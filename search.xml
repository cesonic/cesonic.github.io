<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>数字电子技术基础学习笔记</title>
      <link href="/2024/02/15/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2024/02/15/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="第一章-数制和码制">第一章 数制和码制</h1><p>数制：表示数量的规则</p><p>码制：表示事物的规则</p><ul><li><p>数制</p><p>规定每一位的构成</p><p>规定从低位向高位的进位的规则</p><p>常用二进制，八进制，十进制，十六进制</p><p>进制转换：<span class="math inline">\(v=\sum a^ib_i\)</span></p></li></ul><h2 id="二进制的补码">二进制的补码</h2><p>在定点运算中，最高位为符号位（0为正，1为负）</p><p>这一方法对数制和码制产生的混淆，无法方便地直接运算。</p><p>因此采用补码：最高位若为1，则表达的数是 <span class="math inline">\(-2^{N-1}\)</span>，其他位不变</p><figure><img src="D:\Blog\source_posts\数字电子技术基础学习笔记\image-20240215163452139.png" alt="image-20240215163452139" /><figcaption>image-20240215163452139</figcaption></figure><p>这样编码的数制和码制就统一了，而且可以直接通过相加得到两数的和。</p><p>规律：正数的补码和原码相同，负数的补码为数值位逐位取反+1</p><p>n位二进制和的补码表达范围：<span class="math inline">\([-2^n,2^{n-1}]\)</span></p><p>编码的时候，要为编码位数留足够的余量。</p><p>拓展位数：正数在前补一个0，负数补一个1</p><p>如果编码范围正确，补码直接相加就是加法运算的结果</p><h2 id="几种常见的编码">几种常见的编码</h2><p>数字电路中均选用二进制，二值逻辑，采用等长编码。</p><p>十进制代码：8421码、2421码、余三码、格雷码</p><p>格雷码：每一位的状态变化都按一定的顺序循环，编码顺序依次变化，按表中顺序变化时，相邻代码只有一位改变状态</p><p>ASCII码：用于编码各类符号和控制码的标准代码</p><h2 id="用电压来表达信息">用电压来表达信息</h2><p>用离散的电压序列来表达信息</p><p>优点：容易产生，容易测量，电流值很小时几乎无功耗。</p><p>缺点：容易受到环境影响，容易受到电容电感影响，交直流处理复杂</p><p>利用电压从0到1的值来表达灰度，很容易就可以表达黑白图像。拷贝和取反也非常容易处理。（利用电压跟随器和运算电路）但是多次经过运算电路，图像会失真。因为电压是连续的，无法完全精确地复现一个信号（模拟电子技术的缺点）。这就需要对电压做离散化处理。</p><p>用数字电子技术，系统中只有0和1，这时可靠性就大大提高了。</p><p>优点：可以输入低质量的01信号，输出高质量的01信号（称之为数字模块，导线不是数字模块），可以对抗噪音。</p><p>缺点：长度变长，精度变低</p><h1 id="第二章-逻辑代数基础">第二章 逻辑代数基础</h1><p>逻辑是事物之间的因果关系，数字电路中的逻辑是二值逻辑。</p><p>基本运算：与、或、非（<span class="math inline">\(A\&amp; B,A+B,A&#39;\)</span> 或 <span class="math inline">\(\bar A\)</span>）</p><figure><img src="D:\Blog\source_posts\数字电子技术基础学习笔记\image-20240215175017818.png" alt="image-20240215175017818" /><figcaption>image-20240215175017818</figcaption></figure><p>对基本运算进行组合，可以得到复杂的逻辑运算。</p><p>如：与非、或非、异或（$<span class="math inline">\(）、同或（\)</span><span class="math inline">\(）、与或非（\)</span>(AB+CD)'$）等。</p><p>这样就可以构建逻辑电路。</p><p>逻辑代数的基本公式和常用公式参见课本P24.</p><hr /><h3 id="基本定理">基本定理</h3><ul><li>代入定理：在包含 <span class="math inline">\(A\)</span> 的逻辑等式中，将另外一个逻辑式代入A，等式依然成立</li><li>反演定理：对任意逻辑式 <span class="math inline">\(Y\)</span>，将 且 和 或 互换，将 0 和 1 互换，就可以得到 <span class="math inline">\(Y\)</span> 的反函数 <span class="math inline">\(Y&#39;\)</span>（为了运算顺序不变，应先变换括号，然后变换且，然后变换或；不属于单个变量的取反保留不变）</li><li>对偶定理，对任意逻辑式 <span class="math inline">\(Y\)</span>，执行上述的变换过程变为 <span class="math inline">\(Y^D\)</span>，则有：若 <span class="math inline">\(Y=G\)</span>，则 <span class="math inline">\(Y^D=G^D\)</span></li></ul><p>逻辑函数：以逻辑变量输入，输出单个逻辑变量的函数。可以用真值表（穷举）、逻辑式（与或非）、逻辑图（逻辑符号）、波形图（穷举输入的组合和对应的输出）表示。</p><p>波形图有输入变量个数+1条波形，直接体现真值表。本质是相同的。</p><p>将真值表转换为逻辑式的方法：穷举每个输出为1的真值组，然后相或。例如只有当 <span class="math inline">\((0,1,1),(1,1,0),(1,0,1)\)</span> 为 <span class="math inline">\(1\)</span> ，则逻辑式可以写为 <span class="math inline">\((A&#39;BC)+(ABC&#39;)+(AB&#39;C)\)</span></p><p>枚举输入并得到输出就可以得到逻辑式的真值表表示。</p><p>逻辑图和逻辑式本质是相同的。</p><hr /><h3 id="逻辑式的化简">逻辑式的化简</h3><p>利用各个定理可以转换或简化得到的逻辑式。</p><p>逻辑式的最简形式的定义：与项最少且与项因子最少</p><p>如 <span class="math inline">\(Y_1=ABC+B&#39;C+ACD,Y_2=AC+B&#39;C\)</span></p><p><span class="math inline">\(Y=AC+B&#39;C+BD&#39;+CD&#39;+A(B+C&#39;)+A&#39;BCD&#39;+AB&#39;DE\)</span></p><p>第六项为1，则第三项必须为一，第六项删掉。</p><p><span class="math inline">\(Y=AC+B&#39;C+BD&#39;+CD&#39;+A(B+C&#39;)+AB&#39;DE\)</span></p><p><span class="math inline">\((B+C&#39;)=(B&#39;C)&#39;\)</span>​，所以可以化为</p><p><span class="math inline">\(Y=AC+B&#39;C+BD&#39;+CD&#39;+A+AB&#39;DE\)</span></p><p>这样就可以将所有其他包含A的项消去得到</p><p><span class="math inline">\(Y=B&#39;C+BD&#39;+CD&#39;+A\)</span></p><p>第三项可以被第一和第二项相与得到，故可以删去得到最简式</p><p><span class="math inline">\(Y=B&#39;C+BD&#39;+A\)</span></p><p>通过不同的公式和不同的化简顺序，得到的化简结果也不唯一。</p><hr /><h3 id="逻辑式的最小项和最大项">逻辑式的最小项和最大项</h3><p>逻辑函数可以表达为<strong>最小项</strong>之和和<strong>最大项</strong>之积</p><p>在 <span class="math inline">\(n\)</span> 变量逻辑函数中，若 <span class="math inline">\(m\)</span> 为包含 <span class="math inline">\(n\)</span> 个因子的乘积项，且 <span class="math inline">\(n\)</span> 个变量均在 <span class="math inline">\(m\)</span> 中出现，则称 <span class="math inline">\(m\)</span> 为该组变量的最小项。</p><p>如 <span class="math inline">\(ABC\)</span> ，若将取反视为 <span class="math inline">\(0\)</span> ，不取反视为 <span class="math inline">\(1\)</span>，可以对最小项编号。如 <span class="math inline">\(ABC\)</span> 的编号为 7 ，<span class="math inline">\(AB&#39;C\)</span> 的编号为 2，记为xch当财务报销 <span class="math inline">\(m_7\)</span> 和 <span class="math inline">\(m_5\)</span>. 最小项的数量显然为 <span class="math inline">\(2^n\)</span>。</p><p>最小项有如下性质：</p><ul><li>对于任意输入，有且只有一个最小项取值为1</li><li>全体最小项之和为1</li><li>任何两个最小项之积为0</li><li>相邻（只有一个变量的取反与不取反状态不同）的最小项之和可以合并为其公共因子</li></ul><p>于是可以将与或式表示为最小项之和，如： <span class="math display">\[\begin{align}Y(A,B,C) &amp;=ABC&#39;+BC \\&amp;=ABC&#39;+ABC+A&#39;BC\\&amp;=\sum m(3,6,7)\end{align}\]</span> 逻辑函数的最小项之和表示一定是唯一的，因为这对应一种真值表的表示方法。</p><p>同样地，若 <span class="math inline">\(M\)</span> 为 <span class="math inline">\(n\)</span> 个变量之和，且这 <span class="math inline">\(n\)</span> 个变量均出现一次，则 <span class="math inline">\(M\)</span> 成为最大项。</p><p>将不取反记为0，取反记为1（与最小项是相反的），可以对最大项编号。如 <span class="math inline">\((A&#39;+B+C&#39;)\)</span> 为 <span class="math inline">\(M_5\)</span>，<span class="math inline">\((A+B&#39;+C)\)</span> 为 <span class="math inline">\(M_2\)</span>.</p><p>最大项有如下性质：</p><ul><li>对于任意输入，有且只有一个最大项取值为0</li><li>全体最大项之积为0</li><li>任何两个最大项之和为1</li><li>相邻的最大项之积可以合并，只留下公共因子。</li></ul><p>可以将与或式转换为唯一的最大项之积的形式，如： <span class="math display">\[\begin{align}Y(A,B,C) &amp; =(A+B+C&#39;)(B+C)\\&amp;=(A+B+C&#39;)(B+C+A)(B+C+A&#39;)\\&amp;=\prod M(0,1,4)\end{align}\]</span> 显然有 <span class="math inline">\(m_{(ABC)_2}(A,B,C)=1,M_{(ABC)_2}(A,B,C)=0\)</span> ，且有最大项和最小项互为反函数</p><p>这样，我们就可以将最小项之和最大项之积互相转换</p><p><span class="math inline">\(Y=\sum m_i=(\sum_\limits{k\not = i }m_k)&#39;=\prod _\limits{k\not = i}m_k&#39;=\prod _\limits{k\not = i}M_k\)</span></p><hr /><h3 id="逻辑函数的卡诺图和卡诺图化简法">逻辑函数的卡诺图和卡诺图化简法</h3><p>用 <span class="math inline">\(2^n\)</span> 个代表各个最小项小方格排列成矩阵，使得几何上相邻的方格在逻辑上也相邻。</p><p>利用与格雷码相同的顺序，可以作出任意变量数的卡诺图</p><figure><img src="D:\Blog\source_posts\数字电子技术基础学习笔记\image-20240302222827194.png" alt="image-20240302222827194" /><figcaption>image-20240302222827194</figcaption></figure><p>在五变量的卡诺图中，除了几何位置相邻和相对（在两端），对折起来位置重合的元素也在逻辑上相邻，而四变量及以下的卡诺图只要几何位置相邻或相对，就有逻辑关系的相邻。因此，五变量及以上的卡诺图较少使用。</p><p>将逻辑函数中存在的最小项对应的方格填入1，其余填入0就可以得到该逻辑函数的卡诺图表示法。事实上，就是将使得输出为1的输入对应的方格填1.</p><p>利用卡诺图，可以方便地化简逻辑函数。即二、四、八个相邻最小项可以合并为一项。化简后得到最简与或式。矩形</p><p>要注意的是，每个矩形圈中应至少有个1只被圈到一次。</p><h3 id="具有无关项的逻辑函数及其化简">具有无关项的逻辑函数及其化简</h3><ul><li>约束项：输入的取值有限制，这些被限制的的最小项称为约束项</li><li>任意项：输入的某些取值下，函数的输出不影响逻辑电路功能</li></ul><p>统称约束项和任意项为无关项，它们不一定要写入逻辑式。</p><p>利用无关项可以得到更简单的化简结果</p><p>因为无关项的加入与否不影响最终结果，因此可以通过加入无关项的方式来化简。</p><p>在卡诺图上直观地说，加入无关项，应使得矩形圈最大，矩形数最少。即在卡诺图中，约束项可以视为1，也可以视为0.</p><p>QM法不考。</p><h1 id="第三章-门电路">第三章 门电路</h1><p>门电路是用来实现逻辑运算的电路。门电路用高/低电平表示逻辑状态的0/1，但高低电平是一个范围。且存在正逻辑（高电平表示1，低电平表示0）和负逻辑。</p><p>获得高/低输出电平的电路有单开关电路和互补开关电路。（单开关电路功耗较大，且得不到理想的高低电平）</p><h2 id="半导体二极管门电路">半导体二极管门电路</h2><p>二极管具有单向导电性：正向偏置电压大于开启电压，呈现较小电阻；外加电压反向偏置时，对外呈现很小的电流，近似于截止（少子导电，外加电压过大会击穿）。因此在合理范围内，可以呈现开关特性。因此可以用二极管代替前面所述的互补开关电路的开关。</p><blockquote><p>注：硅管导通时，压降约为0.7V，落在低电平的合理范围内</p></blockquote><figure><img src="D:\Blog\source_posts\数字电子技术基础学习笔记\image-20240303215302306.png" alt="image-20240303215302306" /><figcaption>image-20240303215302306</figcaption></figure><p>当输入是高电平的时候，该开关截止，输出高电平；输入是低电平的时候，该开关导通，输出低电平。</p><figure><img src="D:\Blog\source_posts\数字电子技术基础学习笔记\image-20240303223135367.png" alt="image-20240303223135367" /><figcaption>image-20240303223135367</figcaption></figure><p>这时如果同时连两个二极管，就可以构造与门电路。只有当两个输入都是高电平时，输出才会是高电平。若将0.7V以下视为0，3V以上视为1，则可以得到与门电路。</p><table><thead><tr class="header"><th>A</th><th>B</th><th>Y</th></tr></thead><tbody><tr class="odd"><td>0</td><td>0</td><td>0.7</td></tr><tr class="even"><td>0</td><td>3</td><td>0.7</td></tr><tr class="odd"><td>3</td><td>0</td><td>0.7</td></tr><tr class="even"><td>3</td><td>3</td><td>3.7</td></tr></tbody></table><p>如果将两个一端带有输入信号的二极管并联，然后通过电阻接地，取电阻的压降为输出信号，则信号表达了一个或门。</p><figure><img src="D:\Blog\source_posts\数字电子技术基础学习笔记\image-20240304202841715.png" alt="image-20240304202841715" /><figcaption>image-20240304202841715</figcaption></figure><table><thead><tr class="header"><th>A</th><th>B</th><th>Y</th></tr></thead><tbody><tr class="odd"><td>0</td><td>0</td><td>0</td></tr><tr class="even"><td>0</td><td>3</td><td>2.3</td></tr><tr class="odd"><td>3</td><td>0</td><td>2.3</td></tr><tr class="even"><td>3</td><td>3</td><td>2.3</td></tr></tbody></table><p>上述三种电路，用二极管实现了跟随器、与门和或门。然而，现在还存在三个问题：</p><ul><li>如何选取 R 的大小？</li><li>二极管带来的0.7V的压降如何处理？</li><li>电阻的存在使得带负载能力差</li></ul><p>因此，二极管一般只用于IC内部搭建简单电路。</p><p>为了解决这三个问题，引入CMOS门电路。</p><h2 id="cmos管门电路">CMOS管门电路</h2><h3 id="mos管">MOS管</h3><p>MOS管的性质在模电已经学过。即在 <span class="math inline">\(G\)</span> 极加电压，可以使得MOS管的 <span class="math inline">\(S\)</span> 极和 <span class="math inline">\(D\)</span> 极导通（增强型NMOS）。</p><p>注意到这时 <span class="math inline">\(G\)</span> 极也是个开关。而因为MOS管的输入和输出之间是非常近似于断路的，所以当输入信号足够大时，输入信号的具体大小对输出不构成影响（工作在饱和区），而只起到一个阈值开关的作用。且输入信号不需要电流驱动，只需要提供电压场，从而功耗低。</p><figure><img src="D:\Blog\source_posts\数字电子技术基础学习笔记\image-20240304212944605.png" alt="image-20240304212944605" /><figcaption>image-20240304212944605</figcaption></figure><p>同样地，对于PMOS管，需要G为低电平，才能形成P型的沟道从而导电。</p><p>耗尽型的MOS管在本课程中不涉及。</p><h3 id="用mos管构建互补电路">用MOS管构建互补电路</h3><p>用NMOS管和PMOS管共同组建互补电路，就可以弥补前述单开关电路缺点。而这一互补电路就是CMOS管门电路（Completely MOS）</p><figure><img src="D:\Blog\source_posts\数字电子技术基础学习笔记\image-20240304221938194.png" alt="image-20240304221938194" /><figcaption>image-20240304221938194</figcaption></figure><p>此时，输入是高电平（<span class="math inline">\(V_{DD}\)</span>），上面的管不导通，下面的管导通，输出是低电平；输入是低电平，则输出是高电平。</p><p>这就是CMOS管实现反相器的电路。</p><blockquote><p>讨论极端的情况，考虑输入从$0 $ 到 <span class="math inline">\(V_{DD}\)</span>，输出如何？</p><p>注意到，流经PMOS管的电流一定等于流经NMOS管的电流。</p><figure><img src="D:\Blog\source_posts\数字电子技术基础学习笔记\image-20240304222929087.png" alt="image-20240304222929087" /><figcaption>image-20240304222929087</figcaption></figure><p>那么找到对应电压，红绿两条曲线的交点就是工作点。</p><p>那么，输出电压大致如图：</p><figure><img src="D:\Blog\source_posts\数字电子技术基础学习笔记\image-20240304223317504.png" alt="image-20240304223317504" /><figcaption>image-20240304223317504</figcaption></figure><p>这也可以看出CMOS管的开关特性。这就是一种”可以输出高质量的0/1，可以接纳低质量的0/1“</p></blockquote><p>最理想的情况下，两个MOS管应当一个工作在截止区，一个工作在饱和区。但总存在一个中间状态，使得两个管都工作在线饱和区（导通）。</p><p>若 <span class="math inline">\(T_1,T_2\)</span> 参数完全对称，则当 <span class="math inline">\(V_I=\frac{1}{2}V_{DD}\)</span> 时，<span class="math inline">\(V_O=\frac{1}{2}V_{DD}\)</span>，这就是电压-电压传输特性曲线中间的转折点。且在这个转折点，会出现一个尖峰电流。而在两端，电流趋近于0.</p><p>这意味着我们在高电平和低电平的时候，电流极小，功耗几乎为0。因此CMOS器件静态时功耗几乎为0。</p><blockquote><p>然而动态时会经过中间段，产生功耗。如果工作频率高，出现尖峰电流次数多，功耗也会增加。</p></blockquote><h3 id="cmos管门电路对信号的容差性">CMOS管门电路对信号的容差性</h3><p>为了防止信号的丢失，显然元器件所要输出的高低电平质量，必须要好于输入的高低电平质量。而这质量的差就叫输入噪声容限。</p><figure><img src="D:\Blog\source_posts\数字电子技术基础学习笔记\image-20240304225102793.png" alt="image-20240304225102793" /><figcaption>image-20240304225102793</figcaption></figure><p>即 <span class="math inline">\(V_{NH}=V_{OH}-V_{IH},V_{NL}=V_{IL}-V_{OL}\)</span></p><figure><img src="D:\Blog\source_posts\数字电子技术基础学习笔记\image-20240304225658791.png" alt="image-20240304225658791" /><figcaption>image-20240304225658791</figcaption></figure><p>应当注意到的是，可以通过提高 <span class="math inline">\(V_{DD}\)</span> 来提高CMOS管的噪声容限。</p><h3 id="cmos管门电路的输入保护">CMOS管门电路的输入保护</h3><p>因为门极的二氧化硅层在输入信号 <span class="math inline">\(V_{IN}\)</span> 过高时可能被击穿，因此加入输入保护电路。</p><figure><img src="D:\Blog\source_posts\数字电子技术基础学习笔记\image-20240304230435264.png" alt="image-20240304230435264" /><figcaption>image-20240304230435264</figcaption></figure><p>如图，加入输入保护电路之后，一旦 <span class="math inline">\(V_I&gt;V_{DD}+0.7\)</span> 或 <span class="math inline">\(V_I&lt;-0.7\)</span> ，二极管就将导通，保护MOS管的二氧化硅层。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>2023</title>
      <link href="/2023/12/31/2023/"/>
      <url>/2023/12/31/2023/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><span class="math display">\[\underbrace{\widehat{\overline{\left|\stackrel{\ }{\ _\cup}\stackrel{\bigcap^\cup}{}\stackrel{\ }{\cup^{\ }}\stackrel{\bigcap_\cup}{}\right|}}}\]</span></p><p><span class="math display">\[27e^{\frac{17}{4}}\sqrt{\frac{3}{2}\log (2)\log(3)}\]</span></p><p><font color="white">只记下一些大事吧。</font></p><p><font color="white">当然，由于久远的记忆自然会消散，对于每一年的印象，总是停留在最后的几个月。就算尽力收集以往记忆的碎片，也未曾会觉得这是比现在所经历的和所刚刚经历的重要的。</font></p><p><font color="white">于是，便是对于当下的记录了。</font></p><p><font color="white">一直很享受所喜欢的知识的学习。就算是课程内容也不例外，就算是模电计网这类课程，也能享受到乐趣。这样的话，努力后得到的成绩也非常有满足感呢。</font></p><p><font color="white">然而我相信是存在着我更想学习的内容的，所遗憾的便是课内课程太多，难以去涉猎其他的知识吧，就算是竞赛，也仍然局限在没有精进，兴趣几乎消耗殆尽的算法竞赛上。</font></p><p><font color="white">所想学的内容太多了啊。从实际的，到难以付诸实践的都存在着。想自学一点计算机类的web内容或者人工智能内容，天马行空地，想学vocaloid的创作。想要sekai。但是时间和金钱上都很难允许呢。</font></p><p><font color="white">明年的课业仍旧繁重，怎么办呢？</font></p><p><font color="white">开始听 <span class="math inline">\(\mathtt{Kamitsubaki}\)</span> ，今年，或者说现在，或者近几个月最喜欢的是情绪的鹅妈妈童谣、ハチ的砂之惑星、wowaka的世末舞厅。</font></p><p><font color="white">尽力收集了一些喜欢的CD。トンデモ未来空奏図，一些kamitsubaki。当然，买不到unhappy refrain。</font></p><p><font color="white">今年玩的游戏非常少，而且流程都不怎么长。</font></p><p><font color="white">完成了空洞骑士的最后一个部分。去月球寻找天堂影子工厂，以及在前天和昨天，最后两天完成了oneshot的旅程。玩了一点Arcaea，完全没有入门。随手玩玩几局炉石传说打打牌消磨时间。</font></p><p><font color="white">其实买了不少游戏，但是时间实在难以在上面消耗。我也更享受玩这种独立游戏呢。特别是剧情写的好一些的。</font></p><p><font color="white">2024年还想要更多oneshot这样的游戏，还想要更多歌声，还想要更多喜欢的知识。</font></p><p><font color="white">逐渐地觉得时光飞逝之快了，好在2023并没有太辜负自己的努力，虽然，去年的新年愿望并没有达成多少。感谢2023的自己，以及所有友人们。</font></p><p><font color="white">希望2024不会辜负我现在的期望吧。纵使许多事情一直在发生着，想说出的想法非常多，可以记录的大事更多。但是我也只能记下来非常非常小的一部分。于漫天飞雪中张开双手，却也终究只能抓住其中的一两朵。</font></p><p><font color="white">实在无法作结。</font></p><blockquote><p><font color="white">思いついたら歩いていけ</font></p><p><font color="white">若是想到了就跨步前行吧</font></p><p><font color="white">心残り残さないように</font></p><p><font color="white">不要留下任何遗憾</font></p></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>口题和随笔。</title>
      <link href="/2023/10/22/%E5%8F%A3%E9%A2%98%E5%92%8C%E9%9A%8F%E7%AC%94%E3%80%82/"/>
      <url>/2023/10/22/%E5%8F%A3%E9%A2%98%E5%92%8C%E9%9A%8F%E7%AC%94%E3%80%82/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>稍微看了看今年CSPS。</p><h3 id="a">A</h3><p>暴力枚举1e5个状态，挨个判断能不能到达每个状态即可。</p><p>如果不能过就枚举第一个状态能到达的所有状态再和后面那 <span class="math inline">\(n-1\)</span> 个判一判</p><p>签完了。</p><h3 id="b">B</h3><p>对于 <span class="math inline">\(n=8000\)</span> 的情况，枚举出发点拿个栈向后扫就行。</p><p>听说现在n方能过八千了。流下了时代的眼泪。</p><p>对于随机的情况，考虑到长度大于十的可消除的串基本不存在。那每次判断长度为十的子串就行了。</p><p>对于全是ab的情况，很显然可以压缩成多个连续段，根据段长度和奇偶性处理。</p><p>如果一个全a段长度为k，反正中间那k-2个肯定是自己和自己消除的。然后就很好处理了。</p><p>其他情况暂时还没想。</p><h3 id="d">D</h3><p>二分答案，然后倒推出每个结点的最晚开始时间。然后贪心判断能不能种完。</p><p>做完了。</p><h3 id="c">C</h3><p>太长还没看。</p><hr /><p>其实到这里也就看了半个小时左右。</p><p>题目质量说不上很高，甚至签到题过于签到，据说还有两个原题。</p><p>但是总体切的很愉快，早生了三年，一辈子从来没切的这么愉快过。</p><p>总比icpc西安好，太难绷了早上那场</p><hr /><p>最近的课业越来越繁重了。甚至本学期没有复习周直接期末考。</p><p>现在已经在逐步开始复习，但是进度仍然很赶，很难受。</p><p>过几天还有icpc南京。</p><p>金工实习还有三天的假要补回来，很急。</p><p>暂且继续前进吧。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>积分变换笔记</title>
      <link href="/2023/09/15/%E7%A7%AF%E5%88%86%E5%8F%98%E6%8D%A2%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/09/15/%E7%A7%AF%E5%88%86%E5%8F%98%E6%8D%A2%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>傅里叶变换参见 https://zhuanlan.zhihu.com/p/108017728</p><h1 id="傅里叶变换">傅里叶变换</h1><h2 id="傅里叶变换的定义">傅里叶变换的定义</h2><p>本文不探讨具体本质，只作公式记录</p><p><span class="math inline">\(\hat f(\omega) = \int _{-\infty}^{+\infty}f(\tau )e^{-j\omega \tau}\mathrm{d} \tau\)</span>，也可记为 <span class="math inline">\(F(f(t))\)</span>，这是傅里叶变换</p><p>此时，有 <span class="math display">\[f(t) =\frac{1}{2\pi } \int _{-\infty}^{+\infty}\hat f(\omega )e^{j\omega t}\mathrm{d} \omega\]</span>，记为<span class="math inline">\(F^{-1}(\hat f(\omega))\)</span>，这是傅里叶逆变换</p><p>傅里叶变换和傅里叶逆变换的积分式子基本一致，因此有</p><p><span class="math display">\[\hat {\hat f}(t)=2\pi f(-t) \]</span></p><h2 id="delta-函数"><span class="math inline">\(\delta\)</span> 函数</h2><p><span class="math display">\[\delta (t)=\begin{cases}+\infty ,\quad t=0\\ 0 ,\quad t\not = 0 \end{cases}\]</span></p><p>且 <span class="math inline">\(\int _{-\infty}^{+\infty}\delta(t)=1\)</span></p><p>称其为单位冲激函数。</p><ul><li><p>筛选性质：<span class="math inline">\(\int _{-\infty}^{+\infty} f(t)\delta (t-t_0)\mathrm{d}t=f(t_0)\)</span></p></li><li><p>显然是偶函数</p></li><li><p>记单位阶跃函数：</p><p><span class="math display">\[H(t)=\begin{cases}1 ,\quad t\geq 0\\ 0 ,\quad t&lt; 0 \end{cases}\]</span></p><p>则显然 <span class="math inline">\(H&#39;(t)=\delta (t)\)</span></p></li><li><p><span class="math inline">\(\int ^{+\infty}_{-\infty}\delta ^{(n)}(t-t_0)f(t)\mathrm{d}t=(-1)^nf^{(n)}(t_0)\)</span></p><p>冲激函数的导数可以筛选函数的导数。</p></li></ul><h2 id="傅里叶变换的性质">傅里叶变换的性质</h2><ul><li><p>线性性质：</p><p><span class="math display">\[F(af(t)+bg(t))=aF(\omega )+bG(\omega )\]</span></p></li><li><p>位移性质：</p><p><span class="math inline">\(F(f(t-t_0))=e^{-j\omega t }\hat f(\omega)\)</span></p><p><span class="math inline">\(F^{-1}(\hat f(\omega -a))=e^{jat}f(t)\)</span></p></li><li><p>相似性质：</p><p><span class="math inline">\(F(f(at))=\frac{1}{|a|}\hat f(\frac{\omega}{a})\)</span></p></li><li><p>微分性质：</p><p><span class="math inline">\(F(f&#39;(t))=j\omega \hat f (\omega )\)</span></p><p><span class="math inline">\(F(-jt f(t))=\frac{\mathrm{d}}{\mathrm{d}\omega}\hat f(\omega)\)</span></p></li><li><p>积分性质（要求 <span class="math inline">\(\lim \limits_{t\rightarrow +\infty}\int_{-\infty}^tf(t)\mathrm{d}t=0\)</span>）：</p><p><span class="math inline">\(F[\int_{-\infty}^{t}f(\tau)\mathrm{d}\tau]=\frac{1}{j\omega }\hat f(\omega)\)</span></p></li></ul><blockquote><p>引入卷积 <span class="math inline">\(*\)</span> ：<span class="math inline">\(f(t)*g(t)=\int_{-\infty}^{+\infty}f(\tau)g(t-\tau)\mathrm{d}\tau\)</span></p></blockquote><ul><li><p><span class="math inline">\(F(f(t)*g(t))=\hat f(\omega)\hat g(\omega)\)</span></p><p><span class="math inline">\(F(f(t)g(t))=\frac{1}{2\pi}\hat f(\omega )*\hat g(\omega)\)</span></p></li></ul><p>利用傅里叶变换的微分性质，可以解常微分方程。如：</p><p><span class="math inline">\(ay&#39;&#39;+by&#39;+cy=f\)</span>，则</p><p><span class="math inline">\((a(jw)^2+bjw+c)\hat y=\hat f\)</span></p><p>由此解出 <span class="math inline">\(\hat y\)</span> 和关于 <span class="math inline">\(\hat f\)</span> 的表达式，再做傅里叶逆变换即可。</p><p>由卷积性质，注意到 $f $ 和 <span class="math inline">\(\frac{1}{(a(jw)^2+bjw+c)}\)</span> 的乘积作傅里叶逆变换等同于 <span class="math inline">\(f\)</span> 和 <span class="math inline">\(\frac{1}{(a(jw)^2+bjw+c)}\)</span> 的傅里叶逆变换的卷积。</p><h1 id="拉普拉斯变换">拉普拉斯变换</h1><p><span class="math display">\[F(s)=\int_0^{+\infty} f(t)e^{-st}\mathrm{d}t\]</span></p><p><span class="math inline">\(f(t)H(t)e^{-\beta t}=\frac{1}{2\pi} \int_{-\infty}^{+\infty }F(s)e^{j\omega t}\mathrm{d}\omega\)</span></p><p>若 <span class="math inline">\(f\)</span> 以 <span class="math inline">\(T\)</span> 为周期，则还有：</p><p><span class="math inline">\(F(f(t))=\frac{1}{1-e^{-sT}}\int_0^Tf(r) e^{-sr}\mathrm{d}r\)</span></p><p>这适用于求较难直接变换的函数（如 <span class="math inline">\(|\sin t|\)</span> ）的拉普拉斯变换</p><h2 id="mathcallaplace-变换的性质"><span class="math inline">\(\mathcal{Laplace}\)</span> 变换的性质</h2><ul><li><p><span class="math inline">\(F(f(t^n))=\frac{n!}{s^{n+1}}\)</span></p></li><li><p>线性性质：</p><p><span class="math inline">\(F(af(t)+bg(t))=aF(s)+bG(s)\)</span></p></li><li><p>位移性质：</p><p><span class="math display">\[f(t-t_0)H(t-t_0)\leftrightarrow e^{-st_0}F(s)\]</span></p><p><span class="math inline">\(e^{at}f(t)\leftrightarrow F(s-a)\)</span></p><p>（注意H是单位阶跃函数。）</p></li><li><p>相似性质：</p><p><span class="math inline">\(f(at)\leftrightarrow \frac{1}{a}F(\frac{s}{a})\)</span></p><p>注意这里 <span class="math inline">\(a\)</span> 不能小于 <span class="math inline">\(0\)</span></p></li><li><p>微分积分性质：</p><p><span class="math inline">\(f&#39;(t)\leftrightarrow sF(s)-f(0)\)</span></p><p><span class="math inline">\(-tf(t)\leftrightarrow F&#39;(s)\)</span></p><p><span class="math inline">\(\int_0^t f(\tau )\mathrm{d}\tau \leftrightarrow \frac{1}{s}F(s)\)</span></p><p><span class="math inline">\(\frac{1}{t}f(t)\leftrightarrow \int _s^{\infty}F(\tau)\mathrm{d}\tau\)</span></p></li></ul><h4 id="卷积定理">卷积定理</h4><p><span class="math display">\[f(t)*g(t)\leftrightarrow F(s)G(s)\]</span></p><ol type="1"><li>利用拉普拉斯变换的定义 <span class="math inline">\(F(s)=\int_0^{+\infty} f(t)e^{-st}\mathrm{d}t\)</span>，所以可以先求拉普拉斯变换，然后令 <span class="math inline">\(s=0\)</span> 来得到 <span class="math inline">\(f(t)\)</span> 在正半轴上积分的值。</li><li>利用 <span class="math inline">\(\mathcal L[{\frac{1}{t}f(t)}]=\int _s^{\infty}F(\tau)\mathrm{d}\tau\)</span>，依定义有 <span class="math inline">\(\int_0^{+\infty}\frac{1}{t} f(t)=\int _0^{\infty}F(\tau)\mathrm{d}\tau\)</span>， 当求 <span class="math inline">\(\frac{1}{t}f(t)\)</span> 的积分时，也可以先求 <span class="math inline">\(f(t)\)</span> 的拉普拉斯变换再对 <span class="math inline">\(F(s)\)</span> 求积分，然后令 <span class="math inline">\(s=0\)</span>。</li><li><span class="math inline">\(f(t)=\sum_{k=1}^n \text{Res}(F(s)e^{st},s_k)\)</span></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>一些歌单</title>
      <link href="/2023/09/10/%E4%B8%80%E4%BA%9B%E6%AD%8C%E5%8D%95/"/>
      <url>/2023/09/10/%E4%B8%80%E4%BA%9B%E6%AD%8C%E5%8D%95/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>以后每一个月挑五首歌放上来。</p><h3 id="section">2023.10</h3><ol type="1"><li><p>アンノウン・マザーグース - covered by ヰ世界情緒 / ヰ世界情緒</p></li><li><p>蜘蛛糸モノポリー /sasakure.UK/初音ミク</p></li><li><p>狂言「九十九星降」 / 凋叶棕</p></li><li><p>张士超你昨天晚上到底把我家钥匙放在哪里了？/上海彩虹室内合唱团</p></li><li><p>砂の惑星 / 米津玄師</p></li></ol><h3 id="section-1">2023.11</h3><ol type="1"><li>生存 / ヰ世界情緒/春猿火</li><li>ハッピーホロウと神様俱楽部 cover by ヰ世界情緒, Virtual mini live「parallel canvasⅡ」</li><li>シリウスの心臓 /ヰ世界情緒</li><li>ゆけむり魂温泉 II / 魂音泉</li><li>uzumakinoharu / sasakure.UK</li></ol><h3 id="section-2">2023.12</h3><ol type="1"><li>ワールズエンド・ダンスホール / wowaka</li><li>炉心融解 cover by ヰ世界情緒 / ヰ世界情緒</li><li>Euphoria / IA/じん</li><li>INTERNET OVERDOSE / KOTOKO/Aiobahn</li><li>ワールズエンド・ダンスホール / wowaka/初音ミク</li></ol><h3 id="section-3">2024.1</h3><ol type="1"><li>傀儡阿修羅 / 柊マグネタイト/星界</li><li>神っぽいな / 幸祜</li><li>Euphoria / じん/IA</li><li>傀儡阿修羅 / ヰ世界情緒 feat. 星界</li></ol><h3 id="section-4">2024.2</h3><ol type="1"><li>KICK BACK / 米津玄师</li><li>Bling-Bang-Bang-Born / Creepy Nuts</li></ol><h3 id="section-5">2024.3</h3><ol type="1"><li>マーシャル・マキシマイザー / 可不/柊マグネタイト</li><li></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大学物理下复习和公式整理</title>
      <link href="/2023/09/09/%E5%A4%A7%E5%AD%A6%E7%89%A9%E7%90%86%E4%B8%8B%E5%A4%8D%E4%B9%A0%E5%92%8C%E5%85%AC%E5%BC%8F%E6%95%B4%E7%90%86/"/>
      <url>/2023/09/09/%E5%A4%A7%E5%AD%A6%E7%89%A9%E7%90%86%E4%B8%8B%E5%A4%8D%E4%B9%A0%E5%92%8C%E5%85%AC%E5%BC%8F%E6%95%B4%E7%90%86/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>需要记忆的常量：</p><p>普朗克常量 <span class="math inline">\(h=6.63\times 10^{-34}J\cdot s\)</span></p><p>约化普朗克常数 <span class="math inline">\(\hbar =1.0546\times 10^{-34}\)</span></p><p>氢原子基态 <span class="math inline">\(E_1=-13.6eV\)</span></p><p>电子质量 <span class="math inline">\(m=9.11×10^{-31}\)</span></p><p>光速 <span class="math inline">\(c=3\times 10^{8} m/s\)</span></p><p>真空介电常数 <span class="math inline">\(\varepsilon_0=8.854\times 10^{-12}\)</span></p><p>静电力常量 <span class="math inline">\(k=8.987\times 10^{9}\)</span></p><h1 id="电磁学">电磁学</h1><h2 id="章-静电场">14章 静电场</h2><h3 id="库仑定律">库仑定律：</h3><p><span class="math display">\[F=k\frac{q_1q_2}{r^2}e_r\]</span></p><blockquote><p>其中 <span class="math inline">\(e_r\)</span> 是方向向量。通常引入一个常量 $_0 $ 来代替 <span class="math inline">\(k\)</span> ，有 <span class="math inline">\(k=\frac{1}{4\pi \varepsilon_0}\)</span>，于是</p></blockquote><p><span class="math display">\[F=\frac{1}{4\pi\varepsilon_0}\frac{q_1q_2}{r^2}\]</span></p><h3 id="电场">电场</h3><ul><li>电场强度的原始定义：<span class="math inline">\(E=\frac{F}{q_0}\)</span>，场强有方向。</li><li>场强可以按照向量相加的方式叠加。</li><li>点电荷的场强：<span class="math inline">\(E=\frac{q}{4\pi \varepsilon_0r^2}\)</span></li><li>球形电容器的场强：<span class="math inline">\(E=\frac{q}{4\pi \varepsilon_0r^2}(R_1&lt; r&lt;R_2)\)</span></li><li>由叠加原理，对带电体的场强计算即为上式的积分。</li><li>为了方便积分，引入电荷体密度 <span class="math inline">\(\rho=\frac{\mathrm{d}q}{\mathrm{d}V}\)</span> ，对于均匀带电体，显然有 <span class="math inline">\(\rho=\frac{q}{V}\)</span>，对于带电面和带电细线，定义是类似的。</li></ul><p>一些经典结论：</p><ul><li>无限长的均匀带电细棒的电场大小：<span class="math inline">\(E=\frac{\lambda}{2\pi\epsilon_0a}\)</span>，<span class="math inline">\(\lambda\)</span> 为电荷线密度</li><li>无限大均匀带电平板：<span class="math inline">\(E=\frac{\sigma}{2\epsilon_0}\)</span>，<span class="math inline">\(\sigma\)</span> 为电荷面密度</li><li>均匀带电圆环轴线场强：<span class="math inline">\(E=\frac{1}{4\pi \varepsilon_0}\frac{Qx}{(x^2+R^2)^{3/2}}\)</span></li></ul><p>带电粒子在电场中受到的电场力也可以积分得到，即 <span class="math inline">\(\int E\mathrm{d}q\)</span></p><p>对于静电场，显然有 <span class="math inline">\(\oint_L E \cdot \mathrm{d} L=0\)</span></p><p>这在感生电场中不成立，因为可以出现环流。</p><h3 id="电场强度通量与高斯定理">电场强度通量与高斯定理</h3><p>电场强度通量可以表示为<span class="math inline">\(\Phi_e=\int E \cdot \mathrm{d}S\)</span></p><p>用类似高数下的方式可以证明通过一个闭合曲面的电场强度通量满足：</p><p><span class="math display">\[\Phi_e=\oint E \cdot \mathrm{d}S=\frac{q}{\varepsilon_0}\]</span></p><p>（其中，<span class="math inline">\(q\)</span> 为闭合曲面内的电荷量。）</p><p>此即<strong>电场中的高斯定理</strong>。</p><blockquote><p>由高斯定理，如果通过一个曲面的电场强度均匀，那么就可以由 <span class="math inline">\(q\)</span> 和曲面面积 <span class="math inline">\(S\)</span> 求出该面上每一点的电场强度。</p><p>通过构造这一曲面，有时可以方便计算电场强度。</p></blockquote><h3 id="电势">电势</h3><p>静电场是保守力场，因此可以引入静电势能 <span class="math inline">\(W\)</span>。即要求：</p><p><span class="math display">\[W_a-W_b=\int_a^bq_0E\cdot \mathrm{d}l\]</span></p><p>电势即：</p><p><span class="math inline">\(U_a=\frac{W_a}{q_0}=\int_a^{\text{电势零点}}E\cdot \mathrm{d} l\)</span></p><p>经常选择无穷远处为电势零点。</p><p>由于电场强度是可以叠加的，多个点同时作用于一个点的电势同理也是多个点各自对一个点电势的代数和。</p><p>需要注意的是，电场强度有方向和电势没有方向。</p><p>点电荷的电势：</p><p><span class="math display">\[U_p={\frac{q}{4\pi\varepsilon_0r}}(r\not = 0)\]</span></p><p>通过积分，可以求出半径为 <span class="math inline">\(R\)</span> 的均匀带电球面的空间电势：</p><p><span class="math display">\[U=\frac{q}{4\pi \varepsilon_0R}(r\leq R)\]</span></p><p><span class="math display">\[U=\frac{q}{4\pi \varepsilon_0r}(r\geq R)\]</span></p><p>注意到，场强是电势的微分，电势是场强的积分。因此有：</p><p><span class="math display">\[E_x=-\frac{\partial U}{\partial x},E_y=-\frac{\partial U}{\partial y},E_z=-\frac{\partial U}{\partial z}\]</span></p><p>在这里，<span class="math inline">\(U\)</span> 被视为关于 <span class="math inline">\(x,y,z\)</span> 的三元函数。</p><p>一些其他结论：</p><ul><li>电场强度方向（电场线）和等势面处处正交。</li><li>沿等势面移动，电场力做功为0。</li><li>带电粒子移动一个闭合路径，电场力做功之和为0.</li><li>等势面密集处电场线密集。</li></ul><h2 id="章-静电场中的导体和电介质">15章 静电场中的导体和电介质</h2><h3 id="静电场中的导体">静电场中的导体</h3><p>将导体放入静电场，静电平衡后，电荷仅分布在导体表面（称为感应电荷）。这些电荷的分布与导体表面本身的曲率也有关<strong>（尖端放电）</strong>。</p><p>感应电荷也会影响电场的分布。</p><p>表面电场：</p><p><span class="math display">\[E_表=\frac{\sigma}{\varepsilon_0}e_n\]</span></p><p>其中，<span class="math inline">\(e_n\)</span> 是导体该点处表面单位外法向矢量，<span class="math inline">\(\sigma\)</span> 为电荷面密度。</p><p><strong>静电屏蔽</strong></p><h3 id="静电场中的介质">静电场中的介质</h3><p>电极化强度 <span class="math inline">\(P=\frac{\Sigma p_e}{\Delta V}=\chi _e\varepsilon _0E\)</span></p><p>穿过某闭合面的 <span class="math inline">\(P\)</span> 的通量满足 <span class="math inline">\(\oint _S P\cdot \mathrm{d}S=-\Sigma q&#39;\)</span></p><p>电极化强度等于单位体积内分子的电偶极矩的矢量和。当外电场强度不太强时，等于电极化率 $_e $ 乘以 <span class="math inline">\(\varepsilon_0\)</span> 乘以外电场强度。</p><p><del>这怎么考嘛（小声）</del></p><h4 id="高斯定理和电位移">高斯定理和电位移</h4><blockquote><p>电介质存在时，环流定理仍然成立，即 <span class="math inline">\(\oint_L E \cdot \mathrm{d} L=0\)</span></p><p>其中 <span class="math inline">\(E\)</span> 是自由电荷和磁化电荷的合场强。</p><p>高斯定理也依然成立，但应该表示为 <span class="math inline">\(\oint _S E\cdot \mathrm{d}S=\frac{1}{\varepsilon_0}\Sigma (q_0+q&#39;)\)</span></p><p>但是同时综合 <span class="math inline">\(P\)</span> 的计算公式 <span class="math inline">\(\oint_L E \cdot \mathrm{d} L=\frac{1}{\varepsilon_0} \Sigma q_0-\frac{1}{\varepsilon_0}\oint _S P\cdot \mathrm{d}S\)</span></p><p>即 <span class="math inline">\(\oint _S(\varepsilon_0E+P)\cdot \mathrm{d}S=\Sigma q_0\)</span></p></blockquote><p>定义电位移 <span class="math inline">\(D=\varepsilon E+ P\)</span></p><p>通过以上推导，有</p><p><span class="math display">\[\oint_S D\cdot \mathrm{d}S =\Sigma q_0\]</span></p><p>此即 <strong>介质中的高斯定理</strong></p><p><span class="math inline">\(D=\varepsilon _0E+P=\varepsilon_0E+\chi_e\varepsilon_0E=\varepsilon_0(1+\chi_e)E\)</span></p><p>（相对介电常数）可以将 <span class="math inline">\(1+\chi_e\)</span> 记为 <span class="math inline">\(\varepsilon_r\)</span> ，然后将 <span class="math inline">\(\varepsilon_0\varepsilon_r\)</span> 记为 <span class="math inline">\(\varepsilon\)</span>，即 <span class="math inline">\(D=\varepsilon E\)</span></p><p>真空的介电常数最小，其相对介电常数为1</p><h3 id="电容和电容器">电容和电容器</h3><p>电容的基本单位为法拉，定义电容为：</p><p><span class="math display">\[C=\frac{Q}{U}\]</span></p><blockquote><p>考虑孤立导体球的电容。</p><p>由电势那里的知识，有</p><p><span class="math inline">\(U=\frac{1}{4\pi \varepsilon_0R}\frac{Q}{R}\)</span></p><p>则有 <span class="math inline">\(C=4\pi\varepsilon_0 R\)</span></p></blockquote><blockquote><p>考虑平行板电容器的电容。</p><p>板间距离为 <span class="math inline">\(d\)</span> ，面积为 <span class="math inline">\(S\)</span> ，板间介质介电常量为 <span class="math inline">\(\varepsilon\)</span>，<span class="math inline">\(\sigma = \frac{q}{S}\)</span> 即单位带电量</p><p><span class="math display">\[U_{AB}=\int _A ^B E\cdot \mathrm{d}l=\int_0^d\frac{\sigma}{\varepsilon}\mathrm{d}x=\frac{d\sigma}{\varepsilon}=\frac{qd}{\varepsilon S}\]</span></p></blockquote><p>故有</p><p><span class="math display">\[C=\frac{\varepsilon S}{d}\]</span></p><blockquote><p>推论：介质电容器电容是真空电容器的 <span class="math inline">\(\varepsilon_r\)</span> 倍</p></blockquote><blockquote><p>同理，由高斯定理知道球形电容器场强<span class="math inline">\(E=\frac{q}{4\pi \varepsilon_0r^2}\)</span> ，可以积分出 <span class="math inline">\(C=\frac{4\pi \varepsilon R_1R_2}{R_2-R_1}\)</span> ，当 <span class="math inline">\(R_2\)</span> 远大于 <span class="math inline">\(R_1\)</span> 时，可以发现此即孤立导体球的电容</p></blockquote><h3 id="电场的能量">电场的能量</h3><p>电场能量 <span class="math inline">\(W_e=A=\int_0^Q U\mathrm{d}q\)</span>，在电容器中有 <span class="math inline">\(W_e=\frac{1}{2}CU^2=\frac{1}{2}QU\)</span></p><p>电场能量密度 <span class="math inline">\(w_e=\frac{\mathrm{d}W_e}{\mathrm{d}V}=\frac{1}{2}\varepsilon E^2=\frac{1}{2}DE=\frac{1}{2}\frac{D^2}{\varepsilon}\)</span>，注意单位是 <span class="math inline">\(J\cdot m^{-3}\)</span></p><p>对电场能量密度积分就可以得到电场能量。</p><h2 id="章-稳恒磁场">16章 稳恒磁场</h2><p><span class="math display">\[I=\frac{\mathrm{d}q}{\mathrm{d}t}\]</span></p><p><span class="math display">\[I=\frac{U}{R}\]</span></p><p>记电导 <span class="math inline">\(G=\frac{1}{R}\)</span>，同时电阻满足 <span class="math inline">\(R=\rho \frac{l}{S}\)</span>，其中 <span class="math inline">\(\rho\)</span> 为电阻率，<span class="math inline">\(l\)</span> 为导体长度，<span class="math inline">\(S\)</span> 为导体横截面积。</p><p>计电动势 <span class="math inline">\(\mathcal{E}=\frac{A_\text{非}}{q}\)</span> ，其中 <span class="math inline">\(A_{\text{非}}\)</span> 是单位正电荷在电源内部从负极移动到正极非静电力所做的功。</p><p>电动势与电压是类似的。</p><p>因为电场是保守场，显然有 <span class="math inline">\(\oint_L E\cdot \mathrm{d}l=0\)</span>。</p><p>电场力所做的功 <span class="math inline">\(A=q(U_1-U_2)=It(U_1-U_2)=I^2Rt\)</span>，电功率 <span class="math inline">\(P=I^2R\)</span></p><h3 id="磁场和磁感应强度">磁场和磁感应强度</h3><p><em><strong>电生磁</strong></em></p><blockquote><p>实验发现，电量为 <span class="math inline">\(q_0\)</span> 的电荷在磁场内以 <span class="math inline">\(v\)</span> 的速度运动会受到力，该力与 <span class="math inline">\(v\)</span> 的方向有关，在 <span class="math inline">\(v\)</span> 垂直于 <span class="math inline">\(B\)</span> 时最大，由此定义磁感应强度 <span class="math inline">\(B=\frac{F_{\text{max}}}{q_0v}\)</span>。</p></blockquote><h4 id="毕奥-萨戈尔定律">毕奥-萨戈尔定律</h4><p>载流导线任一电流元产生的磁感应强度：</p><p><span class="math display">\[\mathrm{d}B=\frac{\mu_0}{4\pi}\frac{I\mathrm{d}l\times \overrightarrow r}{r^3}\]</span></p><p><span class="math display">\[B=\int \frac{\mu_0}{4\pi}\frac{I\mathrm{d}l\times \overrightarrow r}{r^3}\]</span></p><p><span class="math inline">\(\mu _0=4\pi \times 10^{-7}H\cdot m^{-1}\)</span> 为真空磁导率</p><p>注意方向。</p><blockquote><p>几个经典结论：</p><p>对于一条载流直导线：<span class="math inline">\(B=\frac{\mu_0I}{4\pi a}(\sin \beta_2 -\sin \beta _1)\)</span>，<span class="math inline">\(\beta\)</span> 为 P 点看向直线两端时与 P 和导线垂线的夹角，<span class="math inline">\(a\)</span> 为与导线所在直线距离。</p><p>当导线无限长时有 <span class="math inline">\(B=\frac{\mu_0I}{2\pi a}\)</span>，半无限长 <span class="math inline">\(B=\frac{\mu_0 I}{4\pi a}\)</span>.</p><p>带电圆环轴线上：<span class="math inline">\(B=\frac{\mu_0}{2}\frac{R^2I}{(R^2+x^2)^{\frac{3}{2}}}\)</span></p><p>螺线管：<span class="math inline">\(\int B=\int _L\frac{\mu_0}{2}\frac{R^2In\mathrm{d}x}{(R^2+x^2)^{\frac{3}{2}}}=\frac{\mu_0}{2}nI(\cos \theta_2-\cos \theta_1)\)</span></p><p>无限长直螺线管：<span class="math inline">\(B=\mu_0nI\)</span></p><p>这些其实都可以轻易积分得到。</p></blockquote><p>匀速运动点电荷产生的磁感应强度：</p><p><span class="math display">\[B=\frac{\mu_0}{4\pi}\frac{q\overrightarrow v \times \overrightarrow r}{r^3}\]</span></p><blockquote><p>这和毕奥-萨戈尔定律形式一致，即 <span class="math inline">\(q\overrightarrow v =q\frac{\mathrm{d}l}{\mathrm{d}t}=I\mathrm{d}l\)</span></p></blockquote><h4 id="磁场中的高斯定理">磁场中的高斯定理</h4><p>定义通过一个曲面的磁通量 <span class="math inline">\(\varPhi _m=\int_S B \cdot \mathrm{d}S\)</span>，单位为韦伯。</p><p>因为磁感应线为闭合曲线，所以在闭合曲面 <span class="math inline">\(S\)</span> 内必然有 <span class="math inline">\(\int_S B \cdot \mathrm{d}S=0\)</span></p><blockquote><p>这与电场中的高斯定理是不同的，因为电场曲面中可以有电荷，从而使电场线全部向外</p></blockquote><h4 id="安培环路定理">安培环路定理</h4><p><span class="math display">\[\oint _L B\cdot \mathrm{d}l=\mu_0\Sigma I_{\text{内}}\]</span></p><p>即磁感应强度沿闭合路径 <span class="math inline">\(L\)</span> 的线积分为穿过该路径的电流的 <span class="math inline">\(\mu_0\)</span> 倍。</p><p>常取圆（设半径为<span class="math inline">\(r\)</span>）为 <span class="math inline">\(L\)</span> ，故 <span class="math inline">\(B=\frac{\mu_0I}{2\pi r}\)</span></p><blockquote><p>课本P115的例题给出了利用安培环路定理证明一个无限长螺线管内部 <span class="math inline">\(B=\mu_0 nI\)</span>的方法。</p></blockquote><h2 id="章-磁场对运动电荷的作用">17章 磁场对运动电荷的作用</h2><h3 id="洛伦兹力">洛伦兹力</h3><p><span class="math display">\[F=qv\times B\]</span></p><blockquote><p><span class="math inline">\(v\)</span> 与 <span class="math inline">\(B\)</span> 垂直时，对于只受洛伦兹力常常有 <span class="math inline">\(qvB=m\frac{v^2}{R}\)</span>，故有 <span class="math inline">\(R=\frac{mv}{qB}\)</span>，周期即为 <span class="math inline">\(T=\frac{2\pi m}{qB}\)</span>.</p><p>成夹角 <span class="math inline">\(\theta\)</span> 时是螺旋线，垂直方向分解成 <span class="math inline">\(v\sin \theta\)</span> 即可。</p></blockquote><p>（霍尔效应不考）</p><h3 id="安培力">安培力</h3><p><span class="math display">\[F=\int I\mathrm{d}l\times B\]</span></p><p>考虑边与磁场平行或垂直的载流线圈，有两条边受力抵消，有两条边受力 <span class="math inline">\(F=Il_2B\)</span> 也大小相等方向相反，但不在一条线上，形成一力偶，力臂为 <span class="math inline">\(l_1\cos \theta\)</span> ，力偶矩为 $Il_1l_2B=ISB$，通常用 <span class="math inline">\(\varphi\)</span> ，线圈法向和磁场方向的夹角，有 <span class="math inline">\(\theta +\varphi=\frac{\pi}{2}\)</span>。但是我们有 <span class="math inline">\(N\)</span> 匝线圈，于是有 <span class="math inline">\(M=NISB\sin \varphi\)</span>，方向为法向和磁场方向叉乘的方向 。</p><h3 id="磁场的功">磁场的功</h3><p><span class="math inline">\(W=I\Delta \varPhi_m\)</span>，$$ 是磁通量变化量。</p><p>对于正在转动的，可以做积分 <span class="math inline">\(W=\int^{\varPhi_{m2}}_{\varPhi_{m1}} I\mathrm{d}\varPhi_m\)</span>。</p><h2 id="章-磁介质">18章 磁介质</h2><p>当磁场 <span class="math inline">\(B_0\)</span> 中真空改为磁介质时间，<span class="math inline">\(B=\mu_rB_0\)</span>。</p><blockquote><p>如长直螺线管中（真空磁导率为 <span class="math inline">\(\mu_0\)</span>），有 <span class="math inline">\(B=\mu_r\mu_0nI\)</span> ，记 <span class="math inline">\(\mu=\mu_r\mu_0\)</span>，则 <span class="math inline">\(B=\mu nI\)</span>。称 <span class="math inline">\(\mu_r\)</span> 为相对磁导率，<span class="math inline">\(\mu\)</span> 为磁导率</p></blockquote><p>抗磁质（<span class="math inline">\(\mu_r &lt;1\)</span>）：<strong>铋</strong>汞铜氢；顺磁质（<span class="math inline">\(\mu_r &gt;1\)</span>）：氢氧铝铂；铁磁质（<span class="math inline">\(\mu_r &gt;&gt;1\)</span>）：<strong>纯铁</strong>，硅钢，坡莫合金。</p><p>（磁介质的磁化和磁介质中的高斯定理<del>应该</del>不考）</p><p>磁介质中也有安培环路定理，其形式为</p><p><span class="math inline">\(\oint _LH\cdot \mathrm{d}l=\sum_{L}I\)</span>，其中<span class="math inline">\(H=\frac{B}{\mu}\)</span></p><h2 id="章-电磁感应">19章 电磁感应</h2><h3 id="法拉第电磁感应定律">法拉第电磁感应定律</h3><p>感应电动势的大小和磁通量变换率成正比。</p><p>即 <span class="math inline">\(\varepsilon_i=-\frac{\mathrm{d}\varPhi m}{\mathrm{d}t}\)</span></p><p>（如果是线圈，需要乘上匝数 <span class="math inline">\(N\)</span>，把乘上后的记为 <span class="math inline">\(\Psi\)</span> 磁链）</p><h3 id="动生电动势和感生电动势">动生电动势和感生电动势</h3><p>动生电动势有 <span class="math inline">\(\varepsilon_i=\int_{(L)}(v\times B)\cdot \mathrm{d}l\)</span></p><p>感生电动势有 <span class="math inline">\(\varepsilon_i=-\oint_S\frac{\partial B}{\partial t}\cdot \mathrm{d}S\)</span></p><blockquote><p>对于一个圆柱形磁场，取一个同心圆区域求圆周上的磁感应强度：</p><p>考虑圆内磁通量变化率为 <span class="math inline">\(\pi r^2\frac{\mathrm{d}B}{\mathrm{d}t}\)</span>，圆周长度 <span class="math inline">\(2\pi r\)</span>，圆上磁感应强度为 <span class="math inline">\(r\frac{\mathrm{d}B}{2\mathrm{d}t}\)</span>。</p><p>需要注意，圆柱形磁场的电动势呈同心圆环状。</p></blockquote><h3 id="自感">自感</h3><p>记自感 <span class="math inline">\(L=\frac{\Psi}{I}\)</span> ，即磁链与电流大小的比值，对于同个器件（如长直螺线管），这是定值。</p><blockquote><p>由安培环路定理，长直螺线管内 <span class="math inline">\(B=\mu_0nI\)</span> ，磁通量 <span class="math inline">\(\varphi = S\mu_0nI\)</span> ，磁链 <span class="math inline">\(\Psi = S\mu_0n^2lI\)</span>，自感系数 <span class="math inline">\(L=V\mu_0n^2\)</span></p><p>注意磁链乘的是匝数不是单位匝数，上面所有小 <span class="math inline">\(n\)</span> 都是单位长度匝数。</p></blockquote><p>互感不考。</p><h3 id="磁能">磁能</h3><p>考虑电感可以储能，储存的方式是磁场，定义这个能为磁能。</p><blockquote><p>考虑电感串联灯泡：</p><p><span class="math display">\[\mathrm{d}W=\varepsilon_Li\mathrm{d}t=-L\frac{\mathrm{d}i}{\mathrm{d}t}i\mathrm{d}t=-Li\mathrm{d}i\]</span></p><p><span class="math display">\[W=\int_l^0-Li\mathrm{d}i=\frac{1}{2}LI^2\]</span></p></blockquote><p>即自感为 <span class="math inline">\(L\)</span> 的线圈通有 <span class="math inline">\(I\)</span> 时磁场能量为 <span class="math inline">\(W=\frac{1}{2}LI^2\)</span>.</p><p>通过长直螺线管可以导出能量密度，即单位体积 <span class="math inline">\(\mathrm{d}V\)</span> 内磁能 <span class="math inline">\(\frac{1}{2}BH \mathrm{d}V\)</span>，则某一磁场总能量 <span class="math inline">\(\frac{1}{2}\int BH\mathrm{d}V\)</span>。这一结论虽然由长治螺线管导出，但是于所有磁场中都适用。</p><h2 id="章-麦克斯韦方程组与电磁波">20章 麦克斯韦方程组与电磁波</h2><h3 id="位移电流和全电流定理">位移电流和全电流定理</h3><blockquote><p>为了使安培环路定理适用于电容中间，考虑电容，两个极板之间也有电流。</p><p>由高斯定理，电位移满足：<span class="math inline">\(\int_S D\cdot \mathrm{d}S=\sigma S=q\)</span></p><p>记电位移通量 <span class="math inline">\(\Psi =\int_S D\cdot \mathrm{d}S\)</span> ，则发现 <span class="math inline">\(I=\frac{\mathrm{d}q}{\mathrm{d}t}=\frac{\mathrm{d}\Psi}{\mathrm{d}t}=S\frac{\mathrm{d}D}{\mathrm{d}t}\)</span> 。</p></blockquote><p>定义位移电流 <span class="math inline">\(I_d=\frac{\mathrm{d}\Psi}{\mathrm{d}t}\)</span>，还有位移电流密度 <span class="math inline">\(\dot J_d=\frac{\mathrm{d}D}{\mathrm{d}t}\)</span></p><p>于是定义全电流 <span class="math inline">\(I_{\text{全}}=I+I_d=I+\frac{\mathrm{d}\Psi}{\mathrm{d}t}\)</span>，全电流的电流密度 <span class="math inline">\(\dot J_{\text{全}}=\dot J+\frac{\mathrm{d}D}{\mathrm{d}t}\)</span>。</p><p>位移电流在磁效应方面和传导电流完全相同，于是有安培环路定理Plus</p><p><span class="math display">\[\oint _LH\cdot \mathrm{d}l=I_{\text{全}}=\sum \limits_LI+I_d=\sum \limits_LI+\frac{\mathrm{d}\Psi}{\mathrm{d}t}\]</span></p><p>写到这里发现20章不考，嘿嘿</p><h1 id="近代物理">近代物理</h1><h2 id="章-狭义相对论">21章 狭义相对论</h2><h3 id="爱因斯坦的相对论时空观">爱因斯坦的相对论时空观</h3><p>对于牛顿绝对时空观，有伽利略坐标变换表明在不同的<strong>惯性系</strong>中，物体的加速度相同。</p><p>狭义相对论下，对于 <span class="math inline">\(S\)</span> 系和具有相对速度 <span class="math inline">\(v\)</span> 的 <span class="math inline">\(S&#39;\)</span> 系存在洛伦兹坐标变换：</p><p><span class="math display">\[\gamma =\frac{1}{\sqrt{1-\frac{v^2}{c^2}}}\]</span></p><p><span class="math inline">\(\Delta t&#39;=\frac{\Delta t}{\sqrt{1-\frac{v^2}{c^2}}}\)</span>，动钟变慢；</p><p>在与杆相对静止的惯性参考系中测得的时间叫固有时 <span class="math inline">\(\Delta t\)</span> 。</p><p><span class="math inline">\(l=l_0\sqrt{1-\frac{v^2}{c^2}}\)</span>，动尺变短。</p><p>在与杆相对静止的惯性参考系中测得的长度叫固有长度 <span class="math inline">\(l_0\)</span>，常用的结论是，固有长度最长。</p><h3 id="相对论动力学">相对论动力学</h3><p>由动量守恒可以推得 <span class="math inline">\(m=\frac{m_0}{\sqrt{1-\frac{v^2}{c^2}}}\)</span></p><p><span class="math inline">\(p=mv=\frac{m_0v}{\sqrt{1-\frac{v^2}{c^2}}}\)</span></p><blockquote><p><span class="math inline">\(F=\frac{\mathrm{d}p}{\mathrm{d}t}=m\frac{\mathrm{d}v}{\mathrm{d}t}+v\frac{\mathrm{d}m}{\mathrm{d}t}\)</span></p></blockquote><p>且动能 <span class="math inline">\(E_k=mc^2-m_0c^2\)</span> ，称前一项为总能量 <span class="math inline">\(E=mc^2\)</span>，后一项为静止能量 <span class="math inline">\(E_0=m_0c^2\)</span>。</p><blockquote><p><span class="math inline">\(E=mc^2=\frac{m_0c^2}{\sqrt{1-\frac{v^2}{c^2}}}\)</span></p><p><span class="math inline">\(p=mv=\frac{m_0v}{\sqrt{1-\frac{v^2}{c^2}}}\)</span></p><p>可以推得：</p></blockquote><p><span class="math inline">\(E^2=E_0^2+p^2c^2\)</span> ，这个可以画成直角三角形。</p><h2 id="章-早期量子论">22章 早期量子论</h2><h3 id="光电效应">光电效应</h3><p>本章里，我们用 <span class="math inline">\(\mathtt v\)</span> 和 <span class="math inline">\(v\)</span> 来区分频率和速度。</p><p>光照射到金属表面时，会有光电子溢出。光电子存在一个最大初动能 <span class="math inline">\(\frac{1}{2}mv_m^2\)</span> ，若电压（反向）和光电子带电量的乘积大于这个动能，则光电子无法溢出。故有：<span class="math inline">\(\frac{1}{2}mv_m^2=eU_a\)</span> 。称 <span class="math inline">\(U_a\)</span> 为遏止电压。</p><p>对于给定的材料，改变入射光频率，发现遏止电压随频率线性变化，且变化幅度与材料无关，即：</p><p><span class="math inline">\(U_a=k\mathtt v-U_0\)</span> ，<span class="math inline">\(k\)</span> 是普适常量，<span class="math inline">\(U_0\)</span> 依赖于材料。</p><p>容易发现，存在红限频率 <span class="math inline">\(v_0=\frac{U_0}{k}\)</span> ，当 <span class="math inline">\(v&lt;v_0\)</span> 时，无论光强多强都无法发生光电效应。</p><ul><li>光电效应是瞬时发生的。</li><li>初动能与光强无关</li></ul><p>这些现象都是经典物理学无法解释的，故爱因斯坦提出了光量子假说。一个光子的能量为 <span class="math inline">\(h\mathtt v\)</span> ，设某金属逸出功为 <span class="math inline">\(A\)</span> ，则：</p><p><span class="math inline">\(h\mathtt{v}=\frac{1}{2}mv^2+A\)</span></p><p>这里 <span class="math inline">\(h\)</span> 是普朗克常量。</p><p>因此也有 <span class="math inline">\(A=h\mathtt v _0\)</span>。</p><p>康普顿效应：<span class="math inline">\(\Delta \lambda =\lambda -\lambda _0=\lambda _c(1-\cos \varphi)\)</span>，其中 <span class="math inline">\(\lambda _C=\frac{h}{m_0c}\approx 2.43\times 10^{-3}\mathrm{nm}\)</span>，称之为康普顿波长。</p><p>光具有波粒二象性，满足：<span class="math inline">\(\varepsilon=h\mathtt v,p=\frac{h}{\lambda}\)</span>，分别是光子的动能和动量。</p><blockquote><p><span class="math inline">\(c=\lambda \mathtt v\)</span></p></blockquote><h3 id="氢原子光谱">氢原子光谱</h3><p>氢原子系统能量是不连续的，取值为：</p><p><span class="math inline">\(E_n=\frac{-13.6}{n^2}eV,n=1,2,3,\cdots\)</span></p><h2 id="量子力学初步">量子力学初步</h2><h3 id="德布罗意波">德布罗意波</h3><p>物质同样具有波粒二象性。一个具有动量 <span class="math inline">\(p\)</span> 和能量 <span class="math inline">\(E\)</span> 的自由粒子，可以对应一个具有确定波长 $$ 和频率 <span class="math inline">\(\mathtt v\)</span> 的波。</p><p><span class="math inline">\(\mathtt v =\frac{E}{h},\lambda = \frac{h}{p}\)</span>，这与爱因斯坦关系是类似的。</p><h3 id="波函数">波函数</h3><p>假设波函数 <span class="math inline">\(\varPsi (x,y,z,t)\)</span>，则由波函数可以确定粒子出现在各个位置的概率。</p><p>关于波函数的定义，在薛定谔方程一节，但是这节不考。</p><p>由归一性原理，有</p><p><span class="math inline">\(\int |\varPsi (x,y,z,t)|^2\mathrm{d}V=1\)</span></p><p>通过这个可以确定 <span class="math inline">\(\varPsi\)</span> 的系数，从而用积分计算某一区间的出现概率。</p><h3 id="氢原子的量子态">氢原子的量子态</h3><p>能量量子化：<span class="math inline">\(E_n=-\frac{13.6}{n^2}\)</span></p><p>角动量量子化：<span class="math inline">\(L=\sqrt{l(l+1)}\hbar\)</span></p><blockquote><p>$$ 是约化普朗克常数，数值上等于 <span class="math inline">\(\frac{h}{2\pi}\)</span></p><p><span class="math inline">\(l\)</span> 为角量子数，对于给定的能级 <span class="math inline">\(n\)</span> ，<span class="math inline">\(l\)</span> 可取 <span class="math inline">\(0\sim n-1\)</span> ，用 <span class="math inline">\(s,p,d,f,\cdots\)</span> 分别表示 <span class="math inline">\(l=0,1,2,3,\cdots\)</span> 的不同量子状态，例如 <span class="math inline">\(2p\)</span> 表示 <span class="math inline">\(n=2,l=1\)</span>。</p></blockquote><p>角动量空间取向量子化：轨道角动量分量 <span class="math inline">\(L_z=m_lh,\quad (m_l=-l\sim +l)\)</span>，即有 <span class="math inline">\(2l+1\)</span> 个不同取向。</p><blockquote><p>确定 <span class="math inline">\(n\)</span> 后，有 <span class="math inline">\(n\)</span> 个 <span class="math inline">\(l\)</span> 的可能取值，从而有 <span class="math inline">\(n\)</span> 个 <span class="math inline">\(L\)</span> 的可能取值和 <span class="math inline">\(2l+1\)</span> 个 <span class="math inline">\(L_z\)</span> 的可能取值</p></blockquote><p>自旋量子数：<span class="math inline">\(s=\frac{1}{2}\)</span>，自旋磁量子数：<span class="math inline">\(m_s=\pm \frac{1}{2}\)</span></p><p>四个量子数就可以确定氢原子核外电子的状态波函数。写作 <span class="math inline">\((n,l,m_l,m_s)\)</span> ，例如基态 <span class="math inline">\((1,0,0,-\frac{1}{2})\)</span></p><p>泡利不相容原理：院子系统内不可能有两个或两个以上电子处在同样的状态。也就是说，若给定 <span class="math inline">\(n\)</span> ，电子的数目最多为 <span class="math inline">\(\sum _{l=0}^{n-1} 2(2l+1)=2n^2\)</span></p><blockquote><p>第一步枚举 <span class="math inline">\(l\)</span>，然后对 <span class="math inline">\(m_l,m_s\)</span> 的可能状态数乘积求和</p></blockquote><p>所以 <span class="math inline">\(s\)</span> 层最多有 2 个电子， <span class="math inline">\(p\)</span> 层 6 个，<span class="math inline">\(d\)</span> 层 10 个，<span class="math inline">\(\cdots\)</span>，这是 $(2l+1) $ 的结果。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>邱关源电路复习简要笔记</title>
      <link href="/2023/06/21/%E9%82%B1%E5%85%B3%E6%BA%90%E7%94%B5%E8%B7%AF%E5%A4%8D%E4%B9%A0%E7%AE%80%E8%A6%81%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/06/21/%E9%82%B1%E5%85%B3%E6%BA%90%E7%94%B5%E8%B7%AF%E5%A4%8D%E4%B9%A0%E7%AE%80%E8%A6%81%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><span class="math inline">\(Y\)</span> 形连接和 <span class="math inline">\(\Delta\)</span> 形连接的等效变换</p><p><span class="math display">\[R_Y=\frac{\Delta \text{相邻电阻乘积}}{\sum R_\Delta} \]</span></p><p><span class="math display">\[G_\Delta = \frac{Y\text{相邻电导乘积}}{\sum G_Y}\]</span></p><p>三个电阻相等，有 <span class="math inline">\(R\Delta =3R_Y\)</span></p><p>戴维宁定理：开路电压，短路电流计算等效电阻</p><p>叠加定理计算时：电流源短路电压源开路</p><p>电感：<span class="math inline">\(i=C\frac{\mathrm{d}u}{\mathrm{d}t}\)</span></p><p>电感：<span class="math inline">\(u=L\frac{\mathrm{d}i}{\mathrm{d}t}\)</span></p><p>换路定则。</p><p>最大功率传输定理</p><p>负载可以任意变化：</p><p>当求负载 <span class="math inline">\(Z_L\)</span> 的最大功率时，现将负载之外的电路用戴维宁等效电路替换为 <span class="math inline">\(&lt;U_S,Z_S&gt;\)</span></p><p>此时有 <span class="math inline">\(Z_S=\overline{Z_C}\)</span> 时负载获得功率最大。</p><p>耦合电感串联：</p><p>顺接串联：<span class="math inline">\(L_{eq}=L_1+L_2+2M\)</span></p><p>反接串联：<span class="math inline">\(L_{eq}=L_1+L_2-2M\)</span></p><p>耦合电感并联：</p><p>同侧并联：同名端连接在同一个节点上：</p><p>可解得 <span class="math inline">\(L_{eq}=\frac{(L_1L_2-M^2)}{L_1+L_2-2M}\)</span></p><p>异侧并联：异名端连接在同一个节点上：</p><p>可解得 <span class="math inline">\(L_{eq}=\frac{(L_1L_2-M^2)}{L_1+L_2+2M}\)</span></p><p>并联电感注意去耦合后两点电压位置会发生移动。</p><p>复功率：<span class="math inline">\(W=U\overline I\)</span></p><p>耦合因数：<span class="math inline">\(k=\frac{M}{\sqrt{L_1L_2}}\)</span></p><p>理想变压器 （输入：输出= <span class="math inline">\(n:1\)</span> ） 输出端接阻抗 <span class="math inline">\(Z_L\)</span> 时，其输入端等效阻抗为 <span class="math inline">\(n^2Z_L\)</span></p><hr /><p>三相电压 <span class="math inline">\(U_A,U_B,U_C\)</span></p><p>（<span class="math inline">\(U_C\)</span> 超前 <span class="math inline">\(U_A\rightarrow\)</span> 正序，对称三相电路）假设 <span class="math inline">\(\dot{U}_A=U_A\angle 0^{\circ},U_A=U_B=U_C,\dot{U}_B=\dot{U}_A\angle -120^{\circ},\dot{U}_C=\dot{U}_A\angle 120^{\circ}\)</span></p><p>电源侧，电流测三角形连接和星（Y）形连接</p><p><img src="D:\Blog\source_posts\邱关源电路复习简要笔记\星形和三角形.jpg" /></p><p>二、<span class="math inline">\(Y-Y\)</span> 三相四线制</p><p><img src="D:\Blog\source_posts\邱关源电路复习简要笔记\三相四线制.jpg" /></p><p>相：一定通过某一个电源或负载</p><p>线电压：两根导线之间的电压；线电流：经过导线的电流</p><table><colgroup><col style="width: 7%" /><col style="width: 46%" /><col style="width: 46%" /></colgroup><thead><tr class="header"><th style="text-align: center;"></th><th style="text-align: center;">电源侧</th><th style="text-align: center;">负载侧</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">相电压</td><td style="text-align: center;"><span class="math inline">\(\dot{U}_A,\dot{U}_B,\dot{U}_C\)</span></td><td style="text-align: center;"><span class="math inline">\(\dot{U}_A&#39;,\dot{U}_B&#39;,\dot{U}_C&#39;\)</span></td></tr><tr class="even"><td style="text-align: center;">相电流</td><td style="text-align: center;"><span class="math inline">\(\dot{I}_A,\dot{I}_B,\dot{I}_C\)</span></td><td style="text-align: center;"><span class="math inline">\(\dot{I}_A,\dot{I}_B,\dot{I}_C\)</span></td></tr><tr class="odd"><td style="text-align: center;">线电压</td><td style="text-align: center;"><span class="math inline">\(\dot{U}_{AB},\dot{U}_{BC},\dot{U}_{CA}\)</span></td><td style="text-align: center;"><span class="math inline">\(\dot{U}_{AB},\dot{U}_{BC},\dot{U}_{CA}\)</span></td></tr><tr class="even"><td style="text-align: center;">线电流</td><td style="text-align: center;"><span class="math inline">\(\dot{I}_A,\dot{I}_B,\dot{I}_C\)</span></td><td style="text-align: center;"><span class="math inline">\(\dot{I}_A,\dot{I}_B,\dot{I}_C\)</span></td></tr></tbody></table><p>判断四个量的关系一定要在同一侧</p><p><img src="D:\Blog\source_posts\邱关源电路复习简要笔记\相电压与线电压的关系.jpg" /></p><p>在本回路中，<span class="math inline">\(\dot{U}_A=\dot{U}_A&#39;,\dot{U}_B=\dot{U}_B&#39;,\dot{U}_C=\dot{U}_C&#39;\)</span>，故也满足上式</p><p>相电流与线电流关系显然。</p><p>三、 $Y-$ 连接</p><p><img src="D:\Blog\source_posts\邱关源电路复习简要笔记\星形接三角形.jpg" /></p><table><colgroup><col style="width: 7%" /><col style="width: 46%" /><col style="width: 46%" /></colgroup><thead><tr class="header"><th style="text-align: center;"></th><th style="text-align: center;">电源侧</th><th style="text-align: center;">负载侧</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">相电压</td><td style="text-align: center;"><span class="math inline">\(\dot{U}_A,\dot{U}_B,\dot{U}_C\)</span></td><td style="text-align: center;"><span class="math inline">\(\dot{U}_{AB},\dot{U}_{BC},\dot{U}_{CA}\)</span></td></tr><tr class="even"><td style="text-align: center;">相电流</td><td style="text-align: center;"><span class="math inline">\(\dot{I}_A,\dot{I}_B,\dot{I}_C\)</span></td><td style="text-align: center;"><span class="math inline">\(\dot{I}_{AB},\dot{I}_{BC},\dot{I}_{CA}\)</span></td></tr><tr class="odd"><td style="text-align: center;">线电压</td><td style="text-align: center;"><span class="math inline">\(\dot{U}_{AB},\dot{U}_{BC},\dot{U}_{CA}\)</span></td><td style="text-align: center;"><span class="math inline">\(\dot{U}_{AB},\dot{U}_{BC},\dot{U}_{CA}\)</span></td></tr><tr class="even"><td style="text-align: center;">线电流</td><td style="text-align: center;"><span class="math inline">\(\dot{I}_A,\dot{I}_B,\dot{I}_C\)</span></td><td style="text-align: center;"><span class="math inline">\(\dot{I}_A,\dot{I}_B,\dot{I}_C\)</span></td></tr></tbody></table><p>电源侧四个量关系显然与之前一致，主要考虑负载侧</p><p>负载侧：</p><p>线电压=相电压</p><p><span class="math display">\[\dot{I}_{AB}=\frac{\dot{U}_{AB}}{Z},\dot{I}_{BC}=\frac{\dot{U}_{BC}}{Z},\dot{I}_{CA}=\frac{\dot{U}_{CA}}{Z}\]</span> <span class="math inline">\(I_A=I_{AB}-I_{CA},I_B=I_{BC}-I_{AB},I_C=I_{CA}-I_{BC}\)</span></p><p><span class="math inline">\(I_{AB}=\frac{U_{AB}}{Z},I_{BC}=\frac{U_{BC}}{Z},I_{CA}=\frac{U_{CA}}{Z}\)</span></p><p><img src="D:\Blog\source_posts\邱关源电路复习简要笔记\相电流与电流的关系.jpg" /></p><p>处理问题时，先把电源、负载化为星形连接</p><p><span class="math inline">\(U_A&#39;=\frac{1}{\sqrt{3}}U_A\angle -30^{\circ}\)</span></p><p><img src="D:\Blog\source_posts\邱关源电路复习简要笔记\负载的转换.png" /></p><p>对称三相四线制电路，中性线上电流为0</p><p>故每条线左右等电势，故有 <span class="math inline">\(I_A=\frac{U_A}{Z_A}\)</span></p><p>Y-Y：<span class="math inline">\(p=3\dot{U}_A\dot{I}_A=\sqrt{3}U_{AB}I_A\)</span></p>]]></content>
      
      
      <categories>
          
          <category> 课程笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>大学物理上-公式整理</title>
      <link href="/2023/06/16/%E5%A4%A7%E5%AD%A6%E7%89%A9%E7%90%86%E4%B8%8A-%E5%85%AC%E5%BC%8F%E6%95%B4%E7%90%86/"/>
      <url>/2023/06/16/%E5%A4%A7%E5%AD%A6%E7%89%A9%E7%90%86%E4%B8%8A-%E5%85%AC%E5%BC%8F%E6%95%B4%E7%90%86/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="经典力学">经典力学</h1><p>质点运动学略</p><p>牛顿运动定律略</p><p><span class="math inline">\(x_c=\int_{\text{物体}}\frac{x\mathrm d m}{m}\)</span></p><h2 id="动量冲量和相关定理">动量，冲量和相关定理</h2><p><span class="math inline">\(\vec p=m\vec v, \vec I =\int_{t_1}^{t_2}\vec F \mathrm{d}t,\vec F=\frac{\mathrm{d}p}{\mathrm{d}t},\int_{t_1}^{t_2}\vec F\mathrm{d}t=\vec {p_2}-\vec{p_1}\)</span></p><h3 id="动量守恒定律">动量守恒定律</h3><p><span class="math inline">\(\vec F=0\)</span> 时，<span class="math inline">\(\vec P\)</span> 为常矢量</p><p><span class="math inline">\(\vec {F_{n}}=0\)</span> 时，<span class="math inline">\(P_n\)</span> 为常量</p><h3 id="角动量">角动量</h3><p>角动量 <span class="math inline">\(\vec L=\vec r\times m\vec v\)</span>，注意是叉乘</p><p>力矩：<span class="math inline">\(\vec M=\vec r \times \vec F\)</span></p><p>注意前者 <span class="math inline">\(\vec r\)</span> 是质点关于参考点的位矢，后者是力作用点关于参考点的位矢</p><ul><li><p>角动量定理</p><p><span class="math inline">\(\vec M=\frac{\mathrm{d}\vec L}{\mathrm{d}t}\)</span></p><p><span class="math inline">\(\int _{t_1}^{t_2}\vec M\mathrm{d}t=\vec{L_2}-\vec{L_2}\)</span></p><p>若 <span class="math inline">\(\vec M=0\)</span>，则 <span class="math inline">\(\vec L\)</span> 为常矢量，即角动量守恒</p></li></ul><h3 id="能">能</h3><p>保守力：<span class="math inline">\(\oint_L \vec{F}=0,E_P=\int^{\text{零势能点}}_a\vec{ F_{\text{保}}}\mathrm{d}r\)</span></p><p>重力势能：<span class="math inline">\(E_p=mgz\)</span>，引力势能：<span class="math inline">\(E_p=-\frac{GMm}{r}\)</span>，弹性势能：<span class="math inline">\(E_p=\frac{1}{2}kx^2\)</span></p><p>机械能 <span class="math inline">\(E=E_k+E_p\)</span>.. 外力和非保守内力做功为 <span class="math inline">\(0\)</span> 则 <span class="math inline">\(E\)</span> 保持不变</p><p>碰撞：动量守恒，完全弹性则机械能也守恒</p><h3 id="刚体运动">刚体运动</h3><p>转动惯量 <span class="math inline">\(J=\int_{\text{物体}}r_i^2\mathrm{d}m\)</span></p><p>杆：<span class="math inline">\(J=\frac{1}{12}ml^2,J=\frac{1}{3}ml^2\)</span>（轴中间，一端）</p><p>圆环：<span class="math inline">\(J=mR^2\)</span>，圆盘：<span class="math inline">\(J=\frac{1}{2}mR^2\)</span></p><p>角动量 <span class="math inline">\(\vec L=J\omega\)</span>，外力对轴力矩 <span class="math inline">\(\vec M=\vec r \times \vec F_{\perp z}\)</span>，注意是叉乘，结果与轴平行。</p><p><span class="math inline">\(\vec M=J\vec \alpha\)</span>. 逆时针为正。</p><p><span class="math inline">\(\frac{\mathrm{d}L}{\mathrm{d}t}=M,\int_{t_1}^{t_2}M\mathrm{d}t=L_2-L_1\)</span></p><p><span class="math inline">\(M=0,L_1=L_2,J_1\omega_1=J_2\omega_2\)</span></p><h3 id="力矩做功转动动能">力矩做功转动动能</h3><p><span class="math inline">\(A=\int_{\theta_1}^{\theta_2}M\mathrm{d}\theta,E_k=\frac{1}{2}J\omega^2\)</span></p><p><span class="math inline">\(\int_{\theta_1}^{\theta_2}M\mathrm{d}\theta=E_{k2}-E_{k1}\)</span></p><h1 id="振动与波动学">振动与波动学</h1><h2 id="振动">振动</h2><h3 id="简谐振动">简谐振动</h3><p><span class="math inline">\(A\cos (\omega t+\varphi)\)</span></p><p>振动频率 <span class="math inline">\(v=\frac{2\pi}{\omega}\)</span> 与振动周期有 <span class="math inline">\(v=\frac{1}{T}\)</span></p><p>通过求导得到简谐振动的速度和加速度。</p><ul><li><p>弹簧-物块振动方程</p><p><span class="math inline">\(-kx=m\frac{\mathrm{d}^2x}{\mathrm{d}t^2}\)</span></p><p>故有微分方程 <span class="math inline">\(\frac{\mathrm{d}^2x}{\mathrm{d}t^2}+\frac{k}{m}x=0\)</span></p><p>解得 <span class="math inline">\(x=A\cos (\sqrt{\frac{k}{m}} t+\varphi)\)</span></p><p>故 <span class="math inline">\(\omega=\sqrt{\frac{k}{m}},T=2\pi\sqrt{\frac{m}{k}}\)</span></p><hr /><p><span class="math inline">\(x=A\cos(\omega t+\varphi ),\omega=\sqrt{\frac{k}{m}},A=\sqrt{x_0^2+\frac{v_0^2}{\omega^2}}\)</span></p><p>再根据题意解出 <span class="math inline">\(\varphi\)</span></p></li><li><p>简谐振动的能量</p><p>动能表达式：<span class="math inline">\(E_k=\frac{1}{2}mv^2=\frac{1}{2}kA^2\sin^2(\omega t+\varphi)\)</span></p><p>势能表达式：<span class="math inline">\(E_p=\frac{1}{2}kx^2=\frac{1}{2}kA^2\cos^2(\omega t+\varphi)\)</span></p><p><span class="math inline">\(\overline{E_k}=\overline{E_p}=\frac{1}{4}kA^2,E=\frac{1}{2}kA^2=\frac{1}{2}m\omega^2\)</span></p></li></ul><h3 id="旋转矢量法">旋转矢量法</h3><p>略</p><h3 id="同方向同频率简谐振动的合成">同方向同频率简谐振动的合成</h3><p><span class="math inline">\(A=\sqrt{A_1^2+A_2^2+2A_1A_2\cos(\varphi_1-\varphi_2)},\tan \varphi=\frac{A_1\sin \varphi_1+A_2\sin \varphi_2}{A_1\cos \varphi_1+A_2\cos \varphi_2}\)</span></p><p>用解析法和旋转矢量法（平行四边形法则）都可以导出该结果。</p><h2 id="波动">波动</h2><p><span class="math inline">\(A\)</span>：波源振幅，<span class="math inline">\(\varphi\)</span>：波源初相位</p><p>T：波源振动周期，<span class="math inline">\(f\)</span>：波源振动频率，<span class="math inline">\(\omega\)</span>：波源振动角频率</p><p><span class="math inline">\(u\)</span>：波速，<span class="math inline">\(\lambda\)</span>：波长</p><p><span class="math inline">\(T=\frac{2\pi}{\omega}=\frac{1}{f},\omega=2\pi f,u=\frac{\lambda}{T}=\lambda f\)</span></p><h3 id="波函数">波函数</h3><p><span class="math inline">\(y(x,t)=A\cos[\omega (t\mp \frac{x}{u})+\varphi]\)</span></p><h3 id="机械波和电磁波">机械波和电磁波</h3><p>机械波的传播需要介质（纵波：固液气；横波：固），电磁波不需要</p><p>波从一种介质进入另一种介质时，频率，周期不变，波速改变，波长改变</p><p>要注意到光的颜色由频率决定而非波长决定，因此光的颜色不会改变。</p><h3 id="波的叠加和干涉">波的叠加和干涉</h3><p>设两波初相位 <span class="math inline">\(\varphi_1,\varphi_2\)</span>，距离 <span class="math inline">\(P\)</span> 点 <span class="math inline">\(r_1,r_2\)</span> ，则有</p><p>相位差：<span class="math inline">\(\Delta \varphi =\varphi_1-\varphi_2-\omega(\frac{r_2-r_1}{u})\)</span></p><p>波程差：<span class="math inline">\(\delta=r_2-r_1-\lambda\frac{\varphi_2-\varphi_1}{2\pi}\)</span></p><p><span class="math inline">\(\Delta \varphi =\pm 2k\pi\)</span> 或 <span class="math inline">\(\delta=\pm k\lambda\)</span> 时，干涉加强</p><p><span class="math inline">\(\Delta \varphi =\pm (2k+1)\pi\)</span> 或 <span class="math inline">\(\delta=\pm \frac{2k+1}{2}\lambda\)</span> 时，干涉减弱</p><h3 id="半波损失">半波损失</h3><p>在固定端反射（或从波疏介质射向波密介质）会产生半波损失</p><p>入射波： <span class="math inline">\(y(x,t)=A\cos[w(t-\frac{x}{u})]\)</span></p><p>反射波：<span class="math inline">\(y(x,t)=Acos[w(t+\frac{x}{u})-\pi]\)</span></p><p>由于半波损失的存在，驻波的固定端产生波节而非波腹。</p><p>已知入射波求反射波时，先确定入射波在反射点的函数，再考虑半波损失后令其传播方向相反即可。</p><h3 id="驻波">驻波</h3><p>驻波的点与点没有能量的传播</p><h3 id="多普勒效应">多普勒效应</h3><p><span class="math inline">\(f_R=\frac{u+v_R}{u-v_S}f_S\)</span>，<span class="math inline">\(v_R\)</span> 是观察者接近波源速度，<span class="math inline">\(v_S\)</span> 是波源接近速度。</p><h1 id="光学">光学</h1><h2 id="双缝干涉">双缝干涉</h2><p>干涉相长：<span class="math inline">\(\frac{d}{D}x=\pm k\lambda\)</span></p><p>干涉相消：<span class="math inline">\(\frac{d}{D}x=\pm(2k+1)\frac{\lambda}{2}\)</span></p><p><span class="math inline">\(d\)</span> 双缝间距，<span class="math inline">\(D\)</span> 板间距离，<span class="math inline">\(x\)</span> 与板中心距离</p><h3 id="明暗纹中心光强">明暗纹中心光强</h3><p><span class="math inline">\(I_1+I_2\pm \sqrt{I_1I_2}\)</span></p><h3 id="光程">光程</h3><p><span class="math inline">\(\text{相位差}=\frac{2\pi}{\lambda}\text{光程差}\)</span></p><p>记为 <span class="math inline">\(\Delta \varphi=\frac{2\pi}{\lambda}\delta\)</span></p><p>当 <span class="math inline">\(\Delta \varphi=\pm 2k\pi\)</span> 时，相长；当 <span class="math inline">\(\Delta \varphi=\pm (2k+1)\pi\)</span> 时，相消；</p><p>或 $=k $ 时，相长；当 <span class="math inline">\(\delta =(2k+1)\frac{\lambda}{2}\)</span>时，相消；</p><h3 id="薄膜干涉">薄膜干涉</h3><p>折射率 <span class="math inline">\(n_1&lt;n_2\)</span> ，1 射入 2 反射时有半波损失</p><p>当 <span class="math inline">\(n_1&lt;n_2&gt;n_3\)</span> 或 <span class="math inline">\(n_1&gt;n_2&lt;n_3\)</span> 时，薄膜干涉有半波损失</p><p>光程差：<span class="math inline">\(\delta=2n_2d\cos r+\frac{\lambda}{2}\)</span>，这里 <span class="math inline">\(r\)</span> 是折射光与垂直方向的夹角</p><p><span class="math inline">\(n_2\cos r=\sqrt{n_2^2-n_2^2\sin^2r}=\sqrt{n_2^2-n_1^2\sin^2i}\)</span>，这里 <span class="math inline">\(i\)</span> 是入射光和垂直方向</p><p>那么 <span class="math inline">\(2d\sqrt{n_2^2-n_1^2\sin^2i}+\frac{\lambda}{2}=k\lambda\)</span> 时，相长；<span class="math inline">\(=(2k+1)\frac{\lambda}{2}\)</span> ，相消</p><h3 id="劈尖">劈尖</h3><p>通常情况下上式 <span class="math inline">\(\sin i=0\)</span> ，故有 <span class="math inline">\(2nd+\frac{\lambda}{2}=k\lambda\)</span> 时相长</p><p><span class="math inline">\(d=\frac{2k-1}{4n}\lambda\)</span> 时明纹；<span class="math inline">\(d=\frac{k}{2n}\lambda\)</span> 时暗纹。（空气折射率 <span class="math inline">\(n=1\)</span> ）</p><p>故相邻两条明或暗纹之间劈尖空气膜厚度相差 $ $</p><p>条纹间距即为 <span class="math inline">\(l=\frac{\lambda}{2n\sin \alpha}=\frac{\lambda}{2n\alpha}\)</span></p><p>干涉条纹向劈尖尖处弯曲，则说明对应点空气膜变厚，故下凹。反之亦然。</p><h3 id="牛顿环">牛顿环</h3><p>类似地，<span class="math inline">\(d=\frac{2k-1}{4}\lambda\)</span> 时明纹；<span class="math inline">\(d=\frac{k}{2}\lambda\)</span> 时暗纹。</p><p>有 <span class="math inline">\(d=\frac{r^2}{2R}\)</span></p><p>故有 <span class="math inline">\(r=\sqrt{\frac{(2k-1)R\lambda}{2}}\)</span> 明纹； <span class="math inline">\(r=\sqrt{kR\lambda}\)</span> 暗纹。</p><p>纹间距內疏外密。</p><h3 id="增透膜增反膜">增透膜，增反膜</h3><p>选取薄膜厚度 <span class="math inline">\(d\)</span> 使得 <span class="math inline">\(2n_2d=(2k+1)\frac{\lambda}{2}\)</span> 干涉相消，从而增强透射光。</p><p>最薄增透膜即为 <span class="math inline">\(d=\frac{4n_2}{\lambda}\)</span></p><p>一般通过多层反射膜增反，使得大部分光被反射。</p><h2 id="单缝夫琅禾费衍射">单缝（夫琅禾费）衍射</h2><h3 id="明暗纹位置">明暗纹位置</h3><p>明纹 ：<span class="math inline">\(\delta =a\sin \theta =\pm (2k+1)\frac{\lambda}{2}\)</span></p><p>暗纹 ：<span class="math inline">\(\delta =a\sin \theta =\pm k\lambda\)</span></p><p>（ <span class="math inline">\(\sin \theta\)</span> 在较小时也可以用 <span class="math inline">\(\frac{x}{f}\)</span> ，焦距与偏离平板中心的距离之比得到）</p><h3 id="中央明纹宽度">中央明纹宽度</h3><p><span class="math inline">\(l=2f\frac{\lambda}{a}\)</span></p><h3 id="半波带数">半波带数</h3><p>明纹：<span class="math inline">\(2k+1\)</span></p><p>暗纹：<span class="math inline">\(2k\)</span></p><h2 id="光栅衍射">光栅衍射</h2><p>主极大：<span class="math inline">\((a+b)\sin \theta=k\lambda\)</span></p><p>若入射光源照射光栅时不垂直，且与垂直方向夹角为 <span class="math inline">\(\varphi\)</span>，则主极大：<span class="math inline">\((a+b)\sin \theta\cos \varphi=k\lambda\)</span></p><p>缺级：<span class="math inline">\(k=\frac{a+b}{a}k&#39;\)</span></p><p>距离中央明纹距离： <span class="math inline">\(f\tan \theta\)</span>，$$ 较小时，<span class="math inline">\(f\theta\)</span></p><h2 id="光的偏振">光的偏振</h2><p>线偏振光</p><p>偏振度 <span class="math inline">\(P=\frac{I_{max}-I_{min}}{I_{max}+I_{min}}\)</span></p><p>顺时针右旋逆时针左旋，吗</p><p>偏振片：<span class="math inline">\(I=I_0\cos^2\alpha\)</span></p><h3 id="布儒斯特定律">布儒斯特定律</h3><p><span class="math inline">\(\tan i_0=\frac{n_2}{n_1}=n_{21}\)</span>（1射入2）</p><p>此时 <span class="math inline">\(i_0+r=\frac{\pi}{2}\)</span>，且反射光为完全偏振光</p><p>可以通过叠加多块玻璃片使得射出的折射光几乎变为完全偏振光。</p><h1 id="热学">热学</h1><p>考纲喵：理想气体的状态方程；理想气体的温度、压强、内能；能均分定理；麦克斯韦速率分布函数的意义和三种统计速率；热力学第一定律在理想气体准静态等值过程（等体、等压、等温）中的应用；热容；定性理解绝热过程；循环过程及热机效率、卡诺循环；热力学第二定律的定性理解及克劳修斯熵的计算。不考气体分子的平均自由程。</p><h2 id="理想气体">理想气体</h2><h3 id="理想气体的状态方程">理想气体的状态方程</h3><p><span class="math display">\[pV=vRT\]</span></p><p><span class="math display">\[v=\frac{m&#39;}{M},\text{用摩尔质量计算的摩尔数};R=\frac{p_0v_0}{T_0},\text{普适气体恒量，8.31(4)}\]</span></p><p><span class="math display">\[p=nkT\]</span></p><p><span class="math display">\[n=N/V,\text{分子数密度};k,\text{玻尔兹曼常数}1.380649 ×\times 10^{-23} J/K\text{，满足}R=kN_A\]</span></p><h3 id="理想气体的温度压强内能">理想气体的温度、压强、内能</h3><p>压强公式</p><p><span class="math display">\[p=\frac{1}{3}nm\overline {v^2} =\frac{2}{3}n\overline\omega,\overline \omega \text{是平均动能}\]</span></p><p>温度公式</p><p><span class="math display">\[\overline \omega =\frac{3}{2}kT\]</span></p><p>内能公式</p><p><span class="math display">\[U=\frac{m&#39;}{M}\frac{i}{2}RT=\frac{i}{2}vRT=\frac{i}{2}pV\]</span></p><h3 id="麦克斯韦速率分布函数的意义和三种统计速率">麦克斯韦速率分布函数的意义和三种统计速率</h3><p><span class="math display">\[f(v)=4\pi (\frac{m}{2\pi kT})^{\frac{3}{2}}v^2e^{\frac{-mv^2}{2kT}}\]</span></p><p>（<span class="math inline">\(m\)</span> 越小或 <span class="math inline">\(T\)</span> 越大时速率分布函数更向左挤）</p><ul><li>最概然速率</li></ul><p><span class="math display">\[v_p=\sqrt{\frac{2kT}{m}}=\sqrt{\frac{2RT}{M}}\approx 1.41\sqrt{\frac{RT}{M}}\]</span></p><p><span class="math display">\[m,\text{分子质量};M,\text{摩尔质量}\]</span></p><ul><li>平均速率</li></ul><p><span class="math display">\[\overline v=\sqrt{\frac{8kT}{\pi m}}=\sqrt{\frac{8RT}{\pi M}}\approx 1.60\sqrt{\frac{RT}{M}}\]</span></p><ul><li>方均根速率</li></ul><p><span class="math display">\[\sqrt{\overline {v^2}}=\sqrt{\frac{3kT}{m}}=\sqrt{\frac{3RT}{M}}\approx 1.73\sqrt{\frac{RT}{M}}\]</span></p><p><del>分子平均碰撞次数</del></p><p><del><span class="math inline">\(\overline Z=\sqrt{2}\pi d^2\overline vn\)</span></del></p><p><del>平均自由程</del></p><p><del><span class="math inline">\(\overline \lambda =\frac{\overline v}{\overline Z}=\frac{1}{\sqrt{2}\pi d^2n}=\frac{kT}{\sqrt{2}\pi d^2p}\)</span></del></p><h2 id="热力学第一定律">热力学第一定律</h2><p><span class="math display">\[ W= \int_{V_1}^{V_2}p\mathrm{d}V,\text{即所谓做功为曲线与 p-V 图 x 轴围成面积}\]</span></p><p><span class="math display">\[Q=\Delta E+W,\text{吸收热量等于内能增加量加对外做功}\]</span></p><h3 id="等容摩尔热容量">等容摩尔热容量</h3><p><span class="math display">\[\mathrm{d}E=\frac{i}{2}R\mathrm{d}T\]</span></p><p><span class="math display">\[C_v=\frac{i}{2}R\]</span></p><h3 id="等压摩尔热容量">等压摩尔热容量</h3><p>比起等容摩尔热容量，还需要对外做功。</p><p><span class="math display">\[(v=1),C_p=\frac{\mathrm{d}Q_p}{\mathrm{d}T}=\frac{\mathrm{d}E+p\mathrm{d}V}{\mathrm{d}T}=\frac{\frac{i}{2}R\mathrm{d}T+R\mathrm{d}T}{\mathrm{d}T}=\frac{i}{2}R\mathrm{d}T+R=C_v+R\]</span></p><h3 id="利用热容计算吸热放热量">利用热容计算吸热放热量</h3><p><span class="math display">\[Q=vC_v(T_2-T_1)\text{（等容）}\]</span></p><p><span class="math display">\[Q=vC_p(T_2-T_1)\text{（等压）}\]</span></p><h3 id="比热容比-gamma">比热容比 <span class="math inline">\(\gamma\)</span></h3><p><span class="math display">\[\gamma=\frac{C_p}{C_V}=\frac{i+2}{i}\]</span></p><p>通式</p><p><span class="math display">\[Q=\Delta E +W\]</span></p><p><span class="math display">\[W=\int_{V_1}^{V_2}p\mathrm{d}V=\int_{V_1}^{V_2}p_1V_1^{\gamma}\frac{\mathrm{d}V}{V^{\gamma}}\]</span></p><p><span class="math display">\[\Delta E=\frac{m&#39;}{M}\frac{i}{2}R\Delta T\]</span></p><p>绝热过程 <span class="math inline">\(p-V\)</span> 方程</p><p><span class="math display">\[pV^\gamma=C\]</span></p><p>由 <span class="math inline">\(pV=vRT=C_1T\)</span>，</p><p><span class="math display">\[TV^{\gamma-1}=C\]</span></p><p><span class="math display">\[p^{\gamma-1}T^{-\gamma}=C\]</span></p><p>（绝热线比等温线陡）</p><p><span class="math display">\[W=\int_{V_1}^{V_2}p\mathrm{d}V=\int_{V_1}^{V_2}p_1V_1^{\gamma}\frac{\mathrm{d}V}{V^{\gamma}}=-\Delta E\]</span></p><p>等温过程：</p><p><span class="math display">\[W=\int_{V_1}^{V_2}p\mathrm{d}V=vRT\ln(\frac{V_2}{V_1})\]</span></p><h3 id="热机效率">热机效率</h3><p><span class="math display">\[\eta = \frac{W}{Q_1}=\frac{Q_1-Q_2}{Q_1}=1-\frac{Q_2}{Q_1},\text{Q1Q2表示从高温热源吸热，向低温热源放热}\]</span></p><p>若为卡诺热机，还有</p><p><span class="math display">\[\eta = \frac{W}{Q_1}=\frac{Q_1-Q_2}{Q_1}=1-\frac{Q_2}{Q_1}=1-\frac{T_2}{T_1},\text{Q1Q2表示从高温热源吸热，向低温热源放热}\]</span></p><h3 id="制冷机制冷系数">制冷机制冷系数</h3><p><span class="math display">\[e=\frac{Q_2}{W}=\frac{Q_2}{Q_1-Q_2}\text{（Q1Q2，向高温热源放热，从低温热源吸热）W:工件对外界做功}\]</span></p><p>若为卡诺制冷机，还有</p><p><span class="math display">\[e=\frac{Q_2}{W}=\frac{Q_2}{Q_1-Q_2}=\frac{T_2}{T_1-T_2}\]</span></p><h2 id="热力学第二定理">热力学第二定理</h2><h3 id="克劳修斯熵公式对单个系统">克劳修斯熵公式（对单个系统）：</h3><p><span class="math display">\[\Delta S=S_B-S_A=\int_A^B\frac{\mathrm{d}Q}{T}\]</span></p><h3 id="热传导中的熵变从高温热源-a-传向低温热源-b">热传导中的熵变（从高温热源 A 传向低温热源 B ）：</h3><p><span class="math display">\[\mathrm{d}S_A=\frac{-\mathrm{d}Q}{T_A},\mathrm{d}S_B=\frac{\mathrm{d}Q}{T_B}\]</span></p><p><span class="math display">\[\mathrm{d}S=\mathrm{d}S_A+\mathrm{d}S_B=-\frac{\mathrm{d}Q}{T_A}+\frac{\mathrm{d}Q}{T_B} &gt;0\]</span></p><h3 id="自由膨胀过程的熵变">自由膨胀过程的熵变：</h3><p><span class="math display">\[(p_1,V_1,T)\rightarrow (p_2,V_2,T)\]</span></p><p>假设等温膨胀。</p><p><span class="math display">\[Q=0,W=0\Rightarrow \Delta E=0,\Delta T=0\]</span></p><p><span class="math display">\[\int_1^2\frac{\mathrm{d}Q}{T}=\int_{V_1}^{V_2}\frac{m&#39;}{M}R\frac{\mathrm{d}V}{V}=\frac{m&#39;}{M}R\ln\frac{V_2}{V_1}&gt;0\]</span></p><p><del>自由膨胀的玻尔兹曼熵：</del>玻尔兹曼熵不考</p><p><del>一个分子在 <span class="math inline">\(V_1\)</span> 内具有微观态数：<span class="math inline">\(\omega_1=\frac{V_1}{\tau}\)</span></del></p><p><span class="math inline">\(N\)</span> 个分子在 <span class="math inline">\(V_1\)</span> 内具有微观态数：<span class="math inline">\(W_1=(\frac{V_1}{\tau})^n\)</span></p><p><span class="math inline">\(N\)</span> 个分子在 <span class="math inline">\(V_2\)</span> 内具有微观态数：<span class="math inline">\(W_2=(\frac{V_2}{\tau})^n\)</span></p><p><span class="math display">\[\frac{W_1}{W_2}=(\frac{V_1}{V_2})^n\]</span></p><p>两边取自然对数再乘玻尔兹曼常数 <span class="math inline">\(k\)</span>，</p><p><span class="math display">\[k\ln\frac{W_2}{W_1}=kN\ln\frac{V_2}{V_1}=kvN_A\ln\frac{V_2}{V_1}=vR\ln \frac{V_2}{V_1}\]</span></p><p>此即由克劳修斯熵公式导出的等温膨胀结果。</p><p><span class="math display">\[\Delta S=k\ln\frac{W_2}{W_1}=k\ln W_2-k\ln W_1\]</span></p><p>称 <span class="math inline">\(S=k\ln W\)</span> 为玻尔兹曼熵公式。</p><hr /><p>等温膨胀熵变（已经推导过，直接给出结果）</p><p><span class="math display">\[\Delta S=vR\ln\frac{V_2}{V_1}\]</span></p><p>等压过程熵变：</p><p><span class="math display">\[\Delta S=\int_{T_1}^{T_2}\frac{\delta Q}{T}=\int_{T_1}^{T_2}\frac{C_{p,m}\mathrm{d}T}{T}=C_{p,m}\ln \frac{T_2}{T_1}\]</span></p><p>等容过程熵变：</p><p><span class="math display">\[\Delta S=\int_{T_1}^{T_2}\frac{\delta Q}{T}=\int_{T_1}^{T_2}\frac{C_{V,m}\mathrm{d}T}{T}=C_{V,m}\ln \frac{T_2}{T_1}\]</span></p>]]></content>
      
      
      <categories>
          
          <category> 课程笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>《概率论与数理统计》定义/性质速通</title>
      <link href="/2023/05/17/%E3%80%8A%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1%E3%80%8B%E5%AE%9A%E4%B9%89-%E6%80%A7%E8%B4%A8%E9%80%9F%E9%80%9A/"/>
      <url>/2023/05/17/%E3%80%8A%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1%E3%80%8B%E5%AE%9A%E4%B9%89-%E6%80%A7%E8%B4%A8%E9%80%9F%E9%80%9A/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="杂项概念">杂项概念</h2><ul><li><p>分布函数的三个性质：若 <span class="math inline">\(a\geq b\)</span>，则 <span class="math inline">\(F(a)\geq F(b); \mathop{\lim}\limits_{x\rightarrow -\infty} F(x)=0,\mathop{\lim}\limits_{x\rightarrow +\infty} F(x)=1;\mathop{\lim}\limits_{x\rightarrow a^+} F(x)=F(a)\)</span></p></li><li><p>二项分布最可能取值：<span class="math inline">\((n+1)p\in N\rightarrow (n+1)p,(n+1)p-1; (n+1)p\notin N\rightarrow [(n+1)p]\)</span></p></li><li>已知 <span class="math inline">\(f_x(x) ,Y=g(X)\)</span> 求 <span class="math inline">\(f_y(y)\)</span><ul><li>对<span class="math inline">\(x\)</span>积分后对 <span class="math inline">\(y\)</span> 求导</li><li>反函数：<span class="math inline">\(h(Y)=X\)</span></li><li>单调段：<span class="math inline">\(f_Y(y)=f_x(h(y))|h&#39;(y)|\)</span></li><li>不单调段：<span class="math inline">\(f_Y(y)=f_x(h_1(y))|h_1&#39;(y)|+f_x(h_2(y))|h_2&#39;(y)|\)</span></li></ul></li><li><span class="math inline">\(F(x,y)=\int_{-\infty}^x\int_{-\infty}^yf(x,y)\mathrm{d}x\mathrm{d}y,F_x(x)=\int_{-\infty}^xf_x(x)\mathrm{d}x,f_x(x)=\int_{-\infty}^{+\infty}f(x,y)\mathrm{d}x\)</span></li><li>若 <span class="math inline">\(F(x,y)=F_x(x)\cdot F_y(y)\)</span> 或 <span class="math inline">\(f(x,y)=f_x(x)\cdot f_y(y)\)</span> ，则 <span class="math inline">\(x,y\)</span> 相互独立</li><li>条件密度函数<ul><li><span class="math inline">\(f_{Y|X}(y|x)=\frac{f(x,y)}{f_x(x)},F_{Y|X}(y|x)=\int_{-\infty}^{y}f_{Y|X}(y|x)\mathrm{d}y\)</span></li></ul></li><li>二维正态分布：五个参数确定，不能由两个一维正态分布确定</li><li>切比雪夫不等式：<ul><li><span class="math inline">\(P(|X-E(X)|\geq \varepsilon)\leq \frac{D(X)}{\varepsilon ^2}\)</span></li><li><span class="math inline">\(P(|X-E(X)|\leq \varepsilon)\geq 1-\frac{D(X)}{\varepsilon ^2}\)</span></li></ul></li></ul><h2 id="期望与方差">期望与方差</h2><ul><li><span class="math inline">\(\mathrm{Var}[X]=E[X^2]-E[X]^2\)</span></li><li>若 <span class="math inline">\(X,Y\)</span> 相互独立（且都存在数学期望），则 <span class="math inline">\(E[aX+bY]=aE[X]+bE[Y],E[XY]=E[X]\cdot E[Y]\)</span></li><li><span class="math inline">\(\mathrm{Var}[aX+bY]=a^2\mathrm{Var}[X]+b^2\mathrm{Var}[Y]\)</span></li></ul><h3 id="偏度和峰度">偏度和峰度</h3><p>称</p><p><span class="math display">\[\frac{E[(X-E[X])^3]}{\mathrm{(Var}[X])^{\frac{3}{2}}}\]</span></p><p>为 <span class="math inline">\(X\)</span> 的偏度，而称</p><p><span class="math display">\[\frac{E[(X-E[X])^4]}{(\mathrm{Var}[X])^2}\]</span></p><p>为 <span class="math inline">\(X\)</span> 的峰度.</p><h3 id="协方差和相关系数">协方差和相关系数</h3><p>称</p><p><span class="math display">\[\mathrm{Cov}(X,Y)=E[(X-E[X])(Y-E[Y])]\]</span></p><p>为 <span class="math inline">\(X\)</span> , <span class="math inline">\(Y\)</span> 的协方差. 可以证明:</p><p><span class="math display">\[\mathrm{Cov}(X,Y)=E[XY]-E[X]\cdot E[Y]\]</span></p><p>称</p><p><span class="math display">\[r(X,Y)=\frac{\mathrm{Cov}(X,Y)}{\sqrt{\mathrm{Var}[X]\cdot \mathrm{Var}[Y]}}\]</span></p><p>为 <span class="math inline">\(X\)</span> , <span class="math inline">\(Y\)</span> 的相关系数，有：</p><ul><li><p>若 <span class="math inline">\(r(X,Y)=0\)</span>，则 <span class="math inline">\(X,Y\)</span> 不相关</p></li><li><p>若 <span class="math inline">\(X\)</span> 与 <span class="math inline">\(Y\)</span> 独立，则 <span class="math inline">\(\mathrm{Cov}(X,Y)=r(X,Y)=0\)</span></p></li><li><p>若 <span class="math inline">\(r=\pm1\)</span> ，则存在 <span class="math inline">\(a,b (a&gt;0)\)</span> 使得 <span class="math inline">\(Y=\pm ax+b\)</span></p></li><li><p>$ [X,Y]=(Y,X)$</p></li><li><p>独立则一定不相关，但不相关不一定独立</p></li><li><p><span class="math inline">\(\mathrm{Var}[aX+bY]=a^2\mathrm{Var}[X]+b^2\mathrm{Var}]Y]+2ab\mathrm{Cov}(X,Y)\)</span> （若 <span class="math inline">\(X,Y\)</span> 相互独立，显然没有协方差一项.）</p></li><li><p><span class="math inline">\(\mathrm{Cov}(aX+bY,Z)=a\mathrm{Cov(X,Z)}+b\mathrm{Cov}(y,z)\)</span></p></li></ul><h2 id="分布">分布</h2><h3 id="分布-1">0-1 分布</h3><p><span class="math inline">\(P(X=1)=p,P(x=0)=1-p\)</span></p><h3 id="几何分布">几何分布</h3><p><span class="math inline">\(P(X=k)=p(1-p)^{k-1}\)</span>，取第 <span class="math inline">\(k\)</span> 次第一次取到的概率。</p><p><span class="math inline">\(\overline X=(\frac{1}{p}),D(X)=\frac{1-p}{p^2}\)</span></p><h3 id="二项分布">二项分布</h3><p><span class="math inline">\(n\)</span> 重的 0-1 分布</p><p>若</p><p><span class="math display">\[P(X=k)={n\choose k}p^k(1-p)^{n-k}\]</span></p><p>则称 <span class="math inline">\(X\)</span> 服从<strong>二项分布</strong>，记为 <span class="math inline">\(X\sim B(n,p)\)</span>.</p><p>性质：<span class="math inline">\(E[X]=np, \mathrm{Var}[X]=np(1-p)\)</span>.</p><p>可以将 <span class="math inline">\(n\)</span> 足够大的二项分布视为正态分布，有 <span class="math inline">\(\mu =np,\sigma^2=np(1-p)\)</span></p><h3 id="泊松分布">泊松分布</h3><p>二项分布的极限分布</p><p><span class="math display">\[P(X=k)=\frac{\lambda^k}{k!}e^{-\lambda},k=0,1,2,\cdots\]</span></p><p>记为 <span class="math inline">\(X\sim \mathrm{Pois}(\lambda)\)</span> 或 <span class="math inline">\(\mathrm P(\lambda)\)</span>.</p><p>二项分布 <span class="math inline">\(n\rightarrow \infty,np\rightarrow \lambda\)</span> 时服从泊松分布.</p><p>若二项分布 <span class="math inline">\(n\)</span> 足够大且 <span class="math inline">\(p\)</span> 足够小，就可以用泊松分布来估计.</p><p>特别地，<span class="math inline">\(E[X]=\mathrm{Var}[X]=\lambda\)</span>.</p><h3 id="正态分布">正态分布</h3><p>若</p><p><span class="math display">\[f_X(x)=\frac{1}{\sqrt{2\pi}\sigma}e^{-\frac{(x-\mu)^2}{2\sigma^2}},-\infty&lt;x&lt;+\infty\]</span></p><p>则称 <span class="math inline">\(X\)</span> 服从正态分布，记为 <span class="math inline">\(X\sim N(\mu,\sigma^2)\)</span>.</p><p><span class="math inline">\(N(0,1)\)</span> 是标准正态分布.</p><p>对于标准正态分布，有：</p><p>分部密度函数</p><p><span class="math display">\[\phi(x)=\frac{1}{\sqrt{2\pi}}e^{-\frac{x^2}{2}}\]</span></p><p>分布函数：</p><p><span class="math display">\[\Phi(x)=\frac{1}{\sqrt{2\pi}}\int_{-\infty}^xe^{-\frac{t^2}{2}}\mathrm{d}t\]</span></p><p>一般的正态分布 <span class="math inline">\(X\sim N(\mu,\sigma^2 )\)</span> 可以通过以下转换变为标准正态分布</p><ul><li><span class="math inline">\(Y=\frac{X-\mu}{\sigma}\)</span></li></ul><p>分部函数 <span class="math inline">\(\Phi\)</span> 难以积分，一般查表得到。</p><ul><li><p>设总体 <span class="math inline">\(X\sim N(0,1),(X_1,X_2,\cdots,X_n)\)</span> 为其样本,则</p></li><li><ul><li><span class="math inline">\(\overline X=\frac{1}{n}\sum_{i=1}^nX_i\sim N(0,\frac{1}{n}))\)</span></li></ul></li><li><ul><li><span class="math display">\[nS_n^2=\sum_{i=1}^{n}(X_i-\overline X)^2\sim \chi^2(n-1)\]</span></li></ul></li></ul><p>更一般地说, 正态总体的五条性质，设总体 <span class="math inline">\(X\sim N(\mu,\sigma^2),(X_1,X_2,\cdots,X_n)\)</span> 为其样本,则</p><ul><li><p><span class="math inline">\(\overline X\sim N(\mu,\frac{\sigma^2}{n}))\)</span>，或表述为 <span class="math inline">\(E(X)=\mu ,D(X)=\frac{\sigma ^2}{n}\)</span></p></li><li><span class="math display">\[\frac{nS_n^2}{\sigma^2}=\sum_{i=1}^{n}(X_i-\overline X)^2\sim \chi^2(n-1)\]</span></li><li><span class="math display">\[\frac{\overline X-\mu}{\frac{S}{\sqrt{n}}}\sim t(n-1)\]</span></li><li>$X $ 和 <span class="math inline">\(S_n^2\)</span> 独立</li><li><p><span class="math inline">\(E(S^2)=\sigma ^2\)</span></p></li></ul><p>两个正态总体下的两条结论：</p><ul><li><span class="math display">\[\frac{\frac{S_1^2}{\sigma_1^2}}{\frac{S_2^2}{\sigma_2^2}}\sim F(n_1,n_2)\]</span></li><li><span class="math display">\[\frac{\overline X - \overline Y -(\mu_1-\mu_2)}{\sqrt{\frac{(n_1-1)S_X+(n_2-1)S_Y}{n_1+n_2-2}}\sqrt{\frac{1}{n_1}+\frac{1}{n_2}}}\sim t(n_1+n_2-2)\text{（t 分布的可加性）}\]</span></li></ul><p>若 <span class="math inline">\(X\sim N(u_1,m),Y\sim N(u_2,n)\)</span></p><p>则 <span class="math inline">\(Z=X±Y\sim N(u_1±u_2,m+n)\)</span></p><h3 id="指数分布">指数分布</h3><p>密度函数:</p><p><span class="math display">\[f(x)=\lambda e^{-\lambda x},(x&gt;0)\]</span></p><p>数学期望 <span class="math inline">\(\frac{1}{\lambda}\)</span> , 方差 <span class="math inline">\(\frac{1}{\lambda^2}\)</span></p><h3 id="均匀分布">均匀分布</h3><p><span class="math inline">\(X\)</span> 在一个区间 <span class="math inline">\([a,b]\)</span> 内平均分布.</p><p>容易得到</p><p><span class="math display">\[E(X)=\frac{b-a}{2}\]</span></p><p><span class="math display">\[\mathrm{Var}[X]=E[X^2]-E[X]^2=\int_a^b\frac{x^2}{b-a}\mathrm{d}x-(\frac{a+b}{2})^2=\frac{(b-a)^2}{12}\]</span></p><hr /><p>接下来三个分布是数理统计中的三大分布（都是连续型），他们都与正态分布具有密切联系</p><h3 id="卡方分布">卡方分布</h3><p><span class="math inline">\(\chi ^2\)</span> 分布.</p><p><span class="math inline">\(n\)</span> 个均服从标准正态分布的随机变量的平方和构成的新的随机变量的分布称为<span class="math inline">\(\chi ^2\)</span> 分布. 且该卡方分布 <strong>自由度为 <span class="math inline">\(n\)</span> </strong>.</p><p>自由度是随机变量的个数.</p><ol type="1"><li>设 <span class="math inline">\(X\sim \chi^2(n)\)</span> , 则可以得到</li></ol><p><span class="math display">\[E(X)=n,\mathrm{Var}[X]=2n\]</span></p><ol start="2" type="1"><li><p>若 <span class="math inline">\(X_1\sim \chi^2(n_1),X_2\sim \chi^2(n_2)\)</span>, 则 <span class="math inline">\(X_1+X_2\sim \chi ^2(n_1+n_2)\)</span></p></li><li><p>若 <span class="math inline">\(X\sim \chi^2(n),n\rightarrow +\infty\)</span> , 则 <span class="math inline">\(\frac{X-n}{\sqrt{2n}}\sim N(0,1)\)</span>. （用中心极限定理很容易证明, <span class="math inline">\(\mu=1,\sigma^2=2\)</span>）</p></li><li><p>设 <span class="math inline">\(X_1,X_2,X_3,\cdots,X_n\)</span> 为取自正态总体 <span class="math inline">\(X\sim N(\mu,\sigma ^2)\)</span> 的样本，则</p></li></ol><p><span class="math display">\[\frac{1}{\sigma^2} \sum_1^n(X_i-\mu)^2\sim \chi ^2 (n-1)\]</span></p><p>（证明，<span class="math inline">\(\frac{X_i-\mu}{\sigma}\sim N(0,1)\)</span>，且相互独立，将<span class="math inline">\((\frac{X_i-\mu}{\sigma})^2\)</span>加起来即可）</p><ol start="5" type="1"><li>设 <span class="math inline">\(X_1,X_2,X_3,\cdots,X_n\)</span> 为取自正态总体 <span class="math inline">\(X\sim N(\mu,\sigma ^2)\)</span> 的样本，则样本均值 <span class="math inline">\(\overline X\)</span> 与样本方差 <span class="math inline">\(S_n^2\)</span> 相互独立，且</li></ol><p><span class="math display">\[\overline X\sim N(\mu,\frac{\sigma ^2}{n})\]</span></p><p><span class="math display">\[\frac{nS_n^2}{\sigma^2}=\frac{1}{\sigma^2} \sum_1^n(X_i-\overline X)^2\sim \chi ^2 (n)\text{(注意与 4 中的式子对比)}\]</span></p><p>为什么该式子自由度变为 <span class="math inline">\(n-1\)</span> ?</p><p>表面上看 $ _1<sup>n(X_i-X)</sup>2$ 是 <span class="math inline">\(n\)</span> 个独立正态随机变量的平方和，实际上他们并<strong>不独立</strong>，因为有 <span class="math inline">\(\sum_1^n(X_i-\overline X) =0\)</span> 故一旦 <span class="math inline">\(n\)</span> 个值中的 <span class="math inline">\(n-1\)</span> 个确定，第 <span class="math inline">\(n\)</span> 个也随之确定.</p><p><strong>抽样分布基本定理</strong>是上述定理的特例:</p><p>设 <span class="math inline">\(X_1,X_2,X_3,\cdots,X_n\)</span> 为取自正态总体 <span class="math inline">\(X\sim N(0,1)\)</span> 的样本，则样本均值 <span class="math inline">\(\overline X\)</span> 和方差 <span class="math inline">\(S_n^2\)</span> 相互独立，且</p><p><span class="math display">\[\overline X\sim N(0,\frac{1}{n})\]</span></p><p><span class="math display">\[nS_n^2\sim \chi ^2(n-1)\]</span></p><h3 id="t分布">t分布</h3><p>若 <span class="math inline">\(X\sim N(0,1),Y\sim \chi^2(n)\)</span> 且相互独立, 则称</p><p><span class="math display">\[T=\frac{X}{\sqrt{Y/n}}\]</span></p><p>服从自由度为 <span class="math inline">\(n\)</span> 的 t分布, 记作 <span class="math inline">\(t(n)\)</span>.</p><h3 id="f分布">F分布</h3><p>若 <span class="math inline">\(X\sim \chi^2(m),Y\sim \chi ^2(n)\)</span>,则称 <span class="math inline">\(Z=\frac{X/m}{Y/n}\)</span> 服从 F分布. 记作 <span class="math inline">\(Z\sim F(m,n)\)</span>.</p><p>注意到，若 <span class="math inline">\(T\sim t(n)(X\sim N(0,1),Y\sim \chi^2(n))\)</span>，则有 <span class="math inline">\(T^2\sim \frac{X^2}{Y/n}=\frac{\chi^2(1)}{Y/n}=F(1,n)\)</span></p><h2 id="中心极限定理">中心极限定理</h2><p>若随机变量序列 <span class="math inline">\(X_1,X_2,\cdots\)</span> 具有有限的数学期望和方差，且服从</p><p><span class="math display">\[\frac{\sum_{k=1}^{n}(X_k-E[X_k])}{\sqrt{\mathrm{Var}\Big[\sum _{k=1}^nX_k\Big ]}}\rightarrow N(0,1)\]</span></p><p>则称其服从中心极限定理.</p><h3 id="棣莫弗-拉普拉斯中心极限定理">棣莫弗-拉普拉斯中心极限定理</h3><p>设 <span class="math inline">\(X_1,X_2,\cdots\)</span> 独立同分布，服从 <span class="math inline">\(B(1,p)\)</span> ，则 <span class="math inline">\(X_1,X_2,\cdots\)</span> 服从中心极限定理，即</p><p><span class="math display">\[\mathop{\lim}\limits_{n\rightarrow \infty} P(\frac{1}{\sqrt{np(1-p)}}\Big [\sum_{k=1}^nX_k-np\Big ]\leq x)=\Phi(x)=\frac{1}{\sqrt{2\pi}}\int_{-\infty} ^{x}e^-{\frac{u^2}{2}}\mathrm{d}u\]</span></p><p>这个式子看上去比较复杂，实际上表达的意义是 <span class="math inline">\(\sum X-E[X]\)</span> 经过对正态分布的拟合（除以标准差）后服从标准正态分布.</p><p>该定理是下面 <strong>林德伯格-莱维定理</strong> 关于二项分布的特例.</p><h3 id="林德伯格-莱维定理">林德伯格-莱维定理</h3><p>设 <span class="math inline">\(X_1,X_2,\cdots\)</span> 独立同分布，具有有限的数学期望 <span class="math inline">\(\mu\)</span> 与方差 <span class="math inline">\(\sigma ^2\)</span> 则 <span class="math inline">\(X_1,X_2,\cdots\)</span> 必定服从中心极限定理，即</p><p><span class="math display">\[\mathop{\lim}\limits_{n\rightarrow \infty} P(\frac{1}{\sigma\sqrt{n}}\Big [\sum_{k=1}^nX_k-n\mu\Big ]\leq x)=\Phi(x)=\frac{1}{\sqrt{2\pi}}\int_{-\infty} ^{x}e^-{\frac{u^2}{2}}\mathrm{d}u\]</span></p><p>即，如果一个序列<strong>独立同分布</strong>且数学期望和方差有限，则其每一项减去期望值后的和 经过对正态分布的拟合（除以标准差与 <span class="math inline">\(\sqrt{n}\)</span> 的乘积）后服从标准正态分布.</p><p>有了这个定理，当 <span class="math inline">\(n\)</span> 比较大时，我们就可以用正态分布估算部分和的分布了.</p><h2 id="估计">估计</h2>]]></content>
      
      
      <categories>
          
          <category> 课程笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> math </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>组合计数知识摘要</title>
      <link href="/2023/05/09/%E7%BB%84%E5%90%88%E8%AE%A1%E6%95%B0%E7%9F%A5%E8%AF%86%E6%91%98%E8%A6%81/"/>
      <url>/2023/05/09/%E7%BB%84%E5%90%88%E8%AE%A1%E6%95%B0%E7%9F%A5%E8%AF%86%E6%91%98%E8%A6%81/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>本文原稿初稿于2019-11-17，搬运过来作参考。</p><hr /><h1 id="基础知识">基础知识</h1><h2 id="排列组合">排列组合</h2><h3 id="排列">排列</h3><p>从<span class="math inline">\(n\)</span>个数字有序地选择<span class="math inline">\(k\)</span>个数字的方案数。</p><p>第一个数字有<span class="math inline">\(n\)</span>种选择方案，第二个有<span class="math inline">\(n-1\)</span></p><p>于是答案为<span class="math inline">\(n(n-1)(n-2)...(n-k+1)=\frac{n!}{(n-k)!}=n^{\underline{k}}\)</span>。(<span class="math inline">\(n^{\underline{k}}\)</span>指n的k次下降幂）</p><p>记为<span class="math inline">\(P_n^k,A_n^k,{n\choose k}*k!\)</span></p><p>前两个好像是苏联的符号...?</p><h3 id="组合">组合</h3><p>从<span class="math inline">\(n\)</span>个数字个数字无序地选择<span class="math inline">\(k\)</span>个数字的方案数。</p><p>因为无序，在排列的基础上除以<span class="math inline">\(k!\)</span>即可</p><p>记为<span class="math inline">\(C_n^k,{n\choose k}\)</span></p><p>同样地，国际上都喜欢用第二种。</p><h3 id="二项式定理">二项式定理</h3><p><span class="math inline">\((x+1)^n\)</span>中<span class="math inline">\(x^k\)</span>前的系数。</p><p>等价于<span class="math inline">\(n\)</span>个单项式中选<span class="math inline">\(k\)</span>个取<span class="math inline">\(x\)</span>，其余取<span class="math inline">\(1\)</span></p><p>展开式：</p><p><span class="math display">\[(x+y)^n=\sum_{k=0}^n{n \choose k}x^ky^{n-k}\]</span></p><h3 id="广义二项式定理">广义二项式定理</h3><p>求<span class="math inline">\((x+y)^a\)</span> （a是有理数）</p><p><span class="math display">\[(x+y)^a=\sum^{\infty}_{k=0}\frac{a^{\underline{k}}}{k!}x^ky^{(a-k)}\]</span></p><p>如果是正整数显然能那个分数能对应成刚刚的组合数</p><p>其他情况要泰勒展开，我不会。</p><h3 id="隔板法">隔板法</h3><p>n个一样的球放进m个不同的盒子，能不放，求方案数</p><p>把n个东西划分成m段，可以强行加m个球要求不能不放，那么就是在n+m-1个划分点选m-1个</p><p>答案为<span class="math inline">\({n+m-1 \choose m-1}={n+m-1 \choose n}\)</span></p><p>以上是最简单的排列组合，下面的东西可能会让人懵掉。</p><h2 id="计数原理">计数原理</h2><h3 id="抽屉原理">抽屉原理</h3><p>把<span class="math inline">\(kx+b(0&lt;b&lt;x)\)</span>个物品放进<span class="math inline">\(x\)</span>个盒子内，至少有一个盒子内有<span class="math inline">\(k+1\)</span>个东西</p><h3 id="加法原理">加法原理</h3><p>事件<span class="math inline">\(A\)</span>有<span class="math inline">\(n\)</span>个结局，事件<span class="math inline">\(B\)</span>有m种结局，发生了一个事件，共有<span class="math inline">\((n+m)\)</span>种结局</p><p>若干不交的集合取一个的方案数，等于集合大小的和。</p><h3 id="乘法原理">乘法原理</h3><p>事件<span class="math inline">\(A\)</span>有<span class="math inline">\(n\)</span>个结局，事件<span class="math inline">\(B\)</span>有<span class="math inline">\(m\)</span>个结局，两个事件都发生了，共有<span class="math inline">\(nm\)</span>种结局</p><p>若干不交的集合格取一个的方案数，等于集合大小的乘积。</p><p>以上计数原理是计数的基石，虽然很浅显但是在后面的知识中扮演关键的角色、</p><h2 id="特殊数列">特殊数列</h2><h3 id="卡特兰数">卡特兰数</h3><p>定义式：</p><p><span class="math display">\[h_n=\sum^{n-1}_{k=0}h_kh_{n-1-k}(h_0=h_1=1)\]</span></p><p>通项式：</p><p><span class="math display">\[h_n={2n \choose n}-{2n \choose n-1}=\frac{2n \choose n }{n+1}\]</span></p><p>应用场景很多</p><p>括号序列数量，<span class="math inline">\(n\times n\)</span>方格行走数（不能越过对角线），凸多边形划分数，二叉树数量</p><p>用方格行走推导 $h_n = {2n n} - {2n n-1} $ ：</p><p>将模型转换成这样：</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/pkcg7ezl.png" /></p><p>然后不能越过下面的直线</p><p>我们要走n次向上，n次向下，共2n次，这样我们才能回到0。</p><p>先忽略不能越过下面的直线，那就是在2n步中选出n步向上走，为<span class="math inline">\({2n \choose n}\)</span></p><p>接下来减掉不合法的，如果越过了这个线，那么这时我们把终点(n,0)，改成(n,,-2)，进行一次<strong>翻转</strong>，就只需要走n+1步向下，n-1步向上，答案为<span class="math inline">\({2n \choose n-1}\)</span>，这是一个<strong>反射法</strong>的经典应用。</p><p><span class="math inline">\({2n \choose n}-{2n \choose n-1}=\frac{2n \choose n}{n+1}\)</span> 可以用数学方法证明<del>留与读者自证</del></p><h3 id="第一类斯特林数">第一类斯特林数</h3><p>用<span class="math inline">\(S_u(n,m)\)</span>表示n个不同元素构成m个圆排列的方案数</p><p>1.最后一个元素单独做环</p><p>2.插入之前的m个环中</p><p><span class="math display">\[S_u(n,m)=S_u(n-1,m-1)+(n-1)*S_u(n-1,m)\]</span></p><p>第一类斯特林数有时候有符号，在生成函数上应用较多，记为<span class="math inline">\(S_s\)</span></p><p><span class="math display">\[S_s(n,m)=(-1)^{n+m}S_u(n,m)\]</span></p><p>有符号的斯特林数的生成函数为<span class="math inline">\(x^{\underline{n}}\)</span>，这个结论非常重要，有了这个可以快速求斯特林数</p><p>建议明白生成函数后再回来看</p><h3 id="第二类斯特林数">第二类斯特林数</h3><p><span class="math inline">\(S(n,m)\)</span>表示把<span class="math inline">\(n\)</span>个不同元素拆分进<span class="math inline">\(m\)</span>个非空集合的方案数，集合不为空</p><p><span class="math display">\[S(n,m)=S(n-1,m-1)+m*S(n-1,m)\]</span></p><p>类似于第一类斯特林数，考虑当前元素再新建一个集合和加入之前的集合即可。</p><p><span class="math display">\[S(n,m)=\frac{1}{m!}\sum(-1)^k{m \choose k}(m-k)\]</span></p><p>这个式子可以用卷积快速计算，但是因为本篇主题是计数，所以不展开。</p><p>贝尔数（不要求划分成几个集合）是第二类斯特林数之和。</p><h3 id="拆分数">拆分数</h3><p><span class="math inline">\(f_n\)</span>表示大小为n的正整数拆分成若干无序的正整数和的方案数</p><p>有两种DP方法</p><p>1<span class="math inline">\(.f_{i,j}\)</span>表示拆分成若干不超过j的方案数</p><p><span class="math display">\[f_{i,j}=f_{i-j,j}+f_{i,j-1}\]</span></p><p>2.<span class="math inline">\(g_{i,j}\)</span>表示拆分j个数字的方案数</p><p><span class="math display">\[g_{i,j}=g_{i-1,j-1}+g_{i-j,j}\]</span></p><p>两个DP复杂度都是平方级别的。</p><p>考虑大小超过<span class="math inline">\(\sqrt{n}\)</span>的数字最多只有<span class="math inline">\(\sqrt{n}\)</span>个，结合两种DP，复杂度<span class="math inline">\(O(n\sqrt{n})\)</span></p><p>用第一个DP考虑小的数字，用第二个DP考虑大的数字，先用f算出<span class="math inline">\(\sqrt{n}\)</span>以内的答案，g的方程就可以改为<span class="math inline">\(g_{i,j}=g_{i-\sqrt{n},j-1}+g_{i-j,j}\)</span></p><p>拆分数也有生成函数，为：</p><p><span class="math display">\[\frac{1}{\Sigma(-1)^kx^{k(3k\pm 1)}}\]</span></p><p>下面这个分母是带符号的五边形数</p><p>如果把拆分出来的正整数想象成柱形图，那么这两种方法一种是按列考虑，一种按行考虑。</p><h1 id="生成函数">生成函数</h1><blockquote><p>生成函数的应用简单来说在于研究未知（通项）数列规律，用这种方法在给出递推式的情况下求出数列的通项</p></blockquote><h2 id="多项式与形式幂级数">多项式与形式幂级数</h2><p>形式幂级数的定义：</p><p><span class="math display">\[\sum _{n\geq 0}a_nx^n\]</span></p><p>可以认为是一个有无穷次项的多项式，所有次项都为正</p><p>加减法：</p><p><span class="math display">\[\sum _{n\geq 0}a_nx^n\pm \sum _{n\geq 0}b_nx^n=\sum _{n\geq 0} (a_n\pm b_n)x^n\]</span></p><p>乘法：</p><p><span class="math display">\[\sum _{n\geq 0}a_nx^n\times \sum _{n\geq 0}b_nx^n=\sum_{n\geq 0}(\sum _{k=0}^na_kb_{n-k}x^n)\]</span></p><p>类似于多项式的加减法和乘法</p><h2 id="闭形式">闭形式</h2><p>形式幂级数的表达形式是一个长度无穷的多项式，但是对于部分的形式幂级数，存在长度有限的函数能够直接表示它，则称之为闭形 式。</p><p>比如等比数列：</p><p><span class="math display">\[\sum _{n \geq0}x^n=\frac{1}{1-x}\]</span></p><p><span class="math display">\[\sum _{n \geq1}x^n=x\sum _{n \geq0}x^n=\frac{x}{1-x}\]</span></p><p>意义：把无穷长度的形式幂级数改写为有限长度的闭形式</p><h2 id="组合对象">组合对象</h2><p>组合计数是一类常见问题，通常给定我们若干组合条件，对于每个组合对象，有某个函数 <span class="math inline">\(size\)</span> 衡量了它的大小，如图的节点数，序列的长度等。<span class="math inline">\(size\)</span> 为 <span class="math inline">\(n\)</span> 的个数为有限个，记为$A_n <span class="math inline">\(，求某个\)</span>A_n.$</p><p>这些图，序列等就是组合对象。</p><p>组合对象分为是否有标号的两种，指的是是否考虑组合对象内部的元素有不同的区别，例如无标号的三个点的图只有 4 种，而有标号的有 8 种。</p><h2 id="普通生成函数">普通生成函数</h2><p>数列<span class="math inline">\(A_0,A_1,A_2...\)</span>的普通生成函数为</p><p><span class="math display">\[\sum _{n \geq 0}A_nx^n\]</span></p><p>普通生成函数通常考虑无标号问题，它的加法操作和乘法操作分别对应了并和拼接两种操作。</p><h3 id="斐波那契数">斐波那契数</h3><p><span class="math inline">\(f_n\)</span>表示第n个斐波那契数，求<span class="math inline">\(\sum_{n \geq 0}f_nx^n\)</span>的闭形式</p><p>令</p><p><span class="math display">\[F(x)=\sum_{n\geq0}f_nx^n\]</span></p><p>由于<span class="math inline">\(f_n=f_{n-1}+f_{n-2}\)</span>可得</p><p><span class="math display">\[F(x)=xF(x)+x^2F(x)+1\]</span></p><p>解方程得</p><p><span class="math display">\[F(x)=\frac{1}{1-x-x^2}\]</span></p><p>分解质因数后裂项，可得到通项公式。</p><h3 id="卡特兰数-1">卡特兰数</h3><p>求节点数为n的二叉树个数</p><p>生成函数本身具有组合性质，令<span class="math inline">\(F(x)\)</span>表示该问题的生成函数，一棵二叉树可以划分成根节点和左右子树，是两个完整都二叉树，</p><p>所以<span class="math inline">\(F(x)=xF^2(x)+1\)</span>，解方程可得<span class="math inline">\(F(x)=\frac{1-\sqrt{1-4x}}{2x}\)</span></p><p>通过泰勒展开可以求得通项公式。</p><p>因为我不会 也不是主题内容，所以不展开</p><h2 id="指数生成函数">指数生成函数</h2><p>指数生成函数一般用来解决有标号问题</p><p>数列<span class="math inline">\(A_0,A_1,A_2...\)</span>的指数生成函数为</p><p><span class="math display">\[\sum _{n \geq 0}\frac{A_n}{n!}x^n\]</span></p><h3 id="连通图计数">连通图计数</h3><p>考虑到任意图可以被划分成若干连通图。</p><p>定义连通图的生成函数为<span class="math inline">\(F(x)\)</span>，任意图的生成函数为<span class="math inline">\(G(x)\)</span>。</p><p>很容易求出任意图的生成函数，即</p><p><span class="math display">\[G(X)=\sum _{n\geq 0}\frac{2^{n(n-1)/2}}{n!}x^n\]</span></p><p>任意图是由连通图构成的，所以<span class="math inline">\(G(x)=e^{F(x)}\)</span>，所以F(x)=ln G(x)，通过多项式姿势可以快速求出来</p><h1 id="polya定理">Polya定理</h1><h2 id="burnside-引理">Burnside 引理</h2><h3 id="置换">置换</h3><p>置换就是对元素进行重新排列，必须（类似于线性代数中的<strong>线性映射</strong>）。</p><p>比如，把正方体旋转90度，可以看做四个顶点的一个置换</p><p>有以下结论：</p><p>置换可以构成环:从一个元素置换前到置换后连一条有向边，会构成环(循环）</p><p>定义一个状态S经过置换后与原来相同，则称其为不动点。</p><h3 id="置换群">置换群</h3><p>置换群指的是一个置换的集合，满足任意两个置换不能复合出一个新的不在集合内的置换。</p><h3 id="burnside-引理-1">Burnside 引理</h3><p>令<span class="math inline">\(X\)</span>表示某个集合，<span class="math inline">\(G\)</span>表示某个作用在X上的某个置换群。对于任意<span class="math inline">\(G\)</span>内的元素<span class="math inline">\(g\)</span>，定义<span class="math inline">\(f(g)\)</span>为<span class="math inline">\(X\)</span>内经过置换<span class="math inline">\(g\)</span>后不变的元素数量，我们要求<span class="math inline">\(X\)</span>内本质不同的元素个数（本质不同指不能通过<span class="math inline">\(G\)</span>获得彼此），这个个数记为<span class="math inline">\(|X/G|\)</span></p><p>（这也被称为<strong>等价类</strong>，求的也就是等价类个数）</p><p>形象地说，比如某个集合:</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/nk4kqj4t.png" /></p><p>然后有一个置换为逆时针旋转60度，那这两个元素本质相同。</p><p>Burnside 引理为：</p><p><span class="math display">\[|X/G|=\frac{1}{|G|}\sum_{g\in G}f(g)\]</span></p><p>证明：</p><blockquote><p>我们发现一个元素是不是不动点需要考虑两个东西：一是元素本身，二是置换，所以不动点是<strong>二元</strong>的</p></blockquote><p>例子：</p><blockquote><p>一个正方形分成4格,涂上黑白两种颜色,有多少种方案？其中经过转动相同图像的算一种方案</p></blockquote><p>本来可以直接枚举，但是我们要验证Burnside ，所以对其加以考虑。</p><p>在这个正方形上的置换有：</p><p>(1)顺时针转90度，(2)逆时针转90度，(3)不动，(4)直接转动180度</p><p>先把所有正方形画出来</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/mm8421fo.png" /></p><p>然后按从上到下 从左到右一行一行编号为(1)~(16)</p><p>其中对于每个置换，列出不动点：</p><p>(1):2个</p><p>(2):2个</p><p>(3):16个</p><p>(4):4个</p><p><span class="math display">\[|X/G|=\frac{1}{|G|}\sum_{g\in G}f(g)=\frac{1}{4}(2+2+16+4)=6\]</span></p><h3 id="polya定理-1">Polya定理</h3><p>设<span class="math inline">\(G\)</span>是<span class="math inline">\(X\)</span>的一个置换群，<span class="math inline">\(|X|\)</span>=n，用<span class="math inline">\(m\)</span>种颜色染色，本质不同的方案数:</p><p><span class="math display">\[L=\frac{1}{G}\sum_{g\in G}m^{c(g)}\]</span></p><p><span class="math inline">\(c(g)\)</span>表示<span class="math inline">\(g\)</span>的循环节个数。</p><p>通常我们并不枚举所有的<span class="math inline">\(g\)</span>，并计算<span class="math inline">\(c(g)\)</span>，而是枚举 <span class="math inline">\(c(g)\)</span>，快速计算多少<span class="math inline">\(g\)</span>满足条件。</p><p>仍然将一个正方形分成4格,涂上黑白两种颜色,有多少种方案？其中经过转动相同图像的算一种方案</p><p>在这个正方形上的置换有：</p><p>不动：4</p><p>旋转90度 ：1</p><p>旋转180度 ：2</p><p>旋转270度：1</p><p><span class="math inline">\(M=\frac{1}{4}(2^4+2^1+2^2+2^1)=6\)</span></p><h1 id="生成树计数">生成树计数</h1><h2 id="度数矩阵邻接矩阵和基尔霍夫kirchhoff矩阵">度数矩阵，邻接矩阵和基尔霍夫(Kirchhoff)矩阵</h2><p>对于一个无向图<span class="math inline">\(G\)</span>，定义<span class="math inline">\(G\)</span>的度数矩阵<span class="math inline">\(D\)</span>满足：</p><p><span class="math display">\[d_{i,j}=\begin{cases} deg_i\space\space\space(i=j)\\0\space \space\space\space\space\space\space\space(i\ne j)\end{cases}\]</span></p><p>其中，<span class="math inline">\(deg_i\)</span>表示节点i的度数</p><p>定义<span class="math inline">\(G\)</span>的邻接矩阵<span class="math inline">\(C\)</span>满足：</p><p><span class="math display">\[c_{i,j}=\begin{cases} 0\space\space\space\space\space\space\space\space\space\space(i=j)\\adj_{i,j}\space \space\space(i\ne j)\end{cases}\]</span></p><p>定义<span class="math inline">\(G\)</span>的基尔霍夫矩阵<span class="math inline">\(L\)</span>：<span class="math inline">\(L=D-G\)</span>，也就是：</p><p><span class="math display">\[l_{i,j}=\begin{cases} deg_i\space\space\space\space\space\space\space\space(i=j)\\-adj_{i,j}\space \space\space(i\ne j)\end{cases}\]</span></p><h2 id="行列式">行列式</h2><p>定义：一个矩阵<span class="math inline">\(A\)</span>的行列式表示为:</p><p><span class="math display">\[|A|=\sum _p(-1)^{\sigma(p)}\prod_{i=1}^na_{i,p_i}\]</span></p><p>性质：</p><p>1.一个对角矩阵/上三角矩阵的行列式值是所有对角线上元素的乘积。</p><p>2.交换矩阵的两行/两列，行列式值取反</p><p>3.将矩阵的一行/一列乘上一个固定的常数 k，行列式值也乘上 k。</p><p>4.将矩阵的一行加到另外一行上去，行列式值不变，列同理。</p><p>可以使用高斯消元快速计算行列式。</p><h2 id="矩阵树matrix-tree定理">矩阵树(Matrix-Tree)定理</h2><p>图<span class="math inline">\(G\)</span>的生成树数量是依照以上步骤求出来的基尔霍夫矩阵<span class="math inline">\(L\)</span>的行列式的任意一个代数余子式。</p><p>也就是说随意取它的任意一个<span class="math inline">\(n-1\)</span>阶主子式，然后求出主子式的值，得到的就是在这个图中生成树的数量。</p><p>代码：咕咕咕</p><p>计数笔记就到这里结束了，以后可能会补一些例题什么的~</p><p>接下来大概要学线代和数论/多项式~</p>]]></content>
      
      
      <categories>
          
          <category> 算法竞赛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> math </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用 Latex 写化学方程式</title>
      <link href="/2023/05/09/%E7%94%A8-Latex-%E5%86%99%E5%8C%96%E5%AD%A6%E6%96%B9%E7%A8%8B%E5%BC%8F/"/>
      <url>/2023/05/09/%E7%94%A8-Latex-%E5%86%99%E5%8C%96%E5%AD%A6%E6%96%B9%E7%A8%8B%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>本文收录于2020年的洛谷日报，原文初稿于2020-06-07，小作修改后搬运过来。</p><hr /><p>这篇文章主要介绍<span class="math inline">\(\text{Latex}\)</span>中的 <code>mchm</code> 宏包和 <code>chemfig</code> 宏包，其中较多是 <code>chemfig</code> 宏包书写较复杂的有机化学结构式。</p><p><code>mchm</code> 宏包和 <code>chemfig</code> 宏包都已经可以在 <code>Tex Live</code> 中直接使用，如果您没有本地的 <code>Tex</code> 编译器，可以前往<a href="https://www.overleaf.com/">Overleaf</a>使用在线编译器（需要注册，且免费版编译时间不能超过一分钟）。</p><p><code>chemfig</code>宏包还有更多进阶的内容。详见翻译完成的中文说明书https://chemfig.man.huzheyang.cn</p><h1 id="part-1-textmchm宏包">Part 1 <span class="math inline">\(\text{mchm}\)</span>宏包</h1><p><code>mchm</code> 宏包用来书写不涉及有机化学的化学式。使用这个宏包，需要使用指令<code>\ce&#123;&#125;</code>。在大括号内有以下几个特性。</p><p>1.数字下标将不再需要 <code>_&#123;&#125;</code> 来表示，可以直接书写，如 <code>H2SO4</code> 表现为<span class="math inline">\(\text{H}_2\text{SO}_4\)</span>。</p><p>2.<code>+</code> 和 <code>-</code> 如果没有两边没有空格，则表现为上下标，如 <code>H+</code> 显示为<span class="math inline">\(\text{H}^+\)</span>，<code>H+ + OH-</code> 显示为<span class="math inline">\(\text{H}^+ + \text{OH}^-\)</span>。</p><p>3.水合物的书写可以直接用 <code>*</code> ，如 <code>KCr(SO4)2 * 12H2O</code> 显示为<span class="math inline">\(\text{KCr(SO}_4{)_2} · \text{12H}_2\text{O}\)</span>。</p><p>4.拥有可以标注反应条件的箭头，<code>-&gt; &lt;-&gt; &lt;=&gt;</code> 显示为</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/87vtcmy0.png" /></p><p>此外还有 <code>&lt;=&gt;&gt; &lt;&lt;=&gt;</code> 等箭头。</p><p>如果想要标注反应条件，则在箭头后加 <code>T[][]</code> ，如 <code>-&gt;T[催化剂][\Delta] &lt;=&gt;T[\Delta]</code> 显示为</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/lva68acr.png" /></p><p>5.单键，双键和三键可以直接用 <code>- = #</code> 代替，如 <code>CH3-CH=CH-C#CH</code> 显示为</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/z0tqdmmn.png" /></p><p>6.如果<span class="math inline">\(\text{v}\)</span>和<span class="math inline">\(\text{ \^ }\)</span> 旁边有空格，会显示成向下的箭头（沉淀）和向上的箭头（气体），如 <code>Ca(NO3)2 + Na2CO3 -&gt; CaCO3 v + 2NaNO3</code> 和 <code>2HCl + Na2CO3 -&gt; H2O + CO2 ^ + 2NaCl</code> 显示为</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/1jicxnpz.png" /></p><p>以下是一个被引用很多次的例子（有稍作修改）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">\documentclass&#123;article&#125;</span><br><span class="line">\usepackage[UTF8]&#123;ctex&#125; % 中文宏包</span><br><span class="line">\usepackage&#123;mhchem&#125; %化学式宏包</span><br><span class="line"></span><br><span class="line">\begin&#123;document&#125;</span><br><span class="line"></span><br><span class="line">\ce&#123;2H2 + O2 -&gt;T[点燃] 2H2O&#125;</span><br><span class="line"></span><br><span class="line">\ce&#123;N2 + 3H2 &lt;=&gt;[高温、加压][催化剂] 2NH3&#125;</span><br><span class="line"></span><br><span class="line">\ce&#123;^&#123;227&#125;_&#123;90&#125;Th+&#125;</span><br><span class="line"></span><br><span class="line">\ce&#123;KCr(SO4)2 * 12H2O&#125;</span><br><span class="line"></span><br><span class="line">\ce&#123;C6H5-CHO&#125;</span><br><span class="line"></span><br><span class="line">\ce&#123;X=Y#Z&#125;</span><br><span class="line"></span><br><span class="line">\ce&#123;SO4^2- + Ba^2+ -&gt; BaSO4 v&#125;</span><br><span class="line"></span><br><span class="line">\end&#123;document&#125;</span><br></pre></td></tr></table></figure><p>它显示为：</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/ibit1eru.png" /></p><p>有了以上内容，已经可以较方便地书写无机化学中的大部分化学式了。而 <code>chemfig</code> 宏包，即有机化学，才是这篇文章的重头戏。</p><h1 id="part-2-textchemfig-宏包">Part 2 <span class="math inline">\(\text{chemfig}\)</span> 宏包</h1><ul><li>注：该部分内容需要高中有机化学内容，即必修二和小部分选修五的支持。</li></ul><p><code>chemfig</code> 宏包用于书写有机化学中的结构式等，键线式和结构式等都需要 <code>chemfig</code> 来书写。</p><p><code>\chemfig&#123;&#125;</code> 用于书写单个有机物结构式，如果要将有机化合物写入方程式，可以将 <code>\chemfig&#123;&#125;</code> 嵌套入 <code>\ce&#123;&#125;</code> 里面。</p><p>注意：在<code>chemfig</code>中，三键改为用 <code>~</code> 而不是用 <code>#</code> 来表示。</p><p><code>\chemfig&#123;&#125;</code> 有如下几个作用：</p><p>1.在 <code>\chemfig&#123;&#125;</code> 中，为防止产生歧义，数字下标不再能直接写出，如<span class="math inline">\(\text{CH}_4\)</span>必须写为 <code>CH_4</code> ，<span class="math inline">\(\text{C}_6\text{H}_{12}\text{O}_6\)</span>必须写为 <code>C_6H_&#123;12&#125;O_6</code> 。</p><p>2.在 <code>\chemfig&#123;&#125;</code> 中，化学键会被拉长，且碳碳三键改为用 <code>~</code> 表示，如 <code>\chemfig&#123;CH_3-CH=CH-C~CH&#125;</code> 显示为：</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/ndmlfiad.png" /></p><p>缩短化学键的指令稍后再提。</p><p>3.可以用 <code>*n(---)</code> 表示一个环，n为环的边（或点）个数，括号内为环的化学键。如苯环的凯库勒式可以写作 <code>*6(-=-=-=)</code> 或 <code>*6(=-=-=-)</code> 显示为：</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/eia9u6ny.png" /></p><p>这个苯环有点太大，关于缩小苯环和改变方向，也是过会再提。</p><p>苯环的另一种常见画法是内部带有圆圈的正六边形（鲍林式）。</p><p>我们用 <code>\text&#123;**6(------)&#125;</code> 表示，显示为：</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/qhvjg45l.png" /></p><p>表示六元环时，括号内第一个符号表示左下角的键，逆时针旋转编号，最后一个为最左边的键。如 <code>*6(=-----) *6(-=----) *6(-----=)</code> 分别显示为：</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/rfpbwym4.png" /></p><p>如果括号内的键数量达不到括号外的数字，则会从最后一个开始缺失，如果超过括号外的数字，则不会显示多余的键，如 <code>*6(------=) *6(=----)</code> 分别显示为：</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/5uualvn1.png" /></p><p>单个环中，如果没有定义方向，那么最左边必定是一条垂直的键，且由括号内最后一个符号表示它，括号内第一个符号表示它的下一个键，如 <code>*3(--=)  *4(---=)  *5(----=)</code> 分别显示为：</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/5wsfr1uv.png" /></p><p>4.定义方向和键长，在键后用 <code>[x,y]</code> 描述。x表示方向，y表示键长，方向由 <code>0</code> 到 <code>7</code> 编号。如 <code>0</code> 指向向右， <code>1</code> 指向右上， <code>2</code> 指向正上：</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/uvmayd5l.png" /></p><p>使用例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\text&#123;酮与氰化氢加成：&#125;\ce&#123;\chemfig&#123;CH_3C(=[1]O)(-[7]CH_3)&#125; + \chemfig&#123;CN(-[2]H)&#125; -&gt;T[催化剂] \chemfig&#123;CH_3(-[0]C(-[2]OH)(-[0]CN)(-[6]CH3))&#125;&#125;</span><br></pre></td></tr></table></figure><p>显示为：</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/gutrmh2y.png" /></p><p>你也可以自定义角度，改为 <code>:x</code> ，如 <code>CH_3C(=[:30]O)(-[:330]CH_3)</code> 显示为：</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/xmu61aw6.png" /></p><p>如果不定义角度，系统会按照键的起点所连接的键数量取一个系统认为美观的角度，这个很不靠谱。除非你绘制的分子式全在一条线内，不建议不定义角度。</p><p>我们发现以上的化学键显得有些太长，我们可以用 <code>[,y]</code> 来定义键长，不定义键长时长度默认为1，这个y一般取 <code>0.7</code> 正好，根据你的需要定义键长。</p><p>使用例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\text&#123;酮与氰化氢加成：&#125;\ce&#123;\chemfig&#123;CH_3C(=[1,0.7]O)(-[7,0.7]CH_3)&#125; + \chemfig&#123;CN(-[2,0.7]H)&#125; -&gt;T[催化剂] \chemfig&#123;CH_3(-[0,0.7]C(-[2,0.7]OH)(-[0,0.7]CN)(-[6,0.7]CH3))&#125;&#125;</span><br></pre></td></tr></table></figure><p>显示为：</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/mw507onq.png" /></p><p>如果你只想定义键长，不定义角度，可以写为 <code>[,y]</code> 。</p><p>用这个办法也可以定义环的键长和方向，我们发现上面的苯环太大了，可以改为 <code>[,0.7]*6(-=-=-=)</code> ，也可以定义方向 <code>[:30,0.7]*6(-=-=-=)</code> 分别显示为：</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/9adeza6z.png" /></p><p>由上面酮与氰化氢加成的例子，也能看到少许绘制完整结构式的方法。通过以上几个点，我们还是不能绘制较复杂的结构式，接下来我们将以上几个点拼凑起来，绘制完整的分子结构式。</p><h1 id="part-3-嵌套并列与键线式">Part 3 嵌套，并列与键线式</h1><p>将以上内容结合起来，我们要绘制更加复杂的有机结构式。</p><h2 id="嵌套">嵌套</h2><p>如果绘制不断改变方向的键链，需要用到嵌套。<code>A(-[x,y]B)</code> 绘制了一个条从<span class="math inline">\(\text{A}\)</span>连向<span class="math inline">\(\text{B}\)</span>的单键，B可以继续嵌套下去。如 <code>A(-[x1,y1]B(-[x2,y2]C))</code> 绘制了一条从<span class="math inline">\(\text{A}\)</span>连向<span class="math inline">\(\text{B}\)</span>再连向<span class="math inline">\(\text{C}\)</span>的碳链。</p><p>还有一种嵌套是环中嵌套环来绘制稠环化合物，稠环化合物在高中阶段涉及不多。但仍然稍作介绍。</p><p>嵌套环可以直接在括号内嵌套，给出一个例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">\text&#123;萘：&#125;\ce&#123;\chemfig&#123;[,0.7]*6(-=(*6(-=-=--))-=-=)&#125;&#125;</span><br><span class="line"></span><br><span class="line">\text&#123;蒽：&#125;\ce&#123;\chemfig&#123;[,0.7]*6(-=(*6(-=(*6(-=-=--))-=--))-=-=)&#125;&#125;</span><br><span class="line"></span><br><span class="line">\text&#123;菲：&#125;\ce&#123;\chemfig&#123;[,0.7]*6(-=(*6(-(*6(-=-=--))=-=--))-=-=)&#125;&#125;</span><br></pre></td></tr></table></figure><p>显示为：</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/y5nnlmkg.png" /></p><h2 id="并列">并列</h2><p>如果一个碳连着多个基团，需要用到并列。如 <code>A(-[x1,y1]B)(-[x2,y2]C)</code> 绘制了<span class="math inline">\(\text{A}\)</span>上同时连接了<span class="math inline">\(\text{B}\)</span>和<span class="math inline">\(\text{C}\)</span>基团。</p><h2 id="键线式">键线式</h2><p>键线式在以上的基础上，不添加元素名称即可，如果添加会自动在那个位置上加入元素。给出两个例子</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">\text&#123;褪黑素：&#125;\chemfig&#123;[,0.7]*6(-=(*5(-N(-H)-=(-[:30]CH_2CH_2NHCOCH_3)--))-=-(-H_3CO)=)&#125;</span><br><span class="line"></span><br><span class="line">\text&#123;键线式：&#125;\chemfig&#123;[,0.7]*6(-=(*5(-[0.7]N(-H)-=(-[:30,0.7](-[:330,0.7](-[:30,0.7]N(-[2,0.7]H)(-[:330,0.7](=[6,0.7]O)(-[:30,0.7])))))--))-=-(-[,0.7]O(-[1,0.7]))=)&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/veizr9mf.png" /></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\text&#123;香叶醇：&#125;\chemfig&#123;(-[6](-[5](-[6](-[7](=[6](-[5])(-[7])))))(=[7](-[1](-[7]OH))))&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/utr36t08.png" /></p><p>这样的显示方式，双键与单键相连方式与习惯方式不符，我们可以稍作修改，将代码改为 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\chemfig&#123;(-[6,](-[5,](-[6,](-[7,](=^[6,](-[5,])(-[7,])))))(=^[7,](-[1,](-[7,]OH))))&#125;</span><br></pre></td></tr></table></figure></p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/jx8rwc95.png" /></p><p>注意到，此时单键连向双键的其中一条横向而不是连向两条横线中间了。</p><h1 id="part-4-杂项">Part 4 杂项</h1><p>这个part可能会不断更新，且大部分内容高中化学无需用到。</p><h2 id="两个键的链接">两个键的链接</h2><p>比如异丙基苯，苯环上的一个碳原子连着异丙基，若将异丙基简写为<span class="math inline">\(\text{CH}_3\text{CHCH}_3\)</span>，而键又连着中间的碳，如果直接按以上方法绘制，会将键连至第一个碳。</p><p>这个时候可以指定键的起点（或终点）<code>\chemfig&#123;[,0.7]*6(-=-=(-[2,0.7,,3]CH_3CHCH_3)-=)&#125;</code>，表示终点为异丙基的第三个原子，即中间的<span class="math inline">\(\text{C}\)</span></p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/zan20584.png" /></p><p>如果不采用指定终点，则显示为</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/e3hlxbml.png" /></p><p>在刚刚没有用到的两个逗号之间，表示的是起点，如4-异丙基<del>庚</del>辛烷，写作</p><p><code>\chemfig&#123;CH_3CH_2CH_2CHCH_2CH_2CH_2CH_3(-[2,0.7,7,3]CH_3CHCH_3)&#125;</code></p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/k31xeod0.png" /></p><p>这就是指定起点与终点的键的画法了。</p><h2 id="键的拓展">键的拓展</h2><p>除了常见的单键，双键和三键，存在一些其他的键，如楔形式中的键，<code>chemfig</code> 都提供了方法。</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/92xzsbvu.png" /></p><p>楔形式可以定义三角形的形状。</p><p><code>\chemfig[cram width=10pt,cram dash width=0.4pt,cram dash sep=1pt]&#123;A&gt;B&gt;:C&gt;|D&#125;</code> 中括号内四个参数分别表示起始宽度，线宽度，每几个宽度画一条线（虚楔形用）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">\chemfig[cram width=10pt,cram dash width=0.4pt,cram dash sep=1pt]&#123;A&gt;B&gt;:C&gt;|D&#125;</span><br><span class="line"></span><br><span class="line">\chemfig[cram width=15pt,cram dash width=2pt,cram dash sep=2pt]&#123;A&gt;B&gt;:C&gt;|D&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/ggdkz6ai.png" /></p><p>这种定义方式是定义整个分子所有的键，定义分子所有键的命令还有：</p><p><code>bond offset=</code>表示键的端点与字母之间的距离，如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">\chemfig[bond offset=0pt]&#123;A-B&#125;</span><br><span class="line"></span><br><span class="line">\chemfig&#123;A-B&#125;</span><br><span class="line"></span><br><span class="line">\chemfig[bond offset=5pt]&#123;A-B&#125;</span><br></pre></td></tr></table></figure><p>显示为</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/xy1216su.png" /></p><p>默认bond offset为2pt。可以自定义默认间隔，之后的默认间隔就是你定义的值，也可以定义单个键的间隔，方式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">\setchemfig&#123;bond offset=4pt&#125;</span><br><span class="line">\chemfig&#123;A-B-C&#125;\par</span><br><span class="line">\chemfig&#123;A-#(,0pt)B-C&#125;\par</span><br><span class="line">\chemfig&#123;A-B-#(0pt)C&#125;\par</span><br><span class="line">\chemfig&#123;A-#(,0pt)B-#(0pt)C&#125;</span><br></pre></td></tr></table></figure><p>这里定义了默认间隔为4pt，用小括号中间一个逗号表示一个键起点和终点的间隔，下面看看效果：</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/ghmuiuiu.png" /></p><p>也可以定义键长，不再需要在每个键前面表示键长</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">\chemfig[atom sep=2em]&#123;A-B&#125;\par</span><br><span class="line">\chemfig[atom sep=50pt]&#123;A-B&#125;</span><br></pre></td></tr></table></figure><p>显示为：</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/77aniw64.png" /></p><p>也可以定义颜色，如<code>\chemfig[bond style=&#123;line width=1pt,red&#125;]&#123;A-B=C&gt;|D&lt;E&gt;:F&#125;</code>显示为</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/6ow4mv58.png" /></p><p>另外还有一种方法可以定义键线式的角度，表示为<code>::x</code> ，表示在上一个键的角度上加上<code>x</code>度作为新的角度。</p><p><code>\chemfig&#123;A-[:-5]-[::20]-[::20]B-[7]-[::20]C-[::20]&#125;</code>显示为</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/hvsos9sq.png" /></p><h2 id="高分子聚合物">高分子聚合物</h2><p>先看一个例子</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">\chemfig&#123;-[@&#123;left,0.75&#125;]CH_2-CH_2-[@&#123;right,0.25&#125;]&#125;</span><br><span class="line">\polymerdelim[delimiters =&#123;[]&#125;,height = 5pt]&#123;left&#125;&#123;right&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/xrjhko8j.png" /></p><p>高分子聚合物采用先画中间，再画括号（或者中括号）的画法。由于这种原因，括号常常无法准确放在键中间，所以有时用一个<code>\bigskip</code>放在代码前来优化排版。</p><p>可以看出，用一个<span class="math inline">\(\text{@{x,括号在键的位置}}\)</span>来描述一个括号的位置和名字，第二行绘制括号时，表示了括号种类，高度（也可以用depth表示深度），最后用两个大括号表示加上的位置。</p><p>也有人用 <code>\vphantom</code> 来优化排版，如:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">\chemfig&#123;\vphantom&#123;CH_2&#125;-[@&#123;op,.75&#125;]CH_2-CH_2-[@&#123;cl,0.25&#125;]&#125;</span><br><span class="line">\polymerdelim[delimiters =&#123;[]&#125;,height = 5pt]&#123;op&#125;&#123;cl&#125;</span><br></pre></td></tr></table></figure><p>显示与上面相同，只是在整个pdf中显示会比较正常。</p><p>下面再看几个例子</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">\chemfig&#123;\vphantom&#123;CH_2&#125;-[@&#123;op,0.5&#125;]CH_2-CH(-[6]Cl)-[@&#123;cl,0.5&#125;]&#125;</span><br><span class="line">\polymerdelim[delimiters =&#123;[]&#125;,height = 5pt, depth = 25pt]&#123;op&#125;&#123;cl&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/ilctxrjs.png" /></p><p>下面的例子采用了 <code>h align=false</code> 来使得括号可以不在同一条水平线上</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">\chemfig&#123;-[@&#123;op,.5&#125;:-30]O-[::60](=[::60]O)-[::-60]*6(-=-(-(=[::-60]O)-[::60]O-[::-60]-[::60]-[@&#123;cl,.5&#125;::-60])=-=)&#125;</span><br><span class="line">\polymerdelim[delimiters =&#123;[]&#125;,height=30pt, h align=false]&#123;op&#125;&#123;cl&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/87k3os3d.png" /></p><h2 id="更多符号">更多符号</h2><p><code>\fulldisk</code> 实心点，<code>\emptydisk</code> 空心点（例如绘制十氢化萘的顺反异构体需用到）</p><h1 id="part-5-demo">Part 5 demo</h1><p>以下给出一个完整的文档例子，绘制了高中有机化学基础常见的化学方程式，如果上面的内容没有完全讲明白一些细小的点，可以由例子中体会。</p><p><a href="https://www.luogu.com.cn/paste/eh9kp86r">代码</a></p><p>这份代码太长了，在线编译会超时很久，在本机的texlive上也编译了两分钟之久。所以给各位编译后的一份pdf放在这里~</p><p>链接：https://pan.baidu.com/s/1pI0axwIV8qI_UpeJl7_iRw</p><p>提取码：ele7</p>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Others </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>树上启发式合并</title>
      <link href="/2023/05/09/%E6%A0%91%E4%B8%8A%E5%90%AF%E5%8F%91%E5%BC%8F%E5%90%88%E5%B9%B6/"/>
      <url>/2023/05/09/%E6%A0%91%E4%B8%8A%E5%90%AF%E5%8F%91%E5%BC%8F%E5%90%88%E5%B9%B6/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>本文收录于洛谷日报，原文初稿于2018-04-07，经过修改搬运过来。</p><hr /><h2 id="启发式算法">启发式算法</h2><p>启发式算法是基于人类的经验和直观感觉，对一些算法的优化。</p><p>比较常见的例子是并查集的按秩合并，有带按秩合并的并查集中，合并的代码是这样的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> xx=<span class="built_in">find</span>(x),yy=<span class="built_in">find</span>(y);</span><br><span class="line">    <span class="keyword">if</span>(size[xx]&lt;size[yy])<span class="built_in">swap</span>(xx,yy);</span><br><span class="line">    fa[yy]=xx;size[xx]+=size[yy];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里，对于两个大小不一样的集合，我们将大小小的并到大的，而不是大的连接小的。</p><p>为什么呢？这个集合的大小可以认为是集合的高度（在正常情况下），而我们将集合高度小的并到高度大的显然有助于我们找到父亲</p><p>让高度小的树成为高度较大的树的子树，这个优化可以称为启发式合并算法。</p><h2 id="原理">原理</h2><p>树上启发式合并（ <span class="math inline">\(\text{dsu on tree}\)</span> ，静态链分治）对于某些树上离线问题可以速度大于等于大部分算法且更易于理解和实现的算法。</p><p>考虑下面的问题：</p><p>给出一棵树，每个节点有颜色，询问一些子树的颜色数量（颜色可重复）。</p><p>提供一个仅供验证算法正确性的模板题<a href="https://www.luogu.org/problemnew/show/U41492">树上数颜色</a>，数据纯随机，仅用于验证算法正确性。</p><p><img src="https://cdn.luogu.com.cn/upload/pic/24620.png" /></p><p>对于这种问题解决方式大多是运用大量的数据结构（树套树等），如果可以离线，或询问的量巨大，是不是有更简单的方法？</p><p>很容易想到树上莫队，但是树上启发式合并可以在预处理 <span class="math inline">\(\mathrm{O}(n\log n)\)</span> 的时间复杂度解决这个问题。</p><p>既然支持离线，考虑预处理后 <span class="math inline">\(\mathrm{O}(1)\)</span> 输出答案。</p><p>直接暴力预处理的时间复杂度为<span class="math inline">\(\mathrm{O}(n^2)\)</span>，即对每一个子节点进行一次遍历，每次遍历的复杂度显然与<span class="math inline">\(n\)</span>同阶，有<span class="math inline">\(n\)</span>个节点，故复杂度为<span class="math inline">\(O(n^2)\)</span></p><p>可以发现，每个节点的答案是其子树的叠加，考虑利用这个性质处理问题</p><p>我们可以先预处理出每个节点子树的size和它的重儿子，重儿子同树链剖分一样，是拥有节点最多子树的儿子，这个过程显然可以 <span class="math inline">\(\mathrm{O}(n)\)</span> 完成</p><p>我们用一个数组 check 表示颜色 <span class="math inline">\(i\)</span> 有没有出现过，另一个数组 ans 表示他的颜色个数（即答案）</p><p>遍历一个节点，我们按以下的步骤进行遍历：</p><ul><li><p>先遍历其非重儿子，获取它的 ans，但<strong>不保留遍历后它的check</strong></p></li><li><p>遍历它的重儿子，<strong>保留它的check</strong></p></li><li><p>再次遍历其非重儿子及其父亲，用重儿子的check对遍历到的节点进行计算，获取整棵子树的ans</p></li></ul><p><img src="https://cdn.luogu.com.cn/upload/pic/31537.png" /></p><p><em>上图是一个例子</em></p><p>这样，对于一个节点，我们遍历了一次重子树，两次非重子树，显然是最划算的。</p><p>经过这个过程，我们获得了这个节点的子树的所有 ans</p><p>为什么不合并第一步和第三步呢？因为 check 数组不能重复使用，否则空间会太大，需要在 <span class="math inline">\(O(n)\)</span> 的空间内完成。</p><p>显然若一个节点 <span class="math inline">\(u\)</span> 被遍历了 <span class="math inline">\(x\)</span> 次，则其重儿子会被遍历 <span class="math inline">\(x\)</span> 次，轻儿子（如果有的话）会被遍历 <span class="math inline">\(2x\)</span> 次。</p><p>注意除了重儿子，每次遍历完 check 数组要清零。</p><h2 id="复杂度">复杂度</h2><p>（对于不关心复杂度证明的，可以跳过不看）</p><p>我们像树链剖分一样定义重边和轻边（连向重儿子的为重边，其余为轻边）关于重儿子和重边的定义，可以见下图，对于一棵有n个节点的树：</p><p>根节点到树上任意节点的轻边数不超过 <span class="math inline">\(\log n\)</span> 条。我们设根到该节点有x条轻边该节点的子树大小为y，显然轻边连接的子节点的子树大小小于父亲的一半（若大于一半就不是轻边了），则</p><p><span class="math display">\[y&lt;\frac{n}{2^x} \]</span></p><p>显然有 <span class="math inline">\(n&gt;2^x\)</span>，所以 $x&lt;n $。</p><p>又因为如果一个节点是其父亲的重儿子，则他的子树必定在他的兄弟之中最多，所以任意节点到根的路径上所有重边连接的父节点在计算答案是必定不会遍历到这个节点，所以一个节点的被遍历的次数等于他到根节点路径上的轻边数，所以一个节点的被遍历次数为 <span class="math inline">\(\log n\)</span> ,总时间复杂度则为 <span class="math inline">\(\mathrm{O}(n\log n)\)</span>，统计答案花费 <span class="math inline">\(\mathrm{O}(m)\)</span>.</p><p><img src="https://cdn.luogu.com.cn/upload/pic/24909.png" /></p><p><em>图中标红的即为重边，重边连向的子节点为重儿子</em></p><h2 id="大致代码">大致代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn=<span class="number">100010</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> to,nxt;</span><br><span class="line">&#125;t[maxn];<span class="type">int</span> head[maxn],tot=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">addedge</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    t[++tot].to=y;</span><br><span class="line">    t[tot].nxt=head[x];</span><br><span class="line">    head[x]=tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> c[maxn],size[maxn],son[maxn],cnt[maxn],ans[maxn];</span><br><span class="line"><span class="comment">//  color   size       重儿子    计数器  </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> fa)</span></span>&#123;</span><br><span class="line">    size[x]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=head[x];i;i=t[i].nxt)&#123;</span><br><span class="line">        <span class="type">int</span> to=t[i].to;</span><br><span class="line">        <span class="keyword">if</span>(to!=fa)&#123;</span><br><span class="line">            <span class="built_in">dfs1</span>(to,x);</span><br><span class="line">            size[x]+=size[to];</span><br><span class="line">            <span class="keyword">if</span>(size[to]&gt;size[son[x]])</span><br><span class="line">                son[x]=to;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//                    重儿子    保留答案</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa,<span class="type">int</span> isson,<span class="type">int</span> keep)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(keep)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=head[u];i;i=t[i].nxt)&#123;</span><br><span class="line">            <span class="type">int</span> to=t[i].to;</span><br><span class="line">            <span class="keyword">if</span>(to!=fa&amp;&amp;to!=son[u])&#123;</span><br><span class="line">                <span class="built_in">dfs2</span>(to,u,<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> tmp=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(!keep&amp;&amp;son[u])tmp+=<span class="built_in">dfs2</span>(son[u],u,<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(son[u]) tmp+=<span class="built_in">dfs2</span>(son[u],u,<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=head[u];i;i=t[i].nxt)&#123;</span><br><span class="line">        <span class="type">int</span> v=t[i].to;</span><br><span class="line">        <span class="keyword">if</span>(v!=fa&amp;&amp;v!=son[u])&#123;</span><br><span class="line">            tmp+=<span class="built_in">dfs2</span>(v,u,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!cnt[c[u]])&#123;</span><br><span class="line">        tmp++;</span><br><span class="line">    &#125;</span><br><span class="line">    cnt[c[u]]++;</span><br><span class="line">    <span class="keyword">if</span>(keep)ans[u]=tmp;</span><br><span class="line">    <span class="keyword">if</span>(keep&amp;&amp;!isson) <span class="built_in">memset</span>(cnt,<span class="number">0</span>,<span class="built_in">sizeof</span>(cnt));</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="type">int</span> x,y;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;x,&amp;y);</span><br><span class="line">        <span class="built_in">addedge</span>(x,y);</span><br><span class="line">        <span class="built_in">addedge</span>(y,x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;c[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs1</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">dfs2</span>(<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="type">int</span> m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;m);</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        cin&gt;&gt;x;</span><br><span class="line">        cout&lt;&lt;ans[x]&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用场合">使用场合</h2><p>树上启发式合并普遍运用于求解子树答案的静态问题。只要你能维护一个集合，这个集合支持在一定的时间复杂度 <span class="math inline">\(f(n)\)</span> 内插入元素和查询集合内所有元素的<strong>答案</strong>（在数颜色中，就是支持 $(1) $ 的插入和询问颜色个数，即答案），那这个问题就可以在 <span class="math inline">\(\mathrm{O}(n\log n \times f(n))\)</span> 内计算每个子树的答案。</p><p>例如<a href="https://codeforces.com/gym/104025/problem/M">北京理工大学 第 16 届“连山科技”程序设计大赛（November 7, 2022）M题</a>，给定一个树，离线询问子树内互质对个数。发现这个插入一个数并统计当前集合互质对个数是可以用莫反 <span class="math inline">\(\log n\)</span> 计算的，因此可以树上启发式合并套莫反在 <span class="math inline">\(\mathrm{O}(n\log^2 n)\)</span> 内解决。</p><p>当然也可以求解一些特殊的链上问题，如<a href="http://codeforces.com/problemset/problem/741/D">CF741D</a>，给一棵树，每个节点的权值是'a'到'v'的字母，每次询问要求在一个子树找一条路径，使该路径包含的字符排序后成为回文串。</p><p>因为是排列后成为回文串，所以一个字符出现了两次相当于没出现，也就是说，这条路径满足<strong>最多有一个字符出现奇数次</strong></p><p>正常做法是对每一个节点dfs，每到一个节点就强行枚举所有字母找到和他异或后结果为1的个数&lt;1的路径，再取最长值，这样 <span class="math inline">\(\mathrm{O}(n^2 \mathrm{log} n)\)</span>的，可以用树上启发式合并优化到 <span class="math inline">\(\mathrm{O}(n\log^2 n)\)</span> .关于具体做法，可以参考下面的扩展阅读。</p><h2 id="练习题">练习题</h2><p><a href="http://codeforces.com/problemset/problem/600/E">CF600E Lomsat gelral</a></p><p>题意翻译：树的节点有颜色，一种颜色占领了一个子树，当且仅当没有其他颜色在这个子树中出现得比它多。求占领每个子树的所有颜色之和。</p><p><a href="http://uoj.ac/problem/284">UOJ284 快乐游戏鸡</a></p><h2 id="参考资料扩展阅读">参考资料/扩展阅读</h2><p><a href="http://codeforces.com/blog/entry/44351">CF741D作者介绍的dsu on tree</a></p><p><a href="http://codeforces.com/blog/entry/48871">这位作者的题解</a></p>]]></content>
      
      
      <categories>
          
          <category> 算法竞赛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树上问题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高等数学（下）第七章教材补充与习题选</title>
      <link href="/2023/05/09/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%EF%BC%88%E4%B8%8B%EF%BC%89%E7%AC%AC%E4%B8%83%E7%AB%A0%E6%95%99%E6%9D%90%E8%A1%A5%E5%85%85%E4%B8%8E%E4%B9%A0%E9%A2%98%E9%80%89/"/>
      <url>/2023/05/09/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%EF%BC%88%E4%B8%8B%EF%BC%89%E7%AC%AC%E4%B8%83%E7%AB%A0%E6%95%99%E6%9D%90%E8%A1%A5%E5%85%85%E4%B8%8E%E4%B9%A0%E9%A2%98%E9%80%89/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>本文是大一的数学笔记，搬运过来并顺便测试 <span class="math inline">\(latex\)</span> 渲染效果。</p><p>参考教科书是《高等数学（下册）》，华南理工大学数学系，高等教育出版社。</p><h2 id="第一节-多元函数">第一节 多元函数</h2><p><span class="math display">\[\text{7.1.1. 讨论} \mathop{\lim}\limits_{x\rightarrow 0\atop y\rightarrow0} \frac{x^3y}{x^6+y^2} \text{是否存在.}\]</span></p><p>证明这种题常用 <span class="math inline">\(y=kx\)</span> 一类的代换使得从不同方向逼近一个不同极限来证明该极限不存在.</p><p>为了使得得出的表达式与趋于0的 <span class="math inline">\(x,y\)</span> 无关，可以取 <span class="math inline">\(y=kx^3\)</span> ，从而 <span class="math inline">\(\text{原式}=\mathop{\lim}\limits_{x\rightarrow 0\atop y\rightarrow0} \frac{kx^6}{x^6+k^2x^6}=\frac{k}{1+k^2}\)</span> ，该式与 <span class="math inline">\(k\)</span> 有关，所以极限不存在.</p><p><span class="math display">\[\text{7.1.2.讨论极限} \mathop{\lim}\limits_{x\rightarrow 0\atop y\rightarrow0 }\frac{x^2y^2}{x^4+y^4}\]</span></p><p>另外介绍一种课本未提到的方法：利用极坐标转换计算极限相关问题，即作代换 <span class="math inline">\(x=r\cos \theta , y= r\sin \theta\)</span>，则原来的趋近条件变成 $r0 $ ，这也是符合甚至直观上更符合多元函数的极限定义的（一个点的任意小邻域）。</p><p>利用以上代换，原式变为 <span class="math inline">\(\frac{r^2}{r^4(\cos^4 \theta+\sin^4 \theta)}\)</span>，约去 <span class="math inline">\(r^2\)</span> 后得到极限不存在的结论。</p><p><span class="math display">\[\text{7.1.3 讨论极限} \mathop{\lim}\limits_{x\rightarrow 0\atop y\rightarrow0 } \frac{\sqrt{x^2+y^2}-\sin \sqrt{x^2+y^2}}{(x^2+y^2)^\frac{3}{2} }\]</span></p><p>利用以上方法，得到 <span class="math inline">\(\text{原式}=\frac{r-\sin r}{r^3}\)</span> ，洛必达三次得到该极限为 <span class="math inline">\(\frac{1}{6}\)</span>.</p><h2 id="第二节-偏导数">第二节 偏导数</h2><p>要注意对于多元函数的偏导数而言，<span class="math inline">\(\frac{\partial x}{\partial z}\)</span> 一类将分子分母拆开没有意义的。</p><p>定理：若函数 <span class="math inline">\(z=f(x,y)\)</span> 的两个二阶混合偏导数 <span class="math inline">\(\frac{\partial ^2z}{\partial x\partial y},\frac{\partial ^2z}{\partial y\partial x}\)</span> 在区域 <span class="math inline">\(D\)</span> 内连续，则在该区域内两个混合偏导数相等，即</p><p><span class="math display">\[\frac{\partial ^2z}{\partial x\partial y}=\frac{\partial ^2z}{\partial y\partial x}\]</span></p><p>参考教科书没有给出证明，这里补充一个：</p><p>考虑表达式：</p><p><span class="math display">\[W=\frac{f(x+\Delta x,y+\Delta y)-f(x+\Delta x,y)-f(x,y+\Delta y)+f(x,y)}{\Delta x\Delta y}\]</span></p><p>其中 <span class="math inline">\(\Delta x,\Delta y\neq 0\)</span> 且充分小。</p><p>引入函数：</p><p><span class="math display">\[\phi(x,y)=f(x,y+\Delta y)-f(x,y) \qquad (1)\]</span></p><p>则</p><p><span class="math display">\[W=\frac{\phi(x+\Delta x,y)-\phi(x,y)}{\Delta x\Delta y}\]</span></p><p>视 <span class="math inline">\(y\)</span> 为常量，利用拉格朗日中值定理，有</p><p><span class="math display">\[\phi(x+\Delta x,y)-\phi(x,y)=\phi_x(x+\theta_1\Delta x,y)\Delta x\]</span></p><p>与此同时，对 <span class="math inline">\((1)\)</span> 式求导，得到</p><p><span class="math display">\[\phi_x(x+\theta_1 \Delta x,y)=f_x(x+\theta_1\Delta x,y+\Delta y)-f_x(x+\theta_1\Delta x,y)\]</span></p><p>由于<strong>偏导数连续</strong>，因此将 <span class="math inline">\(x+\theta_1\Delta x\)</span> 视为常量，对等式右边再利用一次拉格朗日中值定理，得到：</p><p><span class="math display">\[f_x(x+\theta_1\Delta x,y+\Delta y)-f_x(x+\theta_1\Delta x,y)=f_x(x+\theta_1\Delta x,y+\theta_2\Delta y)\Delta y\]</span></p><p>由以上推导，得到 <span class="math inline">\(W=f_{xy}(x+\theta_1\Delta x,y+\theta_2\Delta y)\)</span></p><p>类似地，如果我们将 <span class="math inline">\((1)\)</span> 式改成</p><p><span class="math display">\[\psi(x,y)=f(x+\Delta x,y)-f(x,y)\]</span></p><p>再做类似的步骤，可以得到 <span class="math inline">\(W=f_{yx}(x+\theta_3\Delta x,y+\theta_4\Delta y)\)</span></p><p>因此有</p><p><span class="math display">\[f_{xy}(x+\theta_1\Delta x,y+\theta_2\Delta y)=W=f_{yx}(x+\theta_3\Delta x,y+\theta_4\Delta y)\]</span></p><p>令 <span class="math inline">\(\Delta x\rightarrow0,\Delta y\rightarrow0\)</span>，得到</p><p><span class="math display">\[f_{xy}(x,y)=f_{yx}(x,y)\]</span></p><p>此即为待证式，证毕。</p><p>值得一提的是，这个证明与下一章可微分的充分条件（见下）的证明异曲同工。都是利用拉格朗日中值定理变换出需要的偏导数形式，而因为使用了中值定理，所以都要求函数连续。同时这两个定理的条件都是充分不必要条件，很有对称美。</p><blockquote><p>如果函数 <span class="math inline">\(z=f(x,y)\)</span> 的两个偏导数在 <span class="math inline">\((x_0,y_0)\)</span> 存在且连续，则该函数在 <span class="math inline">\((x_0,y_0)\)</span> 可微。</p></blockquote><p>若在这里也贴上证明会更好，但是课本已有，篇幅所限就不贴了。</p><h2 id="第三节-全微分及其应用">第三节 全微分及其应用</h2><p>必要条件：</p><p>若 <span class="math inline">\(z\)</span> 在 <span class="math inline">\((x_0,y_0)\)</span> 可微 ，则</p><p><span class="math inline">\(z\)</span> 在 <span class="math inline">\((x_0,y_0)\)</span> 连续，偏导数存在，且满足：</p><p><span class="math display">\[\mathrm{d}z \biggr |_{(x_0,y_0)}=\frac{\partial z}{\partial x}\biggr |_{(x_0,y_0)}\cdot \Delta x+\frac{\partial z}{\partial y}\biggr |_{(x_0,y_0)}\cdot \Delta y\]</span></p><p>注意，使用该公式前需要证明可微。</p><p>充分条件：</p><p>若 <span class="math inline">\(z\)</span> 在 <span class="math inline">\((x_0,y_0)\)</span> 处的偏导数存在且连续，则 <span class="math inline">\(z\)</span> 在 <span class="math inline">\((x_0,y_0)\)</span> 可微。</p><p>要注意，以上都<strong>不是充分必要条件</strong>。</p><p>经典例题：</p><p><span class="math display">\[7.3.1.\text{设函数 } f(x,y)=(x^2+y^2)\sin\frac{1}{x^2+y^2}(x^2+y^2\neq 0),0(x^2+y^2=0)\]</span></p><p><span class="math display">\[\text{证明：（1）}f(x,y) \text{ 在 } (0,0) \text{可微. （2） }f_x(x,y),f_y(x,y) \text{ 在 }(0,0) \text{不连续.} \]</span></p><p>（1）容易知道 $ f_x(0,0) = f_y(0,0) = 0 $, 从而</p><p><span class="math display">\[\Delta f=f(0+\Delta x,0+\Delta y)-f(0,0)=((\Delta x)^2+(\Delta y)^2)\sin \frac{1}{x^2+y^2}\]</span></p><p>因为有 <span class="math inline">\(\rho = (\Delta x)^2+(\Delta y)^2\)</span>,</p><p><span class="math display">\[\Delta f=\frac{((\Delta x)^2+(\Delta y)^2)\sin \frac{1}{x^2+y^2}}{\sqrt{(\Delta x)^2+(\Delta y)^2}}=\rho\sin\frac{1}{\rho ^2}\rightarrow0 (\rho\rightarrow0)\]</span></p><p>此即全微分定义. 故可微.</p><p>（2）当 <span class="math inline">\((x,y)\neq (0,0)\)</span> 时，有</p><p><span class="math display">\[f_x(x,y)=2x\sin\frac{1}{x^2+y^2}-\frac{2x}{(x^2+y^2)}\cos\frac{1}{x^2+y^2}\]</span></p><p><span class="math display">\[f_y(x,y)=2y\sin\frac{1}{x^2+y^2}-\frac{2y}{(x^2+y^2)}\cos\frac{1}{x^2+y^2}\]</span></p><p><span class="math display">\[f_x(x,0)=2x\sin\frac{1}{x^2}-\frac{2}{x}\cos\frac{1}{x^2}\]</span></p><p>可以看出偏导数在 <span class="math inline">\((0,0)\)</span> 不存在，故不连续.</p><p>这是第三个结论，“充分条件”的一个反例.</p><p><span class="math display">\[7.3.3. \text{证明：}f(x,y)=\sqrt{|xy|}\text{在}(0,0)\text{处不可微.}\]</span></p><p>利用定义：</p><blockquote><p>若 函数 <span class="math inline">\(f(x,y)\)</span> 在点 <span class="math inline">\(P_0(x_0,y_0)\)</span> 处的全增量</p></blockquote><blockquote><p><span class="math display">\[ \Delta z=f(x_0+\Delta x,y_0+\Delta y)-f(x_0,y_0)\quad(1)\]</span></p></blockquote><blockquote><p>可以表示为</p></blockquote><blockquote><p><span class="math display">\[\Delta z=A\Delta x+B\Delta y+o(\rho) \quad(2)\]</span></p></blockquote><blockquote><p>其中 <span class="math inline">\(A,B\)</span> 只和点 <span class="math inline">\((x_0,y_0)\)</span> 有关，而与 <span class="math inline">\(\Delta x,\Delta y\)</span> 无关，<span class="math inline">\(\rho = \sqrt{(\Delta x)^2+(\Delta y)^2}\)</span>，则该函数在 <span class="math inline">\(P_0\)</span> 可微，且 <span class="math inline">\(A\Delta x+B\Delta y\)</span> 为其在该点的全微分。</p></blockquote><p>那么利用 <span class="math inline">\(\Delta z-\Delta z=f(x_0+\Delta x,y_0+\Delta y)-f(x_0,y_0)-A\Delta x-B\Delta y\)</span> 得到 <span class="math inline">\(o(\rho)\)</span> ，再除以 <span class="math inline">\(\rho\)</span> ，得出的结果为 <span class="math inline">\(0\)</span> 则说明确实是无穷小，不为0则不可微。</p><p><span class="math display">\[\mathop{\lim}\limits_{\Delta x\rightarrow 0\atop \Delta y\rightarrow0 }\frac{[f(0+\Delta x,0+\Delta y)-f(0,0)]-[f_x(0,0)\Delta x+f_y(0,0)\Delta y]}{\sqrt{(\Delta x)^2+(\Delta y)^2}}=\mathop{\lim}\limits_{\Delta x\rightarrow 0\atop \Delta y\rightarrow0 }\frac{\sqrt{|\Delta x\Delta y|}}{\sqrt{(\Delta x)^2+(\Delta y)^2}}\]</span></p><p>不存在。故不可微。</p><p>一般证明可微或不可微的步骤：</p><p>1.先求出偏导数 <span class="math inline">\(f_x(x_0,y_0),f_y(x_0,y_0)\)</span>，若不存在则不可微</p><p>2.计算 <span class="math inline">\(\Delta z=f(0+\Delta x,0+\Delta y)-f(0,0)\)</span> 的存在性，若不存在则不可微。</p><p>3.计算 <span class="math inline">\(\frac{f(x_0+\Delta x,y_0+\Delta y)-f(x_0,y_0)-f_x(x_0,y_0)\Delta x-f_y(x_0,y_0)\Delta y}{\sqrt{(\Delta x)^2+(\Delta y)^2}}\)</span> ，若等于 <span class="math inline">\(0\)</span> 则可微。</p><p>判断是否为 <span class="math inline">\(0\)</span> 常用找一条路径 <span class="math inline">\(\Delta y=k(\Delta x)^a\)</span>，使得沿这条路径的极限不为0或不存在。</p><p>补充一张互相推导的图：</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/3aor39uf.png" /></p><p><span class="math display">\[7.3.2\quad u=f(x,y),g(x,y,z)=0,h(x,z)=0, \text{求}\frac{\mathrm{d}u}{\mathrm dx}\]</span></p><p>由全微分形式不变性，两边微分可得</p><p><span class="math display">\[\mathrm{d}u=f_x\mathrm{d}x+f_y\mathrm{d}y\]</span></p><p><span class="math display">\[g_x\mathrm dx+g_y\mathrm dy+g_z\mathrm{d}z=0\]</span></p><p><span class="math display">\[h_x\mathrm d x+h_z\mathrm{d}z=0\]</span></p><p>由二式解出 <span class="math inline">\(\mathrm d y\)</span> 关于 <span class="math inline">\(\mathrm dx,\mathrm dz\)</span> 的表达式</p><p>由三式解出 <span class="math inline">\(\mathrm d z\)</span> 关于 <span class="math inline">\(\mathrm dx\)</span> 的表达式</p><p>代入一式得 <span class="math inline">\(\frac{\mathrm{d}u}{\mathrm dx}=f_x-\frac{f_yg_x}{g_y}+\frac{f_yg_zh_x}{g_yh_z}\)</span></p><h2 id="第四节-多元复合函数的求导法则">第四节 多元复合函数的求导法则</h2><p><span class="math display">\[ 7.4.2\quad  \text{已知 }e^{-xy}-2z+e^z=0,\text{求} \frac{\partial z}{\partial x},\frac{\partial z}{\partial  y}\]</span></p><p><span class="math display">\[\mathrm{d}(e^{-xy}-2z+e^z)=0\]</span></p><p><span class="math display">\[e^{-xy}\mathrm{d}(-xy)-2z\mathrm{d}z+e^z\mathrm{d}z=0\]</span></p><p><span class="math display">\[(e^z-2)\mathrm{d}z=e^{-xy}(x\mathrm{d}y+y\mathrm{d}x)\]</span></p><p>利用全微分的形式不变性，得到</p><p><span class="math display">\[\mathrm{d}z=\frac{ye^{-xy}}{(e^z-2)}\mathrm{d}x+\frac{xe^{-xy}}{(e^z-2)}\mathrm{d}y\]</span></p><p>从而</p><p><span class="math display">\[\frac{\partial z}{\partial x}=\frac{ye^{-xy}}{(e^z-2)},\frac{\partial z}{\partial  y}=\frac{xe^{-xy}}{(e^z-2)}\]</span></p><p>利用下一节介绍的隐函数求导法也可以得到这一结果：</p><p><span class="math display">\[F=e^{-xy}-2z+e^z=0\]</span></p><p><span class="math display">\[F_x=-ye^{-xy}\]</span></p><p><span class="math display">\[F_y=-xe^{-xy}\]</span></p><p><span class="math display">\[F_z=-2+e^z\]</span></p><p><span class="math display">\[\frac{\partial z}{\partial x}=\frac{F_x}{F_z}=\frac{ye^{-xy}}{(e^z-2)},\frac{\partial z}{\partial  y}=\frac{F_y}{F_z}=\frac{xe^{-xy}}{(e^z-2)}\]</span></p><p><span class="math display">\[7.4.3\quad \text{设 } f(x,y) \text{ 是 } k \text{ 次齐次函数，即 }f(tx,ty,tz)=t^kf(x,y,z),\lambda \text{为某一常数，则下列结论正确的是：}\]</span></p><p><span class="math display">\[(A)x\frac{\partial f}{\partial x}+y\frac{\partial f}{\partial v}+z\frac{\partial f}{\partial z}=k^\lambda f(x,y,z)\]</span></p><p><span class="math display">\[(B)x\frac{\partial f}{\partial x}+y\frac{\partial f}{\partial v}+z\frac{\partial f}{\partial z}=\lambda^k f(x,y,z)\]</span></p><p><span class="math display">\[(C)x\frac{\partial f}{\partial x}+y\frac{\partial f}{\partial v}+z\frac{\partial f}{\partial z}=kf(x,y,z)\]</span></p><p><span class="math display">\[(D)x\frac{\partial f}{\partial x}+y\frac{\partial f}{\partial v}+z\frac{\partial f}{\partial z}= f(x,y,z)\]</span></p><p>令 <span class="math inline">\(u=tx,v=ty,w=tz\)</span> ，则 <span class="math inline">\(f(u,v,w)=t^kf(x,y,z)\)</span></p><p>两边对 <span class="math inline">\(t\)</span> 求导，得</p><p><span class="math display">\[\frac{\partial f}{\partial u}\cdot\frac{\partial u}{\partial t}+\frac{\partial f}{\partial v}\cdot\frac{\partial v}{\partial t}+\frac{\partial f}{\partial w}\cdot\frac{\partial w}{\partial t}=kt^{k-1}f(x,y,z)\]</span></p><p>即</p><p><span class="math display">\[\frac{\partial f}{\partial u}\cdot x+\frac{\partial f}{\partial v}\cdot y+\frac{\partial f}{\partial w}\cdot z=kt^{k-1}f(x,y,z)\]</span></p><p>两边同乘 <span class="math inline">\(t\)</span> ，得：</p><p><span class="math display">\[\frac{\partial f}{\partial u}\cdot u+\frac{\partial f}{\partial v}\cdot v+\frac{\partial f}{\partial w}\cdot w=kt^{k}f(x,y,z)=kf(u,v,w)\]</span></p><p>故选 <span class="math inline">\(C\)</span>.</p><p><span class="math display">\[7.4.4. \quad x=e^u\cos v,y=e^u\sin v,z=uv,\text{ 求 }\frac{\partial z}{\partial x},\frac{\partial z}{\partial y}\]</span></p><p><span class="math display">\[\frac{\partial z}{\partial x}=\frac{\partial z}{\partial u}\cdot \frac{\partial u}{\partial x}+\frac{\partial z}{\partial v}\cdot \frac{\partial v}{\partial x}=v\cdot \frac{\partial u}{\partial x}+u\cdot \frac{\partial v}{\partial x}\]</span></p><p>对 $ x=e<sup>uv,y=e</sup>uv$ 对 <span class="math inline">\(x\)</span> 求偏导，得到</p><p><span class="math display">\[1=e^u\frac{\partial u}{\partial x}\cos v-e^u\sin v\frac{\partial v}{\partial x}\]</span></p><p><span class="math display">\[0=e^u\frac{\partial u}{\partial x}\sin v+e^u\cos v\frac{\partial v}{\partial x}\]</span></p><p>解出 <span class="math inline">\(\frac{\partial u}{\partial x},\frac{\partial v}{\partial x}\)</span> ，代入公式即得 <span class="math inline">\(\frac{\partial z}{\partial x}\)</span>，<span class="math inline">\(\frac{\partial z}{\partial y}\)</span> 同理.</p><p><span class="math display">\[7.4.5.\text{设变换 }u=x-2y,v=x+ay \text{可以将方程 } 6\frac{\partial^2z}{\partial x^2}+\frac{\partial^2z}{\partial x\partial y}-\frac{\partial^2z}{\partial y^2}\text{ 简化为 }\frac{\partial^2z}{\partial u\partial v}=0, \text{求常数 }a\]</span></p><p><span class="math display">\[\frac{\partial z}{\partial x}=\frac{\partial z}{\partial u}\cdot \frac{\partial u}{\partial x}+\frac{\partial z}{\partial v}\cdot \frac{\partial v}{\partial x}=\frac{\partial z}{\partial u}+\frac{\partial z}{\partial v}\]</span></p><p><span class="math display">\[\frac{\partial z}{\partial y}=-2\frac{\partial z}{\partial u}+a\frac{\partial z}{\partial v}\]</span></p><p><span class="math display">\[\frac{\partial^2 z}{\partial x\partial y}=\frac{\partial^2 z}{\partial u^2}\cdot\frac{\partial u}{\partial y}+\frac{\partial^2 z}{\partial u\partial v}\cdot\frac{\partial u}{\partial y}+\frac{\partial^2 z}{\partial u\partial v}\cdot\frac{\partial v}{\partial y}+\frac{\partial^2 z}{\partial v^2}\cdot\frac{\partial v}{\partial y}\]</span></p><p><span class="math display">\[\frac{\partial^2 z}{\partial x\partial y}=-2\frac{\partial^2 z}{\partial u^2}-2\frac{\partial^2 z}{\partial v\partial u}+a\frac{\partial^2 z}{\partial u\partial v}+a\frac{\partial^2 z}{\partial v^2}\]</span></p><p><span class="math display">\[\frac{\partial^2 z}{\partial x^2}=\frac{\partial^2 z}{\partial u^2}+\frac{\partial^2 z}{\partial u\partial v}+\frac{\partial^2 z}{\partial v\partial u}+\frac{\partial^2 z}{\partial v^2}\]</span></p><p><span class="math display">\[\frac{\partial^2 z}{\partial y^2}=4\frac{\partial^2 z}{\partial u^2}-2a\frac{\partial^2 z}{\partial u\partial v}-2a\frac{\partial^2 z}{\partial v\partial u}+a^2\frac{\partial^2 z}{\partial v^2}\]</span></p><p>根据题设，合并同类项，得到 <span class="math inline">\(6+a-a^2=0,10+5a\neq 0\)</span> ，即<span class="math inline">\(a=3.\)</span></p><h2 id="第五节-隐函数求导法">第五节 隐函数求导法</h2><p>隐函数存在定理：</p><blockquote><p>设二元函数 <span class="math inline">\(F(x,y)\)</span> 在点 <span class="math inline">\(P(x_0,y_0)\)</span> 的某一邻域内满足：</p></blockquote><blockquote><p>(1)具有连续偏导数</p></blockquote><blockquote><p>(2)<span class="math inline">\(F(x_0,y_0)=0\)</span></p></blockquote><blockquote><p>(3)<span class="math inline">\(F_y(x_0,y_0)=0\)</span></p></blockquote><blockquote><p>则 函数 <span class="math inline">\(F(x,y)\)</span> 在点 <span class="math inline">\(P(x_0,y_0)\)</span> 的某一邻域 的某一邻域内恒能唯一确定一个具有连续导数的函数 <span class="math inline">\(y=f(x)\)</span> ，它满足 <span class="math inline">\(y_0=f(x_0)\)</span> ，并有 <span class="math inline">\(-\frac{F_x(x,y)}{F_y(x,y)}\)</span></p></blockquote><p>多元函数的情况是类似的。</p><p>本书对证明不做要求 <del>，这里补充一个证明：</del> ，但是他太长了，不写了。</p><p>推广到多元：</p><p><span class="math display">\[-\mathrm{d}z=\frac{F_{x_1}}{F_z}\mathrm{d}x_1+\frac{F_{x_2}}{F_z}\mathrm{d}x_2+\cdots+\frac{F_{x_n}}{F_z}\mathrm{d}x_n\]</span></p><p><span class="math display">\[7.5.1. \text{设函数 } f(x,y) \text{ 有连续偏导数，试用极坐标的转换公式 } x=r\cos \theta,y=r\sin \theta\text{ 将 } x\frac{\partial u}{\partial y}-y\frac{\partial u}{\partial x}\text{变化为}r,\theta\text{ 下的表达式.}\]</span></p><p>可以将 <span class="math inline">\(r,\theta\)</span> 视为自变量， <span class="math inline">\(x,y\)</span> 视为中间变量。也可以反过来将 <span class="math inline">\(x,y\)</span> 视为自变量，将 <span class="math inline">\(r,\theta\)</span> 视为中间变量，这两种视角都导出一种可行的解法。</p><p>法一，将 <span class="math inline">\(x,y\)</span> 视为中间变量</p><p>根据条件，有：</p><p><span class="math display">\[\frac{\partial x}{\partial \theta}=-r\sin\theta=-y,\frac{\partial y}{\partial \theta}=r\cos\theta=x\]</span></p><p><span class="math display">\[\frac{\partial u}{\partial \theta} =\frac{\partial u}{\partial x}\cdot\frac{\partial x}{\partial \theta}+\frac{\partial u}{\partial y}\cdot \frac{\partial y}{\partial \theta}=-(x\frac{\partial u}{\partial u}-y\frac{\partial u}{\partial x})\]</span></p><p>故</p><p><span class="math display">\[x\frac{\partial u}{\partial u}-y\frac{\partial u}{\partial x}=-\frac{\partial u}{\partial \theta}\]</span></p><h2 id="第六节-方向导数与梯度">第六节 方向导数与梯度</h2><p>方向导数存在的充分条件：</p><blockquote><p>如果函数 <span class="math inline">\(f(x,y)\)</span> 在 <span class="math inline">\(P_0(x_0,y_0)\)</span> 可微分，那么函数在该点沿任意方向 <span class="math inline">\(\boldsymbol{l}\)</span> 的方向导数存在，且有：</p></blockquote><blockquote><p><span class="math display">\[\frac{\partial f}{\partial \boldsymbol{l}}\Biggr |_{P_0}=f_x(x_0,y_0)\cos \alpha+f_y(x_0,y_0)\cos \beta\]</span></p></blockquote><blockquote><p>其中 <span class="math inline">\(\cos \alpha,\cos \beta\)</span> 是方向 <span class="math inline">\(\boldsymbol{l}\)</span> 的方向余弦.</p></blockquote><h2 id="第八节-多元函数的极值">第八节 多元函数的极值</h2><p><span class="math display">\[  7.8.1 \text{ 在第一卦限内作椭球面 }\frac{x^2}{a^2}+\frac{y^2}{b^2}+\frac{z^2}{c^2}=1 \text{ 的切平面使得该切平面与三个坐标平面围成的四面体的体积最小，求切点的坐标.} \]</span></p><p>设切点 <span class="math inline">\((x_0,y_0,z_0)\)</span> 可以得到法平面方程 <span class="math inline">\((x-x_0)\frac{x_0}{a^2}+(y-y_0)\frac{y_0}{b^2}+(z-z_0)\frac{z_0}{c^2}=0\)</span>，即</p><p><span class="math display">\[\frac{xx_0}{a^2}+\frac{yy_0}{b^2}+\frac{zz_0}{c^2}=1\]</span></p><p><span class="math display">\[V=\frac{a^2b^2c^2}{6x_0y_0z_0}\]</span></p><p>实际上就是求 <span class="math inline">\(V\)</span> 在 <span class="math inline">\(\frac{x^2}{a^2}+\frac{y^2}{b^2}+\frac{z^2}{c^2}=1\)</span> 条件下的最值。</p><p>但是 <span class="math inline">\(V\)</span> 太难求偏导了，改为求 <span class="math inline">\(x_0y_0z_0\)</span> 的最大值</p><p>于是设 <span class="math inline">\(F=xyz+\lambda(\frac{x^2}{a^2}+\frac{y^2}{b^2}+\frac{z^2}{c^2}-1)\)</span></p><p>但是这样 <span class="math inline">\(F_x\)</span> 和 <span class="math inline">\(x,y,z\)</span> 都相关，于是改设 <span class="math inline">\(F=\ln x+\ln y +\ln z+\lambda(\frac{x^2}{a^2}+\frac{y^2}{b^2}+\frac{z^2}{c^2}-1)\)</span></p><p>这样每个偏导数的表达式都只与其主元相关，大大方便了计算.</p><p>得到结果 <span class="math inline">\(x_0=\frac{a}{\sqrt 3},y_0=\frac{b}{\sqrt 3},z_0=\frac{c}{\sqrt 3}\)</span>.</p><p>最小二乘法：极值的运用。</p><p>对于多组样本点，找一条直线拟合使得偏差的平方和最小：</p><p>计偏差函数 <span class="math inline">\(M=\sum_{i=0}^t[y_i-(at_i+b)]\)</span></p><p><span class="math display">\[\frac{\partial M}{\partial a}=0,\frac{\partial M}{\partial b}=0\]</span></p><p>从而得到驻点：</p><p><span class="math display">\[a=\frac{n\sum_{i=1}^{n}x_iy_i-(\sum_{i=1}^{n}x_i)(\sum_{i=1}^{n}y_i)}{n\sum_{i=1}^{n}x_i^2-(\sum_{i=1}^{n}x_i)^2}\]</span></p>]]></content>
      
      
      <categories>
          
          <category> 课程笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> math </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WBLT：一种比较少见的平衡树</title>
      <link href="/2023/05/08/WBLT%EF%BC%9A%E4%B8%80%E7%A7%8D%E6%AF%94%E8%BE%83%E5%B0%91%E8%A7%81%E7%9A%84%E5%B9%B3%E8%A1%A1%E6%A0%91/"/>
      <url>/2023/05/08/WBLT%EF%BC%9A%E4%B8%80%E7%A7%8D%E6%AF%94%E8%BE%83%E5%B0%91%E8%A7%81%E7%9A%84%E5%B9%B3%E8%A1%A1%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>本文收录于2019年3月的洛谷日报，原文初稿于 2019-01-20.</p><hr /><p>WBLT 全称 <span class="math inline">\(\text{Weight Balanced Leafy Tree}\)</span>. 是一种常数较小，代码较简单的平衡树实现方式。</p><p>在看本文之前，推荐您先学习 treap 等平衡树 这篇文章对于有平衡树基础的人较为友好</p><h2 id="定义和引入">定义和引入</h2><p>WBLT是二叉搜索树的一种。不同的是，他同时是一个大根堆（也可以是小根堆），每个非叶节点都有两个儿子，且每个节点的权值与其右儿子的权值相同，且左儿子的权值小于右儿子的权值，左子树的所有节点的权值小于右子树任意节点的权值。</p><p>也就是说他大概长这样：</p><p><img src="https://cdn.luogu.com.cn/upload/pic/49109.png" /></p><p>这种设计有一个明显的缺点 就是如果要储存n个数据，普通的平衡树需要开n个节点，而WBLT需要开2n-1个</p><p>也就是说 储存上图的数据的treap长这样：</p><p><img src="https://cdn.luogu.com.cn/upload/pic/49110.png" /></p><p>那么 相比之下它有什么好处呢？</p><h2 id="旋转">旋转</h2><p>WBLT= Weight Balanced Tree（加权平衡树） + Leafy，其中Leafy已经在定义和引入中体现了，平衡是指一个节点的左子树和右子树大小近似相同，这样在查询/修改的时候才能做到近似log，旋转便是维护平衡的方便手段</p><p>因为其结构特殊 不需要像treap一样引入一个rand，只要旋转就可以维护其平衡。</p><p>先给出旋转的代码 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    size[++cnt]=size[l]+size[r];</span><br><span class="line">    val[cnt]=val[r];</span><br><span class="line">    ls[cnt]=l,rs[cnt]=r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">rotate</span><span class="params">(<span class="type">int</span> cur,<span class="type">bool</span> flag)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">        <span class="built_in">merge</span>(ls[cur],ls[rs[cur]]);</span><br><span class="line">        ls[cur]=cnt;</span><br><span class="line">        rs[cur]=rs[rs[cur]];</span><br><span class="line">    &#125;<span class="comment">//左旋</span></span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">merge</span>(rs[ls[cur]],rs[cur]);</span><br><span class="line">        rs[cur]=cnt;</span><br><span class="line">        ls[cur]=ls[ls[cur]];</span><br><span class="line">    &#125;<span class="comment">//右旋</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 再给出图例（节点上的数字为编号，数字颜色为红色则为新节点）： <img src="https://cdn.luogu.com.cn/upload/pic/49144.png" /> 可以发现，旋转后的WBLT仍然保持原来的性质。而且明显偏重的左子树转到了右边，左右子树相对平衡了。</p><h2 id="查询排名为x的数">查询排名为x的数</h2><p>我们记录每个节点的size，这个size不是子树的大小，而是子树储存的有效信息的大小。</p><p>因为有性质_储存n个数据要开2n-1个节点_，所以如果一个子树的大小为<span class="math inline">\(2x-1\)</span>，那它储存的数据量就有<span class="math inline">\(x\)</span>个。</p><p>接下来的操作就简单了，令find(cur,x)为寻找cur所在的子树下排名为x的数，那么当x比左子树的size小</p><p><span class="math inline">\(find(cur,x)=find(lson_{cur},x)\)</span></p><p>当x比左子树的size大</p><p>$find(cur,x)=find(rson_{cur},x-size_{lson_{cur}})</p><p>如果相等，那显然</p><p><span class="math inline">\(find(cur,x)=val_{cur}\)</span></p><p>因为当前要找的是第x大，那我无需遍历下面，这点也与treap不同</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> cur,<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(size[cur]==x)</span><br><span class="line">        <span class="keyword">return</span> val[cur];</span><br><span class="line">    <span class="keyword">if</span>(x&gt;size[ls[cur]])</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">find</span>(rs[cur],x-size[ls[cur]]);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">find</span>(ls[cur],x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="查询x的排名">查询x的排名</h2><p>同理，设rnk(cur,x)为寻找cur子树下x的排名</p><p>当x小于cur的左儿子的权值</p><p><span class="math inline">\(rnk(cur,x)=rnk(lson_{cur},x)\)</span></p><p>否则</p><p><span class="math inline">\(rnk(cur,x)=size_{lson_{cur}}+rnk(rson_{cur},x)\)</span></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">rnk</span><span class="params">(<span class="type">int</span> cur,<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(size[cur]==<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x&gt;val[ls[cur]])</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">rnk</span>(rs[cur],x)+size[ls[cur]];</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">rnk</span>(ls[cur],x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="插入">插入</h2><p>WBLT其他的操作都与treap类似，在每一步时：</p><blockquote><p>根据要添加的权值和当前搜索到的节点选择左右子树进行递归（如果比左儿子的权值大就去右子树，否则去左子树）</p></blockquote><blockquote><p>递归到最后一步到一个叶子节点时，根据其权值大小建立新节点，确定是该节点的左儿子还是右儿子</p></blockquote><blockquote><p>建立它的兄弟节点。</p></blockquote><blockquote><p>向上pushup（类似于线段树，儿子会影响父亲，这点于与treap不同）。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> cur,<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(size[cur]==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">newnode</span>(ls[cur],<span class="built_in">minn</span>(x,val[cur]));</span><br><span class="line">        <span class="built_in">newnode</span>(rs[cur],<span class="built_in">maxx</span>(x,val[cur]));</span><br><span class="line">        <span class="built_in">pushup</span>(cur);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">insert</span>(x&gt;val[ls[cur]]?rs[cur]:ls[cur],x);</span><br><span class="line">    <span class="built_in">pushup</span>(cur);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="删除">删除</h2><p>在每一步时：</p><blockquote><p>根据要删除权值和当前搜索到的节点选择左右子树进行递归（如果比左儿子的权值大就去右子树，否则去左子树）</p></blockquote><blockquote><p>递归到最后一步到一个叶子节点时，判断该节点是不是要删除的，如果不是则选择其兄弟节点，进行删除，将两个节点中保留的与其父亲节点进行替换</p></blockquote><blockquote><p>向上pushup。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">erase</span><span class="params">(<span class="type">int</span> cur,<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(size[cur]==<span class="number">1</span>)&#123;</span><br><span class="line">        cur= ls[fa]==cur?rs[fa]:ls[fa];</span><br><span class="line">        <span class="built_in">copynode</span>(fa,cur);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    fa=cur;</span><br><span class="line">    <span class="built_in">erase</span>(x&gt;val[ls[cur]]?rs[cur]:ls[cur],x);</span><br><span class="line">    <span class="built_in">pushup</span>(cur);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="旋转和p3369">旋转，和P3369</h2><p>等等 旋转呢？</p><p>我们在上文所有的操作中，似乎没有使用旋转，那旋转放在哪呢？</p><p>我们将其放在树的结构有改变的地方，也就是插入 删除这些操作中，每当一个子树过大，就进行相应的旋转，在插入和删除操作中加入以下函数即可</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> ratio=<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">maintain</span><span class="params">(<span class="type">int</span> cur)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(size[ls[cur]]&gt;size[rs[cur]]*ratio)</span><br><span class="line">        <span class="built_in">rotate</span>(cur,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(size[rs[cur]]&gt;size[ls[cur]]*ratio)</span><br><span class="line">        <span class="built_in">rotate</span>(cur,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么普通平衡树的代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn=<span class="number">400010</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> ratio=<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,cnt,fa,root;</span><br><span class="line"><span class="type">int</span> size[maxn],ls[maxn],rs[maxn],val[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">newnode</span><span class="params">(<span class="type">int</span> &amp;cur,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">    cur=++cnt;</span><br><span class="line">    size[cur]=<span class="number">1</span>;</span><br><span class="line">    val[cur]=v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">copynode</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    size[x]=size[y];</span><br><span class="line">    ls[x]=ls[y],rs[x]=rs[y];</span><br><span class="line">    val[x]=val[y];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    size[++cnt]=size[l]+size[r];</span><br><span class="line">    val[cnt]=val[r];</span><br><span class="line">    ls[cnt]=l,rs[cnt]=r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">rotate</span><span class="params">(<span class="type">int</span> cur,<span class="type">bool</span> flag)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">        <span class="built_in">merge</span>(ls[cur],ls[rs[cur]]);</span><br><span class="line">        ls[cur]=cnt;</span><br><span class="line">        rs[cur]=rs[rs[cur]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">merge</span>(rs[ls[cur]],rs[cur]);</span><br><span class="line">        rs[cur]=cnt;</span><br><span class="line">        ls[cur]=ls[ls[cur]];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">maintain</span><span class="params">(<span class="type">int</span> cur)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(size[ls[cur]]&gt;size[rs[cur]]*ratio)</span><br><span class="line">        <span class="built_in">rotate</span>(cur,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(size[rs[cur]]&gt;size[ls[cur]]*ratio)</span><br><span class="line">        <span class="built_in">rotate</span>(cur,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> cur)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!size[ls[cur]])<span class="keyword">return</span> ;</span><br><span class="line">    size[cur]=size[ls[cur]]+size[rs[cur]];</span><br><span class="line">    val[cur]=val[rs[cur]];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">minn</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a&lt;b?a:b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">maxx</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a&gt;b?a:b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> cur,<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(size[cur]==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">newnode</span>(ls[cur],<span class="built_in">minn</span>(x,val[cur]));</span><br><span class="line">        <span class="built_in">newnode</span>(rs[cur],<span class="built_in">maxx</span>(x,val[cur]));</span><br><span class="line">        <span class="built_in">pushup</span>(cur);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">maintain</span>(cur);</span><br><span class="line">    <span class="built_in">insert</span>(x&gt;val[ls[cur]]?rs[cur]:ls[cur],x);</span><br><span class="line">    <span class="built_in">pushup</span>(cur);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">erase</span><span class="params">(<span class="type">int</span> cur,<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(size[cur]==<span class="number">1</span>)&#123;</span><br><span class="line">        cur= ls[fa]==cur?rs[fa]:ls[fa];</span><br><span class="line">        <span class="built_in">copynode</span>(fa,cur);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">maintain</span>(cur);</span><br><span class="line">    fa=cur;</span><br><span class="line">    <span class="built_in">erase</span>(x&gt;val[ls[cur]]?rs[cur]:ls[cur],x);</span><br><span class="line">    <span class="built_in">pushup</span>(cur);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> cur,<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(size[cur]==x)</span><br><span class="line">        <span class="keyword">return</span> val[cur];</span><br><span class="line">    <span class="built_in">maintain</span>(cur);</span><br><span class="line">    <span class="keyword">if</span>(x&gt;size[ls[cur]])</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">find</span>(rs[cur],x-size[ls[cur]]);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">find</span>(ls[cur],x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">rnk</span><span class="params">(<span class="type">int</span> cur,<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(size[cur]==<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">maintain</span>(cur);</span><br><span class="line">    <span class="keyword">if</span>(x&gt;val[ls[cur]])</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">rnk</span>(rs[cur],x)+size[ls[cur]];</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">rnk</span>(ls[cur],x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="built_in">newnode</span>(root,(<span class="number">1</span>&lt;&lt;<span class="number">30</span>));</span><br><span class="line">    <span class="keyword">while</span>(n--)&#123;</span><br><span class="line">        <span class="type">int</span> s,x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;s,&amp;x);</span><br><span class="line">        <span class="keyword">if</span>(s==<span class="number">1</span>)<span class="built_in">insert</span>(root,x);</span><br><span class="line">        <span class="keyword">if</span>(s==<span class="number">2</span>)<span class="built_in">erase</span>(root,x);</span><br><span class="line">        <span class="keyword">if</span>(s==<span class="number">3</span>)<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">rnk</span>(root,x));</span><br><span class="line">        <span class="keyword">if</span>(s==<span class="number">4</span>)<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">find</span>(root,x));</span><br><span class="line">        <span class="keyword">if</span>(s==<span class="number">5</span>)<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">find</span>(root,<span class="built_in">rnk</span>(root,x)<span class="number">-1</span>));</span><br><span class="line">        <span class="keyword">if</span>(s==<span class="number">6</span>)<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">find</span>(root,<span class="built_in">rnk</span>(root,x+<span class="number">1</span>)));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下是评测记录</p><p><img src="https://cdn.luogu.com.cn/upload/pic/49195.png" /></p><p><em>上面的是treap，下面的是WBLT</em></p><p>我们发现，WBLT只比treap慢一点点，所以WBLT和treap几乎是一样块的~</p><h2 id="例题">例题</h2><h3 id="p1503-鬼子进村">P1503 鬼子进村</h3><p>平衡树部分是个裸题，其他倒还得想想</p><p>先把0和n+1插入，作为边界</p><p>摧毁节点就插入该点</p><p>删除上一个就维护个栈，删除栈顶即可</p><p>询问操作就查找前驱和后继，一减就行了，记得特判是否已经被摧毁（记个vis数组即可）</p><p><a href="https://www.luogu.org/paste/5isx0y4z">代码</a></p><h3 id="p2596-zjoi2006书架">P2596 [ZJOI2006]书架</h3><p>平衡树部分还是个裸题</p><p>定义优先级越小，那本书就放越上面</p><p>设<span class="math inline">\(a_i\)</span>为编号为<span class="math inline">\(i\)</span>的书本的优先级，<span class="math inline">\(mapp_i\)</span>为优先级为i的节点编号。</p><p>Top S:将优先级变为最小再插入</p><p>Bottom S：将优先级变为最大再插入</p><p>Insert S T：找到对应两本书 交换优先级</p><p>Ask S：查询优先级排名</p><p>Query S：查询第k小的优先级对应的编号</p><p>代码:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn=<span class="number">400010</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> ratio=<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">register</span> <span class="type">int</span> num=<span class="number">0</span>,flag=<span class="number">1</span>;<span class="type">char</span> ch;</span><br><span class="line">    <span class="keyword">while</span>((ch=<span class="built_in">getchar</span>())&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>) <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) flag=<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">else</span> num=ch-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="keyword">while</span>((ch=<span class="built_in">getchar</span>())&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>) num=num*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> num*flag; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">out</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&gt;=<span class="number">10</span>) <span class="built_in">out</span>(x/<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">putchar</span>(x%<span class="number">10</span>+<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m,cnt,fa,root;</span><br><span class="line"><span class="type">int</span> size[maxn],ls[maxn],rs[maxn],val[maxn],a[maxn];</span><br><span class="line"><span class="type">int</span> mapp[maxn];</span><br><span class="line"></span><br><span class="line"><span class="comment">/*此处有省略，平衡树部分请参照上文*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> opt[<span class="number">20</span>];</span><br><span class="line"><span class="type">int</span> k,l,r,i;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    n=<span class="built_in">read</span>();</span><br><span class="line">    m=<span class="built_in">read</span>();</span><br><span class="line">    <span class="built_in">newnode</span>(root,(<span class="number">1</span>&lt;&lt;<span class="number">30</span>));</span><br><span class="line">    l=<span class="number">233333</span>,r=n+<span class="number">233333</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> qaq;</span><br><span class="line">        qaq=<span class="built_in">read</span>();</span><br><span class="line">        <span class="built_in">insert</span>(root,i+<span class="number">233333</span>);</span><br><span class="line">        a[qaq]=i+<span class="number">233333</span>;</span><br><span class="line">        mapp[i+<span class="number">233333</span>]=qaq;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(m--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,opt);</span><br><span class="line">        <span class="keyword">if</span>(opt[<span class="number">0</span>]==<span class="string">&#x27;Q&#x27;</span>) &#123;</span><br><span class="line">            k=<span class="built_in">read</span>();</span><br><span class="line">            <span class="built_in">out</span>(mapp[<span class="built_in">find</span>(root,k)]);</span><br><span class="line">            <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(opt[<span class="number">0</span>]==<span class="string">&#x27;A&#x27;</span>) &#123;</span><br><span class="line">            k=<span class="built_in">read</span>();</span><br><span class="line">            <span class="built_in">out</span>(<span class="built_in">rnk</span>(root,a[k])<span class="number">-1</span>);</span><br><span class="line">            <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(opt[<span class="number">0</span>]==<span class="string">&#x27;T&#x27;</span>) &#123;</span><br><span class="line">            k=<span class="built_in">read</span>();</span><br><span class="line">            <span class="built_in">erase</span>(root,a[k]);</span><br><span class="line">            <span class="built_in">insert</span>(root,--l);</span><br><span class="line">            a[k]=l;</span><br><span class="line">            mapp[l]=k;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(opt[<span class="number">0</span>]==<span class="string">&#x27;B&#x27;</span>) &#123;</span><br><span class="line">            k=<span class="built_in">read</span>();</span><br><span class="line">            <span class="built_in">erase</span>(root,a[k]);</span><br><span class="line">            <span class="built_in">insert</span>(root,++r);</span><br><span class="line">            a[k]=r;</span><br><span class="line">            mapp[r]=k;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(opt[<span class="number">0</span>]==<span class="string">&#x27;I&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">register</span> <span class="type">int</span> s=<span class="built_in">read</span>(),t=<span class="built_in">read</span>();</span><br><span class="line">            <span class="keyword">if</span>(t==<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="type">int</span> rnk2=<span class="built_in">rnk</span>(root,a[s]),rnk1=rnk2+<span class="number">1</span>;</span><br><span class="line">                <span class="type">int</span> s2=<span class="built_in">find</span>(root,rnk1);</span><br><span class="line">                s2=mapp[s2];</span><br><span class="line">                <span class="built_in">erase</span>(root,a[s]);</span><br><span class="line">                <span class="built_in">erase</span>(root,a[s2]);</span><br><span class="line">                <span class="built_in">swap</span>(a[s],a[s2]);</span><br><span class="line">                mapp[a[s]]=s;</span><br><span class="line">                mapp[a[s2]]=s2;</span><br><span class="line">                <span class="built_in">insert</span>(root,a[s]);</span><br><span class="line">                <span class="built_in">insert</span>(root,a[s2]);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(t==<span class="number">-1</span>) &#123;</span><br><span class="line">                <span class="type">int</span> rnk2=<span class="built_in">rnk</span>(root,a[s]),rnk1=rnk2<span class="number">-1</span>;</span><br><span class="line">                <span class="type">int</span> s2=<span class="built_in">find</span>(root,rnk1);</span><br><span class="line">                s2=mapp[s2];</span><br><span class="line">                <span class="built_in">erase</span>(root,a[s]);</span><br><span class="line">                <span class="built_in">erase</span>(root,a[s2]);</span><br><span class="line">                <span class="built_in">swap</span>(a[s],a[s2]);</span><br><span class="line">                mapp[a[s]]=s;</span><br><span class="line">                mapp[a[s2]]=s2;</span><br><span class="line">                <span class="built_in">insert</span>(root,a[s]);</span><br><span class="line">                <span class="built_in">insert</span>(root,a[s2]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果这个吊打了splay ，和fhq-treap差不了多少</p><p>而且似乎比同种思路的treap快了300ms左右</p><h2 id="总结">总结</h2><p>WBLT有着显著的优缺点</p><p>优点是快（ <span class="math inline">\(\text{O}(n\log n)\)</span> 常数较小） 好记 码量小 且能实现很多功能</p><p>缺点是内存空间大，尽管可以用垃圾回收补偿，但是仍然需要两倍的空间</p><p>备注：本文实现方法是单旋，没法证复杂度同时也难以卡掉。2018集训队论文里介绍了双旋的实现，是复杂度正确的。</p>]]></content>
      
      
      <categories>
          
          <category> 算法竞赛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World!</title>
      <link href="/2023/05/08/Hello-World-0/"/>
      <url>/2023/05/08/Hello-World-0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>写博客的习惯从初中打 OI 就开始了，一直懒得自己部署 hexo 甚至懒得搬到 csdn ，于是一直在使用<a href="https://www.luogu.com.cn/blog/codesonic/">洛谷的博客</a>（甚至高数笔记都交到了洛谷博客上）。但是随着退役和对算法竞赛的不断淡出（虽然现在还在 ACM 队里），而写博客记笔记的欲望也没有减退，就找了个中午部署了这个 hexo 博客。以后有空会逐步把原来的博客的文章挑些比较有价值的搬运过来。</p><p>个人比较喜欢写写数学内容，将来也可能写点人工智能相关的笔记，也希望除开日常事务的繁忙，能多学点有趣的内容。当然随笔也是会写的。</p><p>如果想加友链可以联系我。</p><p>马上就要去上课了，写的应该比较凌乱，其他的内容以后再来慢慢完善和维护吧。</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Others </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
