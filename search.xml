<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>口题和随笔。</title>
      <link href="/2023/10/22/%E5%8F%A3%E9%A2%98%E5%92%8C%E9%9A%8F%E7%AC%94%E3%80%82/"/>
      <url>/2023/10/22/%E5%8F%A3%E9%A2%98%E5%92%8C%E9%9A%8F%E7%AC%94%E3%80%82/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>稍微看了看今年CSPS。</p><h3 id="a">A</h3><p>暴力枚举1e5个状态，挨个判断能不能到达每个状态即可。</p><p>如果不能过就枚举第一个状态能到达的所有状态再和后面那 <span class="math inline">\(n-1\)</span> 个判一判</p><p>签完了。</p><h3 id="b">B</h3><p>对于 <span class="math inline">\(n=8000\)</span> 的情况，枚举出发点拿个栈向后扫就行。</p><p>听说现在n方能过八千了。流下了时代的眼泪。</p><p>对于随机的情况，考虑到长度大于十的可消除的串基本不存在。那每次判断长度为十的子串就行了。</p><p>对于全是ab的情况，很显然可以压缩成多个连续段，根据段长度和奇偶性处理。</p><p>如果一个全a段长度为k，反正中间那k-2个肯定是自己和自己消除的。然后就很好处理了。</p><p>其他情况暂时还没想。</p><h3 id="d">D</h3><p>二分答案，然后倒推出每个结点的最晚开始时间。然后贪心判断能不能种完。</p><p>做完了。</p><h3 id="c">C</h3><p>太长还没看。</p><hr /><p>其实到这里也就看了半个小时左右。</p><p>题目质量说不上很高，甚至签到题过于签到，据说还有两个原题。</p><p>但是总体切的很愉快，早生了三年，一辈子从来没切的这么愉快过。</p><p>总比icpc西安好，太难绷了早上那场</p><hr /><p>最近的课业越来越繁重了。甚至本学期没有复习周直接期末考。</p><p>现在已经在逐步开始复习，但是进度仍然很赶，很难受。</p><p>过几天还有icpc南京。</p><p>金工实习还有三天的假要补回来，很急。</p><p>暂且继续前进吧。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>积分变换笔记</title>
      <link href="/2023/09/15/%E7%A7%AF%E5%88%86%E5%8F%98%E6%8D%A2%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/09/15/%E7%A7%AF%E5%88%86%E5%8F%98%E6%8D%A2%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>收藏 https://zhuanlan.zhihu.com/p/108017728</p><p>这里只记录常用傅里叶变换对</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>一些歌单</title>
      <link href="/2023/09/10/%E4%B8%80%E4%BA%9B%E6%AD%8C%E5%8D%95/"/>
      <url>/2023/09/10/%E4%B8%80%E4%BA%9B%E6%AD%8C%E5%8D%95/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>以后每一个月挑五首歌放上来。</p><h3 id="section">2023.10</h3><ol type="1"><li><p>アンノウン・マザーグース - covered by ヰ世界情緒 / ヰ世界情緒</p><blockquote><p>我个人认为的鹅妈妈的最好翻唱。非常贴合原作感情，也非常异世界情绪。</p></blockquote></li><li><p>蜘蛛糸モノポリー /sasakure.UK/初音ミク</p></li><li><p>狂言「九十九星降」 / 凋叶棕</p></li><li><p>张士超你昨天晚上到底把我家钥匙放在哪里了？/上海彩虹室内合唱团</p><blockquote><p>很久以前喜欢的歌。</p><p>合唱带来的和谐和严肃感和歌曲内容带来了非常强烈的反差。</p></blockquote></li><li><p>砂の惑星 feat.米津玄師/ 米津玄師/初音ミク</p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大学物理下笔记</title>
      <link href="/2023/09/09/%E5%A4%A7%E5%AD%A6%E7%89%A9%E7%90%86%E4%B8%8B%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/09/09/%E5%A4%A7%E5%AD%A6%E7%89%A9%E7%90%86%E4%B8%8B%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="电磁学">电磁学</h1><h2 id="章-静电场">14章 静电场</h2><h3 id="库仑定律">库仑定律：</h3><p><span class="math display">\[F=k\frac{q_1q_2}{r^2}e_r\]</span></p><p><span class="math inline">\(e_r\)</span> 是方向向量。通常引入一个常量 $_0 $ 来代替 <span class="math inline">\(k\)</span> ，有<span class="math inline">\(k=\frac{1}{4\pi \varepsilon_0}\)</span>，于是</p><p><span class="math display">\[F=\frac{1}{4\pi\varepsilon_0}\frac{q_1q_2}{r^2}\]</span></p><h3 id="电场">电场</h3><ul><li>电场强度的原始定义：<span class="math inline">\(E=\frac{F}{q_0}\)</span>，场强有方向。</li><li>场强可以按照向量相加的方式叠加。</li><li>点电荷的场强：<span class="math inline">\(E=\frac{q}{4\pi \varepsilon_0r^2}\)</span></li><li>由叠加原理，对带电体的场强计算即为上式的积分。</li><li>为了方便积分，引入电荷体密度 <span class="math inline">\(\rho=\frac{\mathrm{d}q}{\mathrm{d}V}\)</span> ，对于均匀带电体，显然有 <span class="math inline">\(\rho=\frac{q}{V}\)</span>，对于带电面和带电细线，定义是类似的。</li></ul><p>一些经典结论：</p><ul><li>无限长的均匀带电细棒的电场大小：<span class="math inline">\(E=\frac{\lambda}{2\pi\epsilon_0a}\)</span>，<span class="math inline">\(\lambda\)</span> 为电荷线密度</li><li>无限大均匀带电平板：<span class="math inline">\(E=\frac{\sigma}{2\epsilon_0}\)</span>，<span class="math inline">\(\sigma\)</span> 为电荷面密度</li><li>均匀带电圆环轴线场强：<span class="math inline">\(E=\frac{1}{4\pi \varepsilon_0}\frac{Qx}{(x^2+R^2)^{3/2}}\)</span></li><li></li></ul><p>带电粒子在电场中受到的电场力也可以积分得到，即 <span class="math inline">\(\int E\mathrm{d}q\)</span></p><h3 id="电场强度通量与高斯定理">电场强度通量与高斯定理</h3><p>电场强度通量可以表示为<span class="math inline">\(\Phi_e=\int E \cdot \mathrm{d}S\)</span></p><p>用类似高数下的方式可以证明通过一个闭合曲面的电场强度通量满足：</p><p><span class="math display">\[\Phi_e=\oint E \cdot \mathrm{d}S=\frac{q}{\varepsilon_0}\]</span></p><p>（其中，<span class="math inline">\(q\)</span> 为闭合曲面内的电荷量。）</p><p>此即<strong>高斯定理</strong>。</p><p>由高斯定理，如果通过一个曲面的电场强度均匀，那么就可以由 <span class="math inline">\(q\)</span> 和曲面面积 <span class="math inline">\(S\)</span> 求出该面上每一点的电场强度。</p><p>通过构造这一曲面，有时可以方便计算电场强度。</p><h3 id="电势">电势</h3><p>静电场是保守力场，因此可以引入静电势能 <span class="math inline">\(W\)</span>。即要求：</p><p><span class="math display">\[W_a-W_b=\int_a^bq_0E\cdot \mathrm{d}l\]</span></p><p>电势即：</p><p><span class="math inline">\(U_a=\frac{W_a}{q_0}=\int_a^{\text{电势零点}}E\cdot \mathrm{d} l\)</span></p><p>经常选择无穷远处为电势零点。</p><p>由于电场强度是可以叠加的，多个点同时作用于一个点的电势同理也是多个点各自对一个点电势的代数和。</p><p>需要注意的是，电场强度有方向和电势没有方向。</p><p>点电荷的电势：</p><p><span class="math display">\[U_p={\frac{q}{4\pi\varepsilon_0r}}(r\not = 0)\]</span></p><p>通过积分，可以求出半径为 <span class="math inline">\(R\)</span> 的均匀带电球面的空间电势：</p><p><span class="math display">\[U=\frac{q}{4\pi \varepsilon_0R}(r\leq R)\]</span></p><p><span class="math display">\[U=\frac{q}{4\pi \varepsilon_0r}(r\geq R)\]</span></p><p>注意到，场强是电势的微分，电势是场强的积分。因此有：</p><p><span class="math display">\[E_x=-\frac{\partial U}{\partial x},E_y=-\frac{\partial U}{\partial y},E_z=-\frac{\partial U}{\partial z}\]</span></p><p>在这里，<span class="math inline">\(U\)</span> 被视为关于 <span class="math inline">\(x,y,z\)</span> 的三元函数。</p><p>一些其他结论：</p><ul><li>电场强度方向（电场线）和等势面处处正交。</li><li>沿等势面移动，电场力做功为0。</li><li>带电粒子移动一个闭合路径，电场力做功之和为0.</li><li>等势面密集处电场线密集。</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>邱关源电路复习简要笔记</title>
      <link href="/2023/06/21/%E9%82%B1%E5%85%B3%E6%BA%90%E7%94%B5%E8%B7%AF%E5%A4%8D%E4%B9%A0%E7%AE%80%E8%A6%81%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/06/21/%E9%82%B1%E5%85%B3%E6%BA%90%E7%94%B5%E8%B7%AF%E5%A4%8D%E4%B9%A0%E7%AE%80%E8%A6%81%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><span class="math inline">\(Y\)</span> 形连接和 <span class="math inline">\(\Delta\)</span> 形连接的等效变换</p><p><span class="math display">\[R_Y=\frac{\Delta \text{相邻电阻乘积}}{\sum R_\Delta} \]</span></p><p><span class="math display">\[G_\Delta = \frac{Y\text{相邻电导乘积}}{\sum G_Y}\]</span></p><p>三个电阻相等，有 <span class="math inline">\(R\Delta =3R_Y\)</span></p><p>戴维宁定理：开路电压，短路电流计算等效电阻</p><p>叠加定理计算时：电流源短路电压源开路</p><p>电感：<span class="math inline">\(i=C\frac{\mathrm{d}u}{\mathrm{d}t}\)</span></p><p>电感：<span class="math inline">\(u=L\frac{\mathrm{d}i}{\mathrm{d}t}\)</span></p><p>换路定则。</p><p>最大功率传输定理</p><p>负载可以任意变化：</p><p>当求负载 <span class="math inline">\(Z_L\)</span> 的最大功率时，现将负载之外的电路用戴维宁等效电路替换为 <span class="math inline">\(&lt;U_S,Z_S&gt;\)</span></p><p>此时有 <span class="math inline">\(Z_S=\overline{Z_C}\)</span> 时负载获得功率最大。</p><p>耦合电感串联：</p><p>顺接串联：<span class="math inline">\(L_{eq}=L_1+L_2+2M\)</span></p><p>反接串联：<span class="math inline">\(L_{eq}=L_1+L_2-2M\)</span></p><p>耦合电感并联：</p><p>同侧并联：同名端连接在同一个节点上：</p><p>可解得 <span class="math inline">\(L_{eq}=\frac{(L_1L_2-M^2)}{L_1+L_2-2M}\)</span></p><p>异侧并联：异名端连接在同一个节点上：</p><p>可解得 <span class="math inline">\(L_{eq}=\frac{(L_1L_2-M^2)}{L_1+L_2+2M}\)</span></p><p>并联电感注意去耦合后两点电压位置会发生移动。</p><p>复功率：<span class="math inline">\(W=U\overline I\)</span></p><p>耦合因数：<span class="math inline">\(k=\frac{M}{\sqrt{L_1L_2}}\)</span></p><p>理想变压器 （输入：输出= <span class="math inline">\(n:1\)</span> ） 输出端接阻抗 <span class="math inline">\(Z_L\)</span> 时，其输入端等效阻抗为 <span class="math inline">\(n^2Z_L\)</span></p><hr /><p>三相电压 <span class="math inline">\(U_A,U_B,U_C\)</span></p><p>（<span class="math inline">\(U_C\)</span> 超前 <span class="math inline">\(U_A\rightarrow\)</span> 正序，对称三相电路）假设 <span class="math inline">\(\dot{U}_A=U_A\angle 0^{\circ},U_A=U_B=U_C,\dot{U}_B=\dot{U}_A\angle -120^{\circ},\dot{U}_C=\dot{U}_A\angle 120^{\circ}\)</span></p><p>电源侧，电流测三角形连接和星（Y）形连接</p><p><img src="D:\Blog\source_posts\邱关源电路复习简要笔记\星形和三角形.jpg" /></p><p>二、<span class="math inline">\(Y-Y\)</span> 三相四线制</p><p><img src="D:\Blog\source_posts\邱关源电路复习简要笔记\三相四线制.jpg" /></p><p>相：一定通过某一个电源或负载</p><p>线电压：两根导线之间的电压；线电流：经过导线的电流</p><table><colgroup><col style="width: 7%" /><col style="width: 46%" /><col style="width: 46%" /></colgroup><thead><tr class="header"><th style="text-align: center;"></th><th style="text-align: center;">电源侧</th><th style="text-align: center;">负载侧</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">相电压</td><td style="text-align: center;"><span class="math inline">\(\dot{U}_A,\dot{U}_B,\dot{U}_C\)</span></td><td style="text-align: center;"><span class="math inline">\(\dot{U}_A&#39;,\dot{U}_B&#39;,\dot{U}_C&#39;\)</span></td></tr><tr class="even"><td style="text-align: center;">相电流</td><td style="text-align: center;"><span class="math inline">\(\dot{I}_A,\dot{I}_B,\dot{I}_C\)</span></td><td style="text-align: center;"><span class="math inline">\(\dot{I}_A,\dot{I}_B,\dot{I}_C\)</span></td></tr><tr class="odd"><td style="text-align: center;">线电压</td><td style="text-align: center;"><span class="math inline">\(\dot{U}_{AB},\dot{U}_{BC},\dot{U}_{CA}\)</span></td><td style="text-align: center;"><span class="math inline">\(\dot{U}_{AB},\dot{U}_{BC},\dot{U}_{CA}\)</span></td></tr><tr class="even"><td style="text-align: center;">线电流</td><td style="text-align: center;"><span class="math inline">\(\dot{I}_A,\dot{I}_B,\dot{I}_C\)</span></td><td style="text-align: center;"><span class="math inline">\(\dot{I}_A,\dot{I}_B,\dot{I}_C\)</span></td></tr></tbody></table><p>判断四个量的关系一定要在同一侧</p><p><img src="D:\Blog\source_posts\邱关源电路复习简要笔记\相电压与线电压的关系.jpg" /></p><p>在本回路中，<span class="math inline">\(\dot{U}_A=\dot{U}_A&#39;,\dot{U}_B=\dot{U}_B&#39;,\dot{U}_C=\dot{U}_C&#39;\)</span>，故也满足上式</p><p>相电流与线电流关系显然。</p><p>三、 $Y-$ 连接</p><p><img src="D:\Blog\source_posts\邱关源电路复习简要笔记\星形接三角形.jpg" /></p><table><colgroup><col style="width: 7%" /><col style="width: 46%" /><col style="width: 46%" /></colgroup><thead><tr class="header"><th style="text-align: center;"></th><th style="text-align: center;">电源侧</th><th style="text-align: center;">负载侧</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">相电压</td><td style="text-align: center;"><span class="math inline">\(\dot{U}_A,\dot{U}_B,\dot{U}_C\)</span></td><td style="text-align: center;"><span class="math inline">\(\dot{U}_{AB},\dot{U}_{BC},\dot{U}_{CA}\)</span></td></tr><tr class="even"><td style="text-align: center;">相电流</td><td style="text-align: center;"><span class="math inline">\(\dot{I}_A,\dot{I}_B,\dot{I}_C\)</span></td><td style="text-align: center;"><span class="math inline">\(\dot{I}_{AB},\dot{I}_{BC},\dot{I}_{CA}\)</span></td></tr><tr class="odd"><td style="text-align: center;">线电压</td><td style="text-align: center;"><span class="math inline">\(\dot{U}_{AB},\dot{U}_{BC},\dot{U}_{CA}\)</span></td><td style="text-align: center;"><span class="math inline">\(\dot{U}_{AB},\dot{U}_{BC},\dot{U}_{CA}\)</span></td></tr><tr class="even"><td style="text-align: center;">线电流</td><td style="text-align: center;"><span class="math inline">\(\dot{I}_A,\dot{I}_B,\dot{I}_C\)</span></td><td style="text-align: center;"><span class="math inline">\(\dot{I}_A,\dot{I}_B,\dot{I}_C\)</span></td></tr></tbody></table><p>电源侧四个量关系显然与之前一致，主要考虑负载侧</p><p>负载侧：</p><p>线电压=相电压</p><p><span class="math display">\[\dot{I}_{AB}=\frac{\dot{U}_{AB}}{Z},\dot{I}_{BC}=\frac{\dot{U}_{BC}}{Z},\dot{I}_{CA}=\frac{\dot{U}_{CA}}{Z}\]</span> <span class="math inline">\(I_A=I_{AB}-I_{CA},I_B=I_{BC}-I_{AB},I_C=I_{CA}-I_{BC}\)</span></p><p><span class="math inline">\(I_{AB}=\frac{U_{AB}}{Z},I_{BC}=\frac{U_{BC}}{Z},I_{CA}=\frac{U_{CA}}{Z}\)</span></p><p><img src="D:\Blog\source_posts\邱关源电路复习简要笔记\相电流与电流的关系.jpg" /></p><p>处理问题时，先把电源、负载化为星形连接</p><p><span class="math inline">\(U_A&#39;=\frac{1}{\sqrt{3}}U_A\angle -30^{\circ}\)</span></p><p><img src="D:\Blog\source_posts\邱关源电路复习简要笔记\负载的转换.png" /></p><p>对称三相四线制电路，中性线上电流为0</p><p>故每条线左右等电势，故有 <span class="math inline">\(I_A=\frac{U_A}{Z_A}\)</span></p><p>Y-Y：<span class="math inline">\(p=3\dot{U}_A\dot{I}_A=\sqrt{3}U_{AB}I_A\)</span></p>]]></content>
      
      
      <categories>
          
          <category> 课程笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>大学物理上-公式整理</title>
      <link href="/2023/06/16/%E5%A4%A7%E5%AD%A6%E7%89%A9%E7%90%86%E4%B8%8A-%E5%85%AC%E5%BC%8F%E6%95%B4%E7%90%86/"/>
      <url>/2023/06/16/%E5%A4%A7%E5%AD%A6%E7%89%A9%E7%90%86%E4%B8%8A-%E5%85%AC%E5%BC%8F%E6%95%B4%E7%90%86/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="经典力学">经典力学</h1><p>质点运动学略</p><p>牛顿运动定律略</p><p><span class="math inline">\(x_c=\int_{\text{物体}}\frac{x\mathrm d m}{m}\)</span></p><h2 id="动量冲量和相关定理">动量，冲量和相关定理</h2><p><span class="math inline">\(\vec p=m\vec v, \vec I =\int_{t_1}^{t_2}\vec F \mathrm{d}t,\vec F=\frac{\mathrm{d}p}{\mathrm{d}t},\int_{t_1}^{t_2}\vec F\mathrm{d}t=\vec {p_2}-\vec{p_1}\)</span></p><h3 id="动量守恒定律">动量守恒定律</h3><p><span class="math inline">\(\vec F=0\)</span> 时，<span class="math inline">\(\vec P\)</span> 为常矢量</p><p><span class="math inline">\(\vec {F_{n}}=0\)</span> 时，<span class="math inline">\(P_n\)</span> 为常量</p><h3 id="角动量">角动量</h3><p>角动量 <span class="math inline">\(\vec L=\vec r\times m\vec v\)</span>，注意是叉乘</p><p>力矩：<span class="math inline">\(\vec M=\vec r \times \vec F\)</span></p><p>注意前者 <span class="math inline">\(\vec r\)</span> 是质点关于参考点的位矢，后者是力作用点关于参考点的位矢</p><ul><li><p>角动量定理</p><p><span class="math inline">\(\vec M=\frac{\mathrm{d}\vec L}{\mathrm{d}t}\)</span></p><p><span class="math inline">\(\int _{t_1}^{t_2}\vec M\mathrm{d}t=\vec{L_2}-\vec{L_2}\)</span></p><p>若 <span class="math inline">\(\vec M=0\)</span>，则 <span class="math inline">\(\vec L\)</span> 为常矢量，即角动量守恒</p></li></ul><h3 id="能">能</h3><p>保守力：<span class="math inline">\(\oint_L \vec{F}=0,E_P=\int^{\text{零势能点}}_a\vec{ F_{\text{保}}}\mathrm{d}r\)</span></p><p>重力势能：<span class="math inline">\(E_p=mgz\)</span>，引力势能：<span class="math inline">\(E_p=-\frac{GMm}{r}\)</span>，弹性势能：<span class="math inline">\(E_p=\frac{1}{2}kx^2\)</span></p><p>机械能 <span class="math inline">\(E=E_k+E_p\)</span>.. 外力和非保守内力做功为 <span class="math inline">\(0\)</span> 则 <span class="math inline">\(E\)</span> 保持不变</p><p>碰撞：动量守恒，完全弹性则机械能也守恒</p><h3 id="刚体运动">刚体运动</h3><p>转动惯量 <span class="math inline">\(J=\int_{\text{物体}}r_i^2\mathrm{d}m\)</span></p><p>杆：<span class="math inline">\(J=\frac{1}{12}ml^2,J=\frac{1}{3}ml^2\)</span>（轴中间，一端）</p><p>圆环：<span class="math inline">\(J=mR^2\)</span>，圆盘：<span class="math inline">\(J=\frac{1}{2}mR^2\)</span></p><p>角动量 <span class="math inline">\(\vec L=J\omega\)</span>，外力对轴力矩 <span class="math inline">\(\vec M=\vec r \times \vec F_{\perp z}\)</span>，注意是叉乘，结果与轴平行。</p><p><span class="math inline">\(\vec M=J\vec \alpha\)</span>. 逆时针为正。</p><p><span class="math inline">\(\frac{\mathrm{d}L}{\mathrm{d}t}=M,\int_{t_1}^{t_2}M\mathrm{d}t=L_2-L_1\)</span></p><p><span class="math inline">\(M=0,L_1=L_2,J_1\omega_1=J_2\omega_2\)</span></p><h3 id="力矩做功转动动能">力矩做功转动动能</h3><p><span class="math inline">\(A=\int_{\theta_1}^{\theta_2}M\mathrm{d}\theta,E_k=\frac{1}{2}J\omega^2\)</span></p><p><span class="math inline">\(\int_{\theta_1}^{\theta_2}M\mathrm{d}\theta=E_{k2}-E_{k1}\)</span></p><h1 id="振动与波动学">振动与波动学</h1><h2 id="振动">振动</h2><h3 id="简谐振动">简谐振动</h3><p><span class="math inline">\(A\cos (\omega t+\varphi)\)</span></p><p>振动频率 <span class="math inline">\(v=\frac{2\pi}{\omega}\)</span> 与振动周期有 <span class="math inline">\(v=\frac{1}{T}\)</span></p><p>通过求导得到简谐振动的速度和加速度。</p><ul><li><p>弹簧-物块振动方程</p><p><span class="math inline">\(-kx=m\frac{\mathrm{d}^2x}{\mathrm{d}t^2}\)</span></p><p>故有微分方程 <span class="math inline">\(\frac{\mathrm{d}^2x}{\mathrm{d}t^2}+\frac{k}{m}x=0\)</span></p><p>解得 <span class="math inline">\(x=A\cos (\sqrt{\frac{k}{m}} t+\varphi)\)</span></p><p>故 <span class="math inline">\(\omega=\sqrt{\frac{k}{m}},T=2\pi\sqrt{\frac{m}{k}}\)</span></p><hr /><p><span class="math inline">\(x=A\cos(\omega t+\varphi ),\omega=\sqrt{\frac{k}{m}},A=\sqrt{x_0^2+\frac{v_0^2}{\omega^2}}\)</span></p><p>再根据题意解出 <span class="math inline">\(\varphi\)</span></p></li><li><p>简谐振动的能量</p><p>动能表达式：<span class="math inline">\(E_k=\frac{1}{2}mv^2=\frac{1}{2}kA^2\sin^2(\omega t+\varphi)\)</span></p><p>势能表达式：<span class="math inline">\(E_p=\frac{1}{2}kx^2=\frac{1}{2}kA^2\cos^2(\omega t+\varphi)\)</span></p><p><span class="math inline">\(\overline{E_k}=\overline{E_p}=\frac{1}{4}kA^2,E=\frac{1}{2}kA^2=\frac{1}{2}m\omega^2\)</span></p></li></ul><h3 id="旋转矢量法">旋转矢量法</h3><p>略</p><h3 id="同方向同频率简谐振动的合成">同方向同频率简谐振动的合成</h3><p><span class="math inline">\(A=\sqrt{A_1^2+A_2^2+2A_1A_2\cos(\varphi_1-\varphi_2)},\tan \varphi=\frac{A_1\sin \varphi_1+A_2\sin \varphi_2}{A_1\cos \varphi_1+A_2\cos \varphi_2}\)</span></p><p>用解析法和旋转矢量法（平行四边形法则）都可以导出该结果。</p><h2 id="波动">波动</h2><p><span class="math inline">\(A\)</span>：波源振幅，<span class="math inline">\(\varphi\)</span>：波源初相位</p><p>T：波源振动周期，<span class="math inline">\(f\)</span>：波源振动频率，<span class="math inline">\(\omega\)</span>：波源振动角频率</p><p><span class="math inline">\(u\)</span>：波速，<span class="math inline">\(\lambda\)</span>：波长</p><p><span class="math inline">\(T=\frac{2\pi}{\omega}=\frac{1}{f},\omega=2\pi f,u=\frac{\lambda}{T}=\lambda f\)</span></p><h3 id="波函数">波函数</h3><p><span class="math inline">\(y(x,t)=A\cos[\omega (t\mp \frac{x}{u})+\varphi]\)</span></p><h3 id="机械波和电磁波">机械波和电磁波</h3><p>机械波的传播需要介质（纵波：固液气；横波：固），电磁波不需要</p><p>波从一种介质进入另一种介质时，频率，周期不变，波速改变，波长改变</p><p>要注意到光的颜色由频率决定而非波长决定，因此光的颜色不会改变。</p><h3 id="波的叠加和干涉">波的叠加和干涉</h3><p>设两波初相位 <span class="math inline">\(\varphi_1,\varphi_2\)</span>，距离 <span class="math inline">\(P\)</span> 点 <span class="math inline">\(r_1,r_2\)</span> ，则有</p><p>相位差：<span class="math inline">\(\Delta \varphi =\varphi_1-\varphi_2-\omega(\frac{r_2-r_1}{u})\)</span></p><p>波程差：<span class="math inline">\(\delta=r_2-r_1-\lambda\frac{\varphi_2-\varphi_1}{2\pi}\)</span></p><p><span class="math inline">\(\Delta \varphi =\pm 2k\pi\)</span> 或 <span class="math inline">\(\delta=\pm k\lambda\)</span> 时，干涉加强</p><p><span class="math inline">\(\Delta \varphi =\pm (2k+1)\pi\)</span> 或 <span class="math inline">\(\delta=\pm \frac{2k+1}{2}\lambda\)</span> 时，干涉减弱</p><h3 id="半波损失">半波损失</h3><p>在固定端反射（或从波疏介质射向波密介质）会产生半波损失</p><p>入射波： <span class="math inline">\(y(x,t)=A\cos[w(t-\frac{x}{u})]\)</span></p><p>反射波：<span class="math inline">\(y(x,t)=Acos[w(t+\frac{x}{u})-\pi]\)</span></p><p>由于半波损失的存在，驻波的固定端产生波节而非波腹。</p><p>已知入射波求反射波时，先确定入射波在反射点的函数，再考虑半波损失后令其传播方向相反即可。</p><h3 id="驻波">驻波</h3><p>驻波的点与点没有能量的传播</p><h3 id="多普勒效应">多普勒效应</h3><p><span class="math inline">\(f_R=\frac{u+v_R}{u-v_S}f_S\)</span>，<span class="math inline">\(v_R\)</span> 是观察者接近波源速度，<span class="math inline">\(v_S\)</span> 是波源接近速度。</p><h1 id="光学">光学</h1><h2 id="双缝干涉">双缝干涉</h2><p>干涉相长：<span class="math inline">\(\frac{d}{D}x=\pm k\lambda\)</span></p><p>干涉相消：<span class="math inline">\(\frac{d}{D}x=\pm(2k+1)\frac{\lambda}{2}\)</span></p><p><span class="math inline">\(d\)</span> 双缝间距，<span class="math inline">\(D\)</span> 板间距离，<span class="math inline">\(x\)</span> 与板中心距离</p><h3 id="明暗纹中心光强">明暗纹中心光强</h3><p><span class="math inline">\(I_1+I_2\pm \sqrt{I_1I_2}\)</span></p><h3 id="光程">光程</h3><p><span class="math inline">\(\text{相位差}=\frac{2\pi}{\lambda}\text{光程差}\)</span></p><p>记为 <span class="math inline">\(\Delta \varphi=\frac{2\pi}{\lambda}\delta\)</span></p><p>当 <span class="math inline">\(\Delta \varphi=\pm 2k\pi\)</span> 时，相长；当 <span class="math inline">\(\Delta \varphi=\pm (2k+1)\pi\)</span> 时，相消；</p><p>或 $=k $ 时，相长；当 <span class="math inline">\(\delta =(2k+1)\frac{\lambda}{2}\)</span>时，相消；</p><h3 id="薄膜干涉">薄膜干涉</h3><p>折射率 <span class="math inline">\(n_1&lt;n_2\)</span> ，1 射入 2 反射时有半波损失</p><p>当 <span class="math inline">\(n_1&lt;n_2&gt;n_3\)</span> 或 <span class="math inline">\(n_1&gt;n_2&lt;n_3\)</span> 时，薄膜干涉有半波损失</p><p>光程差：<span class="math inline">\(\delta=2n_2d\cos r+\frac{\lambda}{2}\)</span>，这里 <span class="math inline">\(r\)</span> 是折射光与垂直方向的夹角</p><p><span class="math inline">\(n_2\cos r=\sqrt{n_2^2-n_2^2\sin^2r}=\sqrt{n_2^2-n_1^2\sin^2i}\)</span>，这里 <span class="math inline">\(i\)</span> 是入射光和垂直方向</p><p>那么 <span class="math inline">\(2d\sqrt{n_2^2-n_1^2\sin^2i}+\frac{\lambda}{2}=k\lambda\)</span> 时，相长；<span class="math inline">\(=(2k+1)\frac{\lambda}{2}\)</span> ，相消</p><h3 id="劈尖">劈尖</h3><p>通常情况下上式 <span class="math inline">\(\sin i=0\)</span> ，故有 <span class="math inline">\(2nd+\frac{\lambda}{2}=k\lambda\)</span> 时相长</p><p><span class="math inline">\(d=\frac{2k-1}{4n}\lambda\)</span> 时明纹；<span class="math inline">\(d=\frac{k}{2n}\lambda\)</span> 时暗纹。（空气折射率 <span class="math inline">\(n=1\)</span> ）</p><p>故相邻两条明或暗纹之间劈尖空气膜厚度相差 $ $</p><p>条纹间距即为 <span class="math inline">\(l=\frac{\lambda}{2n\sin \alpha}=\frac{\lambda}{2n\alpha}\)</span></p><p>干涉条纹向劈尖尖处弯曲，则说明对应点空气膜变厚，故下凹。反之亦然。</p><h3 id="牛顿环">牛顿环</h3><p>类似地，<span class="math inline">\(d=\frac{2k-1}{4}\lambda\)</span> 时明纹；<span class="math inline">\(d=\frac{k}{2}\lambda\)</span> 时暗纹。</p><p>有 <span class="math inline">\(d=\frac{r^2}{2R}\)</span></p><p>故有 <span class="math inline">\(r=\sqrt{\frac{(2k-1)R\lambda}{2}}\)</span> 明纹； <span class="math inline">\(r=\sqrt{kR\lambda}\)</span> 暗纹。</p><p>纹间距內疏外密。</p><h3 id="增透膜增反膜">增透膜，增反膜</h3><p>选取薄膜厚度 <span class="math inline">\(d\)</span> 使得 <span class="math inline">\(2n_2d=(2k+1)\frac{\lambda}{2}\)</span> 干涉相消，从而增强透射光。</p><p>最薄增透膜即为 <span class="math inline">\(d=\frac{4n_2}{\lambda}\)</span></p><p>一般通过多层反射膜增反，使得大部分光被反射。</p><h2 id="单缝夫琅禾费衍射">单缝（夫琅禾费）衍射</h2><h3 id="明暗纹位置">明暗纹位置</h3><p>明纹 ：<span class="math inline">\(\delta =a\sin \theta =\pm (2k+1)\frac{\lambda}{2}\)</span></p><p>暗纹 ：<span class="math inline">\(\delta =a\sin \theta =\pm k\lambda\)</span></p><p>（ <span class="math inline">\(\sin \theta\)</span> 在较小时也可以用 <span class="math inline">\(\frac{x}{f}\)</span> ，焦距与偏离平板中心的距离之比得到）</p><h3 id="中央明纹宽度">中央明纹宽度</h3><p><span class="math inline">\(l=2f\frac{\lambda}{a}\)</span></p><h3 id="半波带数">半波带数</h3><p>明纹：<span class="math inline">\(2k+1\)</span></p><p>暗纹：<span class="math inline">\(2k\)</span></p><h2 id="光栅衍射">光栅衍射</h2><p>主极大：<span class="math inline">\((a+b)\sin \theta=k\lambda\)</span></p><p>若入射光源照射光栅时不垂直，且与垂直方向夹角为 <span class="math inline">\(\varphi\)</span>，则主极大：<span class="math inline">\((a+b)\sin \theta\cos \varphi=k\lambda\)</span></p><p>缺级：<span class="math inline">\(k=\frac{a+b}{a}k&#39;\)</span></p><p>距离中央明纹距离： <span class="math inline">\(f\tan \theta\)</span>，$$ 较小时，<span class="math inline">\(f\theta\)</span></p><h2 id="光的偏振">光的偏振</h2><p>线偏振光</p><p>偏振度 <span class="math inline">\(P=\frac{I_{max}-I_{min}}{I_{max}+I_{min}}\)</span></p><p>顺时针右旋逆时针左旋，吗</p><p>偏振片：<span class="math inline">\(I=I_0\cos^2\alpha\)</span></p><h3 id="布儒斯特定律">布儒斯特定律</h3><p><span class="math inline">\(\tan i_0=\frac{n_2}{n_1}=n_{21}\)</span>（1射入2）</p><p>此时 <span class="math inline">\(i_0+r=\frac{\pi}{2}\)</span>，且反射光为完全偏振光</p><p>可以通过叠加多块玻璃片使得射出的折射光几乎变为完全偏振光。</p><h1 id="热学">热学</h1><p>考纲喵：理想气体的状态方程；理想气体的温度、压强、内能；能均分定理；麦克斯韦速率分布函数的意义和三种统计速率；热力学第一定律在理想气体准静态等值过程（等体、等压、等温）中的应用；热容；定性理解绝热过程；循环过程及热机效率、卡诺循环；热力学第二定律的定性理解及克劳修斯熵的计算。不考气体分子的平均自由程。</p><h2 id="理想气体">理想气体</h2><h3 id="理想气体的状态方程">理想气体的状态方程</h3><p><span class="math display">\[pV=vRT\]</span></p><p><span class="math display">\[v=\frac{m&#39;}{M},\text{用摩尔质量计算的摩尔数};R=\frac{p_0v_0}{T_0},\text{普适气体恒量，8.31(4)}\]</span></p><p><span class="math display">\[p=nkT\]</span></p><p><span class="math display">\[n=N/V,\text{分子数密度};k,\text{玻尔兹曼常数}1.380649 ×\times 10^{-23} J/K\text{，满足}R=kN_A\]</span></p><h3 id="理想气体的温度压强内能">理想气体的温度、压强、内能</h3><p>压强公式</p><p><span class="math display">\[p=\frac{1}{3}nm\overline {v^2} =\frac{2}{3}n\overline\omega,\overline \omega \text{是平均动能}\]</span></p><p>温度公式</p><p><span class="math display">\[\overline \omega =\frac{3}{2}kT\]</span></p><p>内能公式</p><p><span class="math display">\[U=\frac{m&#39;}{M}\frac{i}{2}RT=\frac{i}{2}vRT=\frac{i}{2}pV\]</span></p><h3 id="麦克斯韦速率分布函数的意义和三种统计速率">麦克斯韦速率分布函数的意义和三种统计速率</h3><p><span class="math display">\[f(v)=4\pi (\frac{m}{2\pi kT})^{\frac{3}{2}}v^2e^{\frac{-mv^2}{2kT}}\]</span></p><p>（<span class="math inline">\(m\)</span> 越小或 <span class="math inline">\(T\)</span> 越大时速率分布函数更向左挤）</p><ul><li>最概然速率</li></ul><p><span class="math display">\[v_p=\sqrt{\frac{2kT}{m}}=\sqrt{\frac{2RT}{M}}\approx 1.41\sqrt{\frac{RT}{M}}\]</span></p><p><span class="math display">\[m,\text{分子质量};M,\text{摩尔质量}\]</span></p><ul><li>平均速率</li></ul><p><span class="math display">\[\overline v=\sqrt{\frac{8kT}{\pi m}}=\sqrt{\frac{8RT}{\pi M}}\approx 1.60\sqrt{\frac{RT}{M}}\]</span></p><ul><li>方均根速率</li></ul><p><span class="math display">\[\sqrt{\overline {v^2}}=\sqrt{\frac{3kT}{m}}=\sqrt{\frac{3RT}{M}}\approx 1.73\sqrt{\frac{RT}{M}}\]</span></p><p><del>分子平均碰撞次数</del></p><p><del><span class="math inline">\(\overline Z=\sqrt{2}\pi d^2\overline vn\)</span></del></p><p><del>平均自由程</del></p><p><del><span class="math inline">\(\overline \lambda =\frac{\overline v}{\overline Z}=\frac{1}{\sqrt{2}\pi d^2n}=\frac{kT}{\sqrt{2}\pi d^2p}\)</span></del></p><h2 id="热力学第一定律">热力学第一定律</h2><p><span class="math display">\[ W= \int_{V_1}^{V_2}p\mathrm{d}V,\text{即所谓做功为曲线与 p-V 图 x 轴围成面积}\]</span></p><p><span class="math display">\[Q=\Delta E+W,\text{吸收热量等于内能增加量加对外做功}\]</span></p><h3 id="等容摩尔热容量">等容摩尔热容量</h3><p><span class="math display">\[\mathrm{d}E=\frac{i}{2}R\mathrm{d}T\]</span></p><p><span class="math display">\[C_v=\frac{i}{2}R\]</span></p><h3 id="等压摩尔热容量">等压摩尔热容量</h3><p>比起等容摩尔热容量，还需要对外做功。</p><p><span class="math display">\[(v=1),C_p=\frac{\mathrm{d}Q_p}{\mathrm{d}T}=\frac{\mathrm{d}E+p\mathrm{d}V}{\mathrm{d}T}=\frac{\frac{i}{2}R\mathrm{d}T+R\mathrm{d}T}{\mathrm{d}T}=\frac{i}{2}R\mathrm{d}T+R=C_v+R\]</span></p><h3 id="利用热容计算吸热放热量">利用热容计算吸热放热量</h3><p><span class="math display">\[Q=vC_v(T_2-T_1)\text{（等容）}\]</span></p><p><span class="math display">\[Q=vC_p(T_2-T_1)\text{（等压）}\]</span></p><h3 id="比热容比-gamma">比热容比 <span class="math inline">\(\gamma\)</span></h3><p><span class="math display">\[\gamma=\frac{C_p}{C_V}=\frac{i+2}{i}\]</span></p><p>通式</p><p><span class="math display">\[Q=\Delta E +W\]</span></p><p><span class="math display">\[W=\int_{V_1}^{V_2}p\mathrm{d}V=\int_{V_1}^{V_2}p_1V_1^{\gamma}\frac{\mathrm{d}V}{V^{\gamma}}\]</span></p><p><span class="math display">\[\Delta E=\frac{m&#39;}{M}\frac{i}{2}R\Delta T\]</span></p><p>绝热过程 <span class="math inline">\(p-V\)</span> 方程</p><p><span class="math display">\[pV^\gamma=C\]</span></p><p>由 <span class="math inline">\(pV=vRT=C_1T\)</span>，</p><p><span class="math display">\[TV^{\gamma-1}=C\]</span></p><p><span class="math display">\[p^{\gamma-1}T^{-\gamma}=C\]</span></p><p>（绝热线比等温线陡）</p><p><span class="math display">\[W=\int_{V_1}^{V_2}p\mathrm{d}V=\int_{V_1}^{V_2}p_1V_1^{\gamma}\frac{\mathrm{d}V}{V^{\gamma}}=-\Delta E\]</span></p><p>等温过程：</p><p><span class="math display">\[W=\int_{V_1}^{V_2}p\mathrm{d}V=vRT\ln(\frac{V_2}{V_1})\]</span></p><h3 id="热机效率">热机效率</h3><p><span class="math display">\[\eta = \frac{W}{Q_1}=\frac{Q_1-Q_2}{Q_1}=1-\frac{Q_2}{Q_1},\text{Q1Q2表示从高温热源吸热，向低温热源放热}\]</span></p><p>若为卡诺热机，还有</p><p><span class="math display">\[\eta = \frac{W}{Q_1}=\frac{Q_1-Q_2}{Q_1}=1-\frac{Q_2}{Q_1}=1-\frac{T_2}{T_1},\text{Q1Q2表示从高温热源吸热，向低温热源放热}\]</span></p><h3 id="制冷机制冷系数">制冷机制冷系数</h3><p><span class="math display">\[e=\frac{Q_2}{W}=\frac{Q_2}{Q_1-Q_2}\text{（Q1Q2，向高温热源放热，从低温热源吸热）W:工件对外界做功}\]</span></p><p>若为卡诺制冷机，还有</p><p><span class="math display">\[e=\frac{Q_2}{W}=\frac{Q_2}{Q_1-Q_2}=\frac{T_2}{T_1-T_2}\]</span></p><h2 id="热力学第二定理">热力学第二定理</h2><h3 id="克劳修斯熵公式对单个系统">克劳修斯熵公式（对单个系统）：</h3><p><span class="math display">\[\Delta S=S_B-S_A=\int_A^B\frac{\mathrm{d}Q}{T}\]</span></p><h3 id="热传导中的熵变从高温热源-a-传向低温热源-b">热传导中的熵变（从高温热源 A 传向低温热源 B ）：</h3><p><span class="math display">\[\mathrm{d}S_A=\frac{-\mathrm{d}Q}{T_A},\mathrm{d}S_B=\frac{\mathrm{d}Q}{T_B}\]</span></p><p><span class="math display">\[\mathrm{d}S=\mathrm{d}S_A+\mathrm{d}S_B=-\frac{\mathrm{d}Q}{T_A}+\frac{\mathrm{d}Q}{T_B} &gt;0\]</span></p><h3 id="自由膨胀过程的熵变">自由膨胀过程的熵变：</h3><p><span class="math display">\[(p_1,V_1,T)\rightarrow (p_2,V_2,T)\]</span></p><p>假设等温膨胀。</p><p><span class="math display">\[Q=0,W=0\Rightarrow \Delta E=0,\Delta T=0\]</span></p><p><span class="math display">\[\int_1^2\frac{\mathrm{d}Q}{T}=\int_{V_1}^{V_2}\frac{m&#39;}{M}R\frac{\mathrm{d}V}{V}=\frac{m&#39;}{M}R\ln\frac{V_2}{V_1}&gt;0\]</span></p><p><del>自由膨胀的玻尔兹曼熵：</del>玻尔兹曼熵不考</p><p><del>一个分子在 <span class="math inline">\(V_1\)</span> 内具有微观态数：<span class="math inline">\(\omega_1=\frac{V_1}{\tau}\)</span></del></p><p><span class="math inline">\(N\)</span> 个分子在 <span class="math inline">\(V_1\)</span> 内具有微观态数：<span class="math inline">\(W_1=(\frac{V_1}{\tau})^n\)</span></p><p><span class="math inline">\(N\)</span> 个分子在 <span class="math inline">\(V_2\)</span> 内具有微观态数：<span class="math inline">\(W_2=(\frac{V_2}{\tau})^n\)</span></p><p><span class="math display">\[\frac{W_1}{W_2}=(\frac{V_1}{V_2})^n\]</span></p><p>两边取自然对数再乘玻尔兹曼常数 <span class="math inline">\(k\)</span>，</p><p><span class="math display">\[k\ln\frac{W_2}{W_1}=kN\ln\frac{V_2}{V_1}=kvN_A\ln\frac{V_2}{V_1}=vR\ln \frac{V_2}{V_1}\]</span></p><p>此即由克劳修斯熵公式导出的等温膨胀结果。</p><p><span class="math display">\[\Delta S=k\ln\frac{W_2}{W_1}=k\ln W_2-k\ln W_1\]</span></p><p>称 <span class="math inline">\(S=k\ln W\)</span> 为玻尔兹曼熵公式。</p><hr /><p>等温膨胀熵变（已经推导过，直接给出结果）</p><p><span class="math display">\[\Delta S=vR\ln\frac{V_2}{V_1}\]</span></p><p>等压过程熵变：</p><p><span class="math display">\[\Delta S=\int_{T_1}^{T_2}\frac{\delta Q}{T}=\int_{T_1}^{T_2}\frac{C_{p,m}\mathrm{d}T}{T}=C_{p,m}\ln \frac{T_2}{T_1}\]</span></p><p>等容过程熵变：</p><p><span class="math display">\[\Delta S=\int_{T_1}^{T_2}\frac{\delta Q}{T}=\int_{T_1}^{T_2}\frac{C_{V,m}\mathrm{d}T}{T}=C_{V,m}\ln \frac{T_2}{T_1}\]</span></p>]]></content>
      
      
      <categories>
          
          <category> 课程笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>《概率论与数理统计》定义/性质速通</title>
      <link href="/2023/05/17/%E3%80%8A%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1%E3%80%8B%E5%AE%9A%E4%B9%89-%E6%80%A7%E8%B4%A8%E9%80%9F%E9%80%9A/"/>
      <url>/2023/05/17/%E3%80%8A%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1%E3%80%8B%E5%AE%9A%E4%B9%89-%E6%80%A7%E8%B4%A8%E9%80%9F%E9%80%9A/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="杂项概念">杂项概念</h2><ul><li><p>分布函数的三个性质：若 <span class="math inline">\(a\geq b\)</span>，则 <span class="math inline">\(F(a)\geq F(b); \mathop{\lim}\limits_{x\rightarrow -\infty} F(x)=0,\mathop{\lim}\limits_{x\rightarrow +\infty} F(x)=1;\mathop{\lim}\limits_{x\rightarrow a^+} F(x)=F(a)\)</span></p></li><li><p>二项分布最可能取值：<span class="math inline">\((n+1)p\in N\rightarrow (n+1)p,(n+1)p-1; (n+1)p\notin N\rightarrow [(n+1)p]\)</span></p></li><li>已知 <span class="math inline">\(f_x(x) ,Y=g(X)\)</span> 求 <span class="math inline">\(f_y(y)\)</span><ul><li>对<span class="math inline">\(x\)</span>积分后对 <span class="math inline">\(y\)</span> 求导</li><li>反函数：<span class="math inline">\(h(Y)=X\)</span></li><li>单调段：<span class="math inline">\(f_Y(y)=f_x(h(y))|h&#39;(y)|\)</span></li><li>不单调段：<span class="math inline">\(f_Y(y)=f_x(h_1(y))|h_1&#39;(y)|+f_x(h_2(y))|h_2&#39;(y)|\)</span></li></ul></li><li><span class="math inline">\(F(x,y)=\int_{-\infty}^x\int_{-\infty}^yf(x,y)\mathrm{d}x\mathrm{d}y,F_x(x)=\int_{-\infty}^xf_x(x)\mathrm{d}x,f_x(x)=\int_{-\infty}^{+\infty}f(x,y)\mathrm{d}x\)</span></li><li>若 <span class="math inline">\(F(x,y)=F_x(x)\cdot F_y(y)\)</span> 或 <span class="math inline">\(f(x,y)=f_x(x)\cdot f_y(y)\)</span> ，则 <span class="math inline">\(x,y\)</span> 相互独立</li><li>条件密度函数<ul><li><span class="math inline">\(f_{Y|X}(y|x)=\frac{f(x,y)}{f_x(x)},F_{Y|X}(y|x)=\int_{-\infty}^{y}f_{Y|X}(y|x)\mathrm{d}y\)</span></li></ul></li><li>二维正态分布：五个参数确定，不能由两个一维正态分布确定</li><li>切比雪夫不等式：<ul><li><span class="math inline">\(P(|X-E(X)|\geq \varepsilon)\leq \frac{D(X)}{\varepsilon ^2}\)</span></li><li><span class="math inline">\(P(|X-E(X)|\leq \varepsilon)\geq 1-\frac{D(X)}{\varepsilon ^2}\)</span></li></ul></li></ul><h2 id="期望与方差">期望与方差</h2><ul><li><span class="math inline">\(\mathrm{Var}[X]=E[X^2]-E[X]^2\)</span></li><li>若 <span class="math inline">\(X,Y\)</span> 相互独立（且都存在数学期望），则 <span class="math inline">\(E[aX+bY]=aE[X]+bE[Y],E[XY]=E[X]\cdot E[Y]\)</span></li><li><span class="math inline">\(\mathrm{Var}[aX+bY]=a^2\mathrm{Var}[X]+b^2\mathrm{Var}[Y]\)</span></li></ul><h3 id="偏度和峰度">偏度和峰度</h3><p>称</p><p><span class="math display">\[\frac{E[(X-E[X])^3]}{\mathrm{(Var}[X])^{\frac{3}{2}}}\]</span></p><p>为 <span class="math inline">\(X\)</span> 的偏度，而称</p><p><span class="math display">\[\frac{E[(X-E[X])^4]}{(\mathrm{Var}[X])^2}\]</span></p><p>为 <span class="math inline">\(X\)</span> 的峰度.</p><h3 id="协方差和相关系数">协方差和相关系数</h3><p>称</p><p><span class="math display">\[\mathrm{Cov}(X,Y)=E[(X-E[X])(Y-E[Y])]\]</span></p><p>为 <span class="math inline">\(X\)</span> , <span class="math inline">\(Y\)</span> 的协方差. 可以证明:</p><p><span class="math display">\[\mathrm{Cov}(X,Y)=E[XY]-E[X]\cdot E[Y]\]</span></p><p>称</p><p><span class="math display">\[r(X,Y)=\frac{\mathrm{Cov}(X,Y)}{\sqrt{\mathrm{Var}[X]\cdot \mathrm{Var}[Y]}}\]</span></p><p>为 <span class="math inline">\(X\)</span> , <span class="math inline">\(Y\)</span> 的相关系数，有：</p><ul><li><p>若 <span class="math inline">\(r(X,Y)=0\)</span>，则 <span class="math inline">\(X,Y\)</span> 不相关</p></li><li><p>若 <span class="math inline">\(X\)</span> 与 <span class="math inline">\(Y\)</span> 独立，则 <span class="math inline">\(\mathrm{Cov}(X,Y)=r(X,Y)=0\)</span></p></li><li><p>若 <span class="math inline">\(r=\pm1\)</span> ，则存在 <span class="math inline">\(a,b (a&gt;0)\)</span> 使得 <span class="math inline">\(Y=\pm ax+b\)</span></p></li><li><p>$ [X,Y]=(Y,X)$</p></li><li><p>独立则一定不相关，但不相关不一定独立</p></li><li><p><span class="math inline">\(\mathrm{Var}[aX+bY]=a^2\mathrm{Var}[X]+b^2\mathrm{Var}]Y]+2ab\mathrm{Cov}(X,Y)\)</span> （若 <span class="math inline">\(X,Y\)</span> 相互独立，显然没有协方差一项.）</p></li><li><p><span class="math inline">\(\mathrm{Cov}(aX+bY,Z)=a\mathrm{Cov(X,Z)}+b\mathrm{Cov}(y,z)\)</span></p></li></ul><h2 id="分布">分布</h2><h3 id="分布-1">0-1 分布</h3><p><span class="math inline">\(P(X=1)=p,P(x=0)=1-p\)</span></p><h3 id="几何分布">几何分布</h3><p><span class="math inline">\(P(X=k)=p(1-p)^{k-1}\)</span>，取第 <span class="math inline">\(k\)</span> 次第一次取到的概率。</p><p><span class="math inline">\(\overline X=(\frac{1}{p}),D(X)=\frac{1-p}{p^2}\)</span></p><h3 id="二项分布">二项分布</h3><p><span class="math inline">\(n\)</span> 重的 0-1 分布</p><p>若</p><p><span class="math display">\[P(X=k)={n\choose k}p^k(1-p)^{n-k}\]</span></p><p>则称 <span class="math inline">\(X\)</span> 服从<strong>二项分布</strong>，记为 <span class="math inline">\(X\sim B(n,p)\)</span>.</p><p>性质：<span class="math inline">\(E[X]=np, \mathrm{Var}[X]=np(1-p)\)</span>.</p><p>可以将 <span class="math inline">\(n\)</span> 足够大的二项分布视为正态分布，有 <span class="math inline">\(\mu =np,\sigma^2=np(1-p)\)</span></p><h3 id="泊松分布">泊松分布</h3><p>二项分布的极限分布</p><p><span class="math display">\[P(X=k)=\frac{\lambda^k}{k!}e^{-\lambda},k=0,1,2,\cdots\]</span></p><p>记为 <span class="math inline">\(X\sim \mathrm{Pois}(\lambda)\)</span> 或 <span class="math inline">\(\mathrm P(\lambda)\)</span>.</p><p>二项分布 <span class="math inline">\(n\rightarrow \infty,np\rightarrow \lambda\)</span> 时服从泊松分布.</p><p>若二项分布 <span class="math inline">\(n\)</span> 足够大且 <span class="math inline">\(p\)</span> 足够小，就可以用泊松分布来估计.</p><p>特别地，<span class="math inline">\(E[X]=\mathrm{Var}[X]=\lambda\)</span>.</p><h3 id="正态分布">正态分布</h3><p>若</p><p><span class="math display">\[f_X(x)=\frac{1}{\sqrt{2\pi}\sigma}e^{-\frac{(x-\mu)^2}{2\sigma^2}},-\infty&lt;x&lt;+\infty\]</span></p><p>则称 <span class="math inline">\(X\)</span> 服从正态分布，记为 <span class="math inline">\(X\sim N(\mu,\sigma^2)\)</span>.</p><p><span class="math inline">\(N(0,1)\)</span> 是标准正态分布.</p><p>对于标准正态分布，有：</p><p>分部密度函数</p><p><span class="math display">\[\phi(x)=\frac{1}{\sqrt{2\pi}}e^{-\frac{x^2}{2}}\]</span></p><p>分布函数：</p><p><span class="math display">\[\Phi(x)=\frac{1}{\sqrt{2\pi}}\int_{-\infty}^xe^{-\frac{t^2}{2}}\mathrm{d}t\]</span></p><p>一般的正态分布 <span class="math inline">\(X\sim N(\mu,\sigma^2 )\)</span> 可以通过以下转换变为标准正态分布</p><ul><li><span class="math inline">\(Y=\frac{X-\mu}{\sigma}\)</span></li></ul><p>分部函数 <span class="math inline">\(\Phi\)</span> 难以积分，一般查表得到。</p><ul><li><p>设总体 <span class="math inline">\(X\sim N(0,1),(X_1,X_2,\cdots,X_n)\)</span> 为其样本,则</p></li><li><ul><li><span class="math inline">\(\overline X=\frac{1}{n}\sum_{i=1}^nX_i\sim N(0,\frac{1}{n}))\)</span></li></ul></li><li><ul><li><span class="math display">\[nS_n^2=\sum_{i=1}^{n}(X_i-\overline X)^2\sim \chi^2(n-1)\]</span></li></ul></li></ul><p>更一般地说, 正态总体的五条性质，设总体 <span class="math inline">\(X\sim N(\mu,\sigma^2),(X_1,X_2,\cdots,X_n)\)</span> 为其样本,则</p><ul><li><p><span class="math inline">\(\overline X\sim N(\mu,\frac{\sigma^2}{n}))\)</span>，或表述为 <span class="math inline">\(E(X)=\mu ,D(X)=\frac{\sigma ^2}{n}\)</span></p></li><li><span class="math display">\[\frac{nS_n^2}{\sigma^2}=\sum_{i=1}^{n}(X_i-\overline X)^2\sim \chi^2(n-1)\]</span></li><li><span class="math display">\[\frac{\overline X-\mu}{\frac{S}{\sqrt{n}}}\sim t(n-1)\]</span></li><li>$X $ 和 <span class="math inline">\(S_n^2\)</span> 独立</li><li><p><span class="math inline">\(E(S^2)=\sigma ^2\)</span></p></li></ul><p>两个正态总体下的两条结论：</p><ul><li><span class="math display">\[\frac{\frac{S_1^2}{\sigma_1^2}}{\frac{S_2^2}{\sigma_2^2}}\sim F(n_1,n_2)\]</span></li><li><span class="math display">\[\frac{\overline X - \overline Y -(\mu_1-\mu_2)}{\sqrt{\frac{(n_1-1)S_X+(n_2-1)S_Y}{n_1+n_2-2}}\sqrt{\frac{1}{n_1}+\frac{1}{n_2}}}\sim t(n_1+n_2-2)\text{（t 分布的可加性）}\]</span></li></ul><p>若 <span class="math inline">\(X\sim N(u_1,m),Y\sim N(u_2,n)\)</span></p><p>则 <span class="math inline">\(Z=X±Y\sim N(u_1±u_2,m+n)\)</span></p><h3 id="指数分布">指数分布</h3><p>密度函数:</p><p><span class="math display">\[f(x)=\lambda e^{-\lambda x},(x&gt;0)\]</span></p><p>数学期望 <span class="math inline">\(\frac{1}{\lambda}\)</span> , 方差 <span class="math inline">\(\frac{1}{\lambda^2}\)</span></p><h3 id="均匀分布">均匀分布</h3><p><span class="math inline">\(X\)</span> 在一个区间 <span class="math inline">\([a,b]\)</span> 内平均分布.</p><p>容易得到</p><p><span class="math display">\[E(X)=\frac{b-a}{2}\]</span></p><p><span class="math display">\[\mathrm{Var}[X]=E[X^2]-E[X]^2=\int_a^b\frac{x^2}{b-a}\mathrm{d}x-(\frac{a+b}{2})^2=\frac{(b-a)^2}{12}\]</span></p><hr /><p>接下来三个分布是数理统计中的三大分布（都是连续型），他们都与正态分布具有密切联系</p><h3 id="卡方分布">卡方分布</h3><p><span class="math inline">\(\chi ^2\)</span> 分布.</p><p><span class="math inline">\(n\)</span> 个均服从标准正态分布的随机变量的平方和构成的新的随机变量的分布称为<span class="math inline">\(\chi ^2\)</span> 分布. 且该卡方分布 <strong>自由度为 <span class="math inline">\(n\)</span> </strong>.</p><p>自由度是随机变量的个数.</p><ol type="1"><li>设 <span class="math inline">\(X\sim \chi^2(n)\)</span> , 则可以得到</li></ol><p><span class="math display">\[E(X)=n,\mathrm{Var}[X]=2n\]</span></p><ol start="2" type="1"><li><p>若 <span class="math inline">\(X_1\sim \chi^2(n_1),X_2\sim \chi^2(n_2)\)</span>, 则 <span class="math inline">\(X_1+X_2\sim \chi ^2(n_1+n_2)\)</span></p></li><li><p>若 <span class="math inline">\(X\sim \chi^2(n),n\rightarrow +\infty\)</span> , 则 <span class="math inline">\(\frac{X-n}{\sqrt{2n}}\sim N(0,1)\)</span>. （用中心极限定理很容易证明, <span class="math inline">\(\mu=1,\sigma^2=2\)</span>）</p></li><li><p>设 <span class="math inline">\(X_1,X_2,X_3,\cdots,X_n\)</span> 为取自正态总体 <span class="math inline">\(X\sim N(\mu,\sigma ^2)\)</span> 的样本，则</p></li></ol><p><span class="math display">\[\frac{1}{\sigma^2} \sum_1^n(X_i-\mu)^2\sim \chi ^2 (n-1)\]</span></p><p>（证明，<span class="math inline">\(\frac{X_i-\mu}{\sigma}\sim N(0,1)\)</span>，且相互独立，将<span class="math inline">\((\frac{X_i-\mu}{\sigma})^2\)</span>加起来即可）</p><ol start="5" type="1"><li>设 <span class="math inline">\(X_1,X_2,X_3,\cdots,X_n\)</span> 为取自正态总体 <span class="math inline">\(X\sim N(\mu,\sigma ^2)\)</span> 的样本，则样本均值 <span class="math inline">\(\overline X\)</span> 与样本方差 <span class="math inline">\(S_n^2\)</span> 相互独立，且</li></ol><p><span class="math display">\[\overline X\sim N(\mu,\frac{\sigma ^2}{n})\]</span></p><p><span class="math display">\[\frac{nS_n^2}{\sigma^2}=\frac{1}{\sigma^2} \sum_1^n(X_i-\overline X)^2\sim \chi ^2 (n)\text{(注意与 4 中的式子对比)}\]</span></p><p>为什么该式子自由度变为 <span class="math inline">\(n-1\)</span> ?</p><p>表面上看 $ _1<sup>n(X_i-X)</sup>2$ 是 <span class="math inline">\(n\)</span> 个独立正态随机变量的平方和，实际上他们并<strong>不独立</strong>，因为有 <span class="math inline">\(\sum_1^n(X_i-\overline X) =0\)</span> 故一旦 <span class="math inline">\(n\)</span> 个值中的 <span class="math inline">\(n-1\)</span> 个确定，第 <span class="math inline">\(n\)</span> 个也随之确定.</p><p><strong>抽样分布基本定理</strong>是上述定理的特例:</p><p>设 <span class="math inline">\(X_1,X_2,X_3,\cdots,X_n\)</span> 为取自正态总体 <span class="math inline">\(X\sim N(0,1)\)</span> 的样本，则样本均值 <span class="math inline">\(\overline X\)</span> 和方差 <span class="math inline">\(S_n^2\)</span> 相互独立，且</p><p><span class="math display">\[\overline X\sim N(0,\frac{1}{n})\]</span></p><p><span class="math display">\[nS_n^2\sim \chi ^2(n-1)\]</span></p><h3 id="t分布">t分布</h3><p>若 <span class="math inline">\(X\sim N(0,1),Y\sim \chi^2(n)\)</span> 且相互独立, 则称</p><p><span class="math display">\[T=\frac{X}{\sqrt{Y/n}}\]</span></p><p>服从自由度为 <span class="math inline">\(n\)</span> 的 t分布, 记作 <span class="math inline">\(t(n)\)</span>.</p><h3 id="f分布">F分布</h3><p>若 <span class="math inline">\(X\sim \chi^2(m),Y\sim \chi ^2(n)\)</span>,则称 <span class="math inline">\(Z=\frac{X/m}{Y/n}\)</span> 服从 F分布. 记作 <span class="math inline">\(Z\sim F(m,n)\)</span>.</p><p>注意到，若 <span class="math inline">\(T\sim t(n)(X\sim N(0,1),Y\sim \chi^2(n))\)</span>，则有 <span class="math inline">\(T^2\sim \frac{X^2}{Y/n}=\frac{\chi^2(1)}{Y/n}=F(1,n)\)</span></p><h2 id="中心极限定理">中心极限定理</h2><p>若随机变量序列 <span class="math inline">\(X_1,X_2,\cdots\)</span> 具有有限的数学期望和方差，且服从</p><p><span class="math display">\[\frac{\sum_{k=1}^{n}(X_k-E[X_k])}{\sqrt{\mathrm{Var}\Big[\sum _{k=1}^nX_k\Big ]}}\rightarrow N(0,1)\]</span></p><p>则称其服从中心极限定理.</p><h3 id="棣莫弗-拉普拉斯中心极限定理">棣莫弗-拉普拉斯中心极限定理</h3><p>设 <span class="math inline">\(X_1,X_2,\cdots\)</span> 独立同分布，服从 <span class="math inline">\(B(1,p)\)</span> ，则 <span class="math inline">\(X_1,X_2,\cdots\)</span> 服从中心极限定理，即</p><p><span class="math display">\[\mathop{\lim}\limits_{n\rightarrow \infty} P(\frac{1}{\sqrt{np(1-p)}}\Big [\sum_{k=1}^nX_k-np\Big ]\leq x)=\Phi(x)=\frac{1}{\sqrt{2\pi}}\int_{-\infty} ^{x}e^-{\frac{u^2}{2}}\mathrm{d}u\]</span></p><p>这个式子看上去比较复杂，实际上表达的意义是 <span class="math inline">\(\sum X-E[X]\)</span> 经过对正态分布的拟合（除以标准差）后服从标准正态分布.</p><p>该定理是下面 <strong>林德伯格-莱维定理</strong> 关于二项分布的特例.</p><h3 id="林德伯格-莱维定理">林德伯格-莱维定理</h3><p>设 <span class="math inline">\(X_1,X_2,\cdots\)</span> 独立同分布，具有有限的数学期望 <span class="math inline">\(\mu\)</span> 与方差 <span class="math inline">\(\sigma ^2\)</span> 则 <span class="math inline">\(X_1,X_2,\cdots\)</span> 必定服从中心极限定理，即</p><p><span class="math display">\[\mathop{\lim}\limits_{n\rightarrow \infty} P(\frac{1}{\sigma\sqrt{n}}\Big [\sum_{k=1}^nX_k-n\mu\Big ]\leq x)=\Phi(x)=\frac{1}{\sqrt{2\pi}}\int_{-\infty} ^{x}e^-{\frac{u^2}{2}}\mathrm{d}u\]</span></p><p>即，如果一个序列<strong>独立同分布</strong>且数学期望和方差有限，则其每一项减去期望值后的和 经过对正态分布的拟合（除以标准差与 <span class="math inline">\(\sqrt{n}\)</span> 的乘积）后服从标准正态分布.</p><p>有了这个定理，当 <span class="math inline">\(n\)</span> 比较大时，我们就可以用正态分布估算部分和的分布了.</p><h2 id="估计">估计</h2>]]></content>
      
      
      <categories>
          
          <category> 课程笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> math </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>组合计数知识摘要</title>
      <link href="/2023/05/09/%E7%BB%84%E5%90%88%E8%AE%A1%E6%95%B0%E7%9F%A5%E8%AF%86%E6%91%98%E8%A6%81/"/>
      <url>/2023/05/09/%E7%BB%84%E5%90%88%E8%AE%A1%E6%95%B0%E7%9F%A5%E8%AF%86%E6%91%98%E8%A6%81/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>本文原稿初稿于2019-11-17，搬运过来作参考。</p><hr /><h1 id="基础知识">基础知识</h1><h2 id="排列组合">排列组合</h2><h3 id="排列">排列</h3><p>从<span class="math inline">\(n\)</span>个数字有序地选择<span class="math inline">\(k\)</span>个数字的方案数。</p><p>第一个数字有<span class="math inline">\(n\)</span>种选择方案，第二个有<span class="math inline">\(n-1\)</span></p><p>于是答案为<span class="math inline">\(n(n-1)(n-2)...(n-k+1)=\frac{n!}{(n-k)!}=n^{\underline{k}}\)</span>。(<span class="math inline">\(n^{\underline{k}}\)</span>指n的k次下降幂）</p><p>记为<span class="math inline">\(P_n^k,A_n^k,{n\choose k}*k!\)</span></p><p>前两个好像是苏联的符号...?</p><h3 id="组合">组合</h3><p>从<span class="math inline">\(n\)</span>个数字个数字无序地选择<span class="math inline">\(k\)</span>个数字的方案数。</p><p>因为无序，在排列的基础上除以<span class="math inline">\(k!\)</span>即可</p><p>记为<span class="math inline">\(C_n^k,{n\choose k}\)</span></p><p>同样地，国际上都喜欢用第二种。</p><h3 id="二项式定理">二项式定理</h3><p><span class="math inline">\((x+1)^n\)</span>中<span class="math inline">\(x^k\)</span>前的系数。</p><p>等价于<span class="math inline">\(n\)</span>个单项式中选<span class="math inline">\(k\)</span>个取<span class="math inline">\(x\)</span>，其余取<span class="math inline">\(1\)</span></p><p>展开式：</p><p><span class="math display">\[(x+y)^n=\sum_{k=0}^n{n \choose k}x^ky^{n-k}\]</span></p><h3 id="广义二项式定理">广义二项式定理</h3><p>求<span class="math inline">\((x+y)^a\)</span> （a是有理数）</p><p><span class="math display">\[(x+y)^a=\sum^{\infty}_{k=0}\frac{a^{\underline{k}}}{k!}x^ky^{(a-k)}\]</span></p><p>如果是正整数显然能那个分数能对应成刚刚的组合数</p><p>其他情况要泰勒展开，我不会。</p><h3 id="隔板法">隔板法</h3><p>n个一样的球放进m个不同的盒子，能不放，求方案数</p><p>把n个东西划分成m段，可以强行加m个球要求不能不放，那么就是在n+m-1个划分点选m-1个</p><p>答案为<span class="math inline">\({n+m-1 \choose m-1}={n+m-1 \choose n}\)</span></p><p>以上是最简单的排列组合，下面的东西可能会让人懵掉。</p><h2 id="计数原理">计数原理</h2><h3 id="抽屉原理">抽屉原理</h3><p>把<span class="math inline">\(kx+b(0&lt;b&lt;x)\)</span>个物品放进<span class="math inline">\(x\)</span>个盒子内，至少有一个盒子内有<span class="math inline">\(k+1\)</span>个东西</p><h3 id="加法原理">加法原理</h3><p>事件<span class="math inline">\(A\)</span>有<span class="math inline">\(n\)</span>个结局，事件<span class="math inline">\(B\)</span>有m种结局，发生了一个事件，共有<span class="math inline">\((n+m)\)</span>种结局</p><p>若干不交的集合取一个的方案数，等于集合大小的和。</p><h3 id="乘法原理">乘法原理</h3><p>事件<span class="math inline">\(A\)</span>有<span class="math inline">\(n\)</span>个结局，事件<span class="math inline">\(B\)</span>有<span class="math inline">\(m\)</span>个结局，两个事件都发生了，共有<span class="math inline">\(nm\)</span>种结局</p><p>若干不交的集合格取一个的方案数，等于集合大小的乘积。</p><p>以上计数原理是计数的基石，虽然很浅显但是在后面的知识中扮演关键的角色、</p><h2 id="特殊数列">特殊数列</h2><h3 id="卡特兰数">卡特兰数</h3><p>定义式：</p><p><span class="math display">\[h_n=\sum^{n-1}_{k=0}h_kh_{n-1-k}(h_0=h_1=1)\]</span></p><p>通项式：</p><p><span class="math display">\[h_n={2n \choose n}-{2n \choose n-1}=\frac{2n \choose n }{n+1}\]</span></p><p>应用场景很多</p><p>括号序列数量，<span class="math inline">\(n\times n\)</span>方格行走数（不能越过对角线），凸多边形划分数，二叉树数量</p><p>用方格行走推导 $h_n = {2n n} - {2n n-1} $ ：</p><p>将模型转换成这样：</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/pkcg7ezl.png" /></p><p>然后不能越过下面的直线</p><p>我们要走n次向上，n次向下，共2n次，这样我们才能回到0。</p><p>先忽略不能越过下面的直线，那就是在2n步中选出n步向上走，为<span class="math inline">\({2n \choose n}\)</span></p><p>接下来减掉不合法的，如果越过了这个线，那么这时我们把终点(n,0)，改成(n,,-2)，进行一次<strong>翻转</strong>，就只需要走n+1步向下，n-1步向上，答案为<span class="math inline">\({2n \choose n-1}\)</span>，这是一个<strong>反射法</strong>的经典应用。</p><p><span class="math inline">\({2n \choose n}-{2n \choose n-1}=\frac{2n \choose n}{n+1}\)</span> 可以用数学方法证明<del>留与读者自证</del></p><h3 id="第一类斯特林数">第一类斯特林数</h3><p>用<span class="math inline">\(S_u(n,m)\)</span>表示n个不同元素构成m个圆排列的方案数</p><p>1.最后一个元素单独做环</p><p>2.插入之前的m个环中</p><p><span class="math display">\[S_u(n,m)=S_u(n-1,m-1)+(n-1)*S_u(n-1,m)\]</span></p><p>第一类斯特林数有时候有符号，在生成函数上应用较多，记为<span class="math inline">\(S_s\)</span></p><p><span class="math display">\[S_s(n,m)=(-1)^{n+m}S_u(n,m)\]</span></p><p>有符号的斯特林数的生成函数为<span class="math inline">\(x^{\underline{n}}\)</span>，这个结论非常重要，有了这个可以快速求斯特林数</p><p>建议明白生成函数后再回来看</p><h3 id="第二类斯特林数">第二类斯特林数</h3><p><span class="math inline">\(S(n,m)\)</span>表示把<span class="math inline">\(n\)</span>个不同元素拆分进<span class="math inline">\(m\)</span>个非空集合的方案数，集合不为空</p><p><span class="math display">\[S(n,m)=S(n-1,m-1)+m*S(n-1,m)\]</span></p><p>类似于第一类斯特林数，考虑当前元素再新建一个集合和加入之前的集合即可。</p><p><span class="math display">\[S(n,m)=\frac{1}{m!}\sum(-1)^k{m \choose k}(m-k)\]</span></p><p>这个式子可以用卷积快速计算，但是因为本篇主题是计数，所以不展开。</p><p>贝尔数（不要求划分成几个集合）是第二类斯特林数之和。</p><h3 id="拆分数">拆分数</h3><p><span class="math inline">\(f_n\)</span>表示大小为n的正整数拆分成若干无序的正整数和的方案数</p><p>有两种DP方法</p><p>1<span class="math inline">\(.f_{i,j}\)</span>表示拆分成若干不超过j的方案数</p><p><span class="math display">\[f_{i,j}=f_{i-j,j}+f_{i,j-1}\]</span></p><p>2.<span class="math inline">\(g_{i,j}\)</span>表示拆分j个数字的方案数</p><p><span class="math display">\[g_{i,j}=g_{i-1,j-1}+g_{i-j,j}\]</span></p><p>两个DP复杂度都是平方级别的。</p><p>考虑大小超过<span class="math inline">\(\sqrt{n}\)</span>的数字最多只有<span class="math inline">\(\sqrt{n}\)</span>个，结合两种DP，复杂度<span class="math inline">\(O(n\sqrt{n})\)</span></p><p>用第一个DP考虑小的数字，用第二个DP考虑大的数字，先用f算出<span class="math inline">\(\sqrt{n}\)</span>以内的答案，g的方程就可以改为<span class="math inline">\(g_{i,j}=g_{i-\sqrt{n},j-1}+g_{i-j,j}\)</span></p><p>拆分数也有生成函数，为：</p><p><span class="math display">\[\frac{1}{\Sigma(-1)^kx^{k(3k\pm 1)}}\]</span></p><p>下面这个分母是带符号的五边形数</p><p>如果把拆分出来的正整数想象成柱形图，那么这两种方法一种是按列考虑，一种按行考虑。</p><h1 id="生成函数">生成函数</h1><blockquote><p>生成函数的应用简单来说在于研究未知（通项）数列规律，用这种方法在给出递推式的情况下求出数列的通项</p></blockquote><h2 id="多项式与形式幂级数">多项式与形式幂级数</h2><p>形式幂级数的定义：</p><p><span class="math display">\[\sum _{n\geq 0}a_nx^n\]</span></p><p>可以认为是一个有无穷次项的多项式，所有次项都为正</p><p>加减法：</p><p><span class="math display">\[\sum _{n\geq 0}a_nx^n\pm \sum _{n\geq 0}b_nx^n=\sum _{n\geq 0} (a_n\pm b_n)x^n\]</span></p><p>乘法：</p><p><span class="math display">\[\sum _{n\geq 0}a_nx^n\times \sum _{n\geq 0}b_nx^n=\sum_{n\geq 0}(\sum _{k=0}^na_kb_{n-k}x^n)\]</span></p><p>类似于多项式的加减法和乘法</p><h2 id="闭形式">闭形式</h2><p>形式幂级数的表达形式是一个长度无穷的多项式，但是对于部分的形式幂级数，存在长度有限的函数能够直接表示它，则称之为闭形 式。</p><p>比如等比数列：</p><p><span class="math display">\[\sum _{n \geq0}x^n=\frac{1}{1-x}\]</span></p><p><span class="math display">\[\sum _{n \geq1}x^n=x\sum _{n \geq0}x^n=\frac{x}{1-x}\]</span></p><p>意义：把无穷长度的形式幂级数改写为有限长度的闭形式</p><h2 id="组合对象">组合对象</h2><p>组合计数是一类常见问题，通常给定我们若干组合条件，对于每个组合对象，有某个函数 <span class="math inline">\(size\)</span> 衡量了它的大小，如图的节点数，序列的长度等。<span class="math inline">\(size\)</span> 为 <span class="math inline">\(n\)</span> 的个数为有限个，记为$A_n <span class="math inline">\(，求某个\)</span>A_n.$</p><p>这些图，序列等就是组合对象。</p><p>组合对象分为是否有标号的两种，指的是是否考虑组合对象内部的元素有不同的区别，例如无标号的三个点的图只有 4 种，而有标号的有 8 种。</p><h2 id="普通生成函数">普通生成函数</h2><p>数列<span class="math inline">\(A_0,A_1,A_2...\)</span>的普通生成函数为</p><p><span class="math display">\[\sum _{n \geq 0}A_nx^n\]</span></p><p>普通生成函数通常考虑无标号问题，它的加法操作和乘法操作分别对应了并和拼接两种操作。</p><h3 id="斐波那契数">斐波那契数</h3><p><span class="math inline">\(f_n\)</span>表示第n个斐波那契数，求<span class="math inline">\(\sum_{n \geq 0}f_nx^n\)</span>的闭形式</p><p>令</p><p><span class="math display">\[F(x)=\sum_{n\geq0}f_nx^n\]</span></p><p>由于<span class="math inline">\(f_n=f_{n-1}+f_{n-2}\)</span>可得</p><p><span class="math display">\[F(x)=xF(x)+x^2F(x)+1\]</span></p><p>解方程得</p><p><span class="math display">\[F(x)=\frac{1}{1-x-x^2}\]</span></p><p>分解质因数后裂项，可得到通项公式。</p><h3 id="卡特兰数-1">卡特兰数</h3><p>求节点数为n的二叉树个数</p><p>生成函数本身具有组合性质，令<span class="math inline">\(F(x)\)</span>表示该问题的生成函数，一棵二叉树可以划分成根节点和左右子树，是两个完整都二叉树，</p><p>所以<span class="math inline">\(F(x)=xF^2(x)+1\)</span>，解方程可得<span class="math inline">\(F(x)=\frac{1-\sqrt{1-4x}}{2x}\)</span></p><p>通过泰勒展开可以求得通项公式。</p><p>因为我不会 也不是主题内容，所以不展开</p><h2 id="指数生成函数">指数生成函数</h2><p>指数生成函数一般用来解决有标号问题</p><p>数列<span class="math inline">\(A_0,A_1,A_2...\)</span>的指数生成函数为</p><p><span class="math display">\[\sum _{n \geq 0}\frac{A_n}{n!}x^n\]</span></p><h3 id="连通图计数">连通图计数</h3><p>考虑到任意图可以被划分成若干连通图。</p><p>定义连通图的生成函数为<span class="math inline">\(F(x)\)</span>，任意图的生成函数为<span class="math inline">\(G(x)\)</span>。</p><p>很容易求出任意图的生成函数，即</p><p><span class="math display">\[G(X)=\sum _{n\geq 0}\frac{2^{n(n-1)/2}}{n!}x^n\]</span></p><p>任意图是由连通图构成的，所以<span class="math inline">\(G(x)=e^{F(x)}\)</span>，所以F(x)=ln G(x)，通过多项式姿势可以快速求出来</p><h1 id="polya定理">Polya定理</h1><h2 id="burnside-引理">Burnside 引理</h2><h3 id="置换">置换</h3><p>置换就是对元素进行重新排列，必须（类似于线性代数中的<strong>线性映射</strong>）。</p><p>比如，把正方体旋转90度，可以看做四个顶点的一个置换</p><p>有以下结论：</p><p>置换可以构成环:从一个元素置换前到置换后连一条有向边，会构成环(循环）</p><p>定义一个状态S经过置换后与原来相同，则称其为不动点。</p><h3 id="置换群">置换群</h3><p>置换群指的是一个置换的集合，满足任意两个置换不能复合出一个新的不在集合内的置换。</p><h3 id="burnside-引理-1">Burnside 引理</h3><p>令<span class="math inline">\(X\)</span>表示某个集合，<span class="math inline">\(G\)</span>表示某个作用在X上的某个置换群。对于任意<span class="math inline">\(G\)</span>内的元素<span class="math inline">\(g\)</span>，定义<span class="math inline">\(f(g)\)</span>为<span class="math inline">\(X\)</span>内经过置换<span class="math inline">\(g\)</span>后不变的元素数量，我们要求<span class="math inline">\(X\)</span>内本质不同的元素个数（本质不同指不能通过<span class="math inline">\(G\)</span>获得彼此），这个个数记为<span class="math inline">\(|X/G|\)</span></p><p>（这也被称为<strong>等价类</strong>，求的也就是等价类个数）</p><p>形象地说，比如某个集合:</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/nk4kqj4t.png" /></p><p>然后有一个置换为逆时针旋转60度，那这两个元素本质相同。</p><p>Burnside 引理为：</p><p><span class="math display">\[|X/G|=\frac{1}{|G|}\sum_{g\in G}f(g)\]</span></p><p>证明：</p><blockquote><p>我们发现一个元素是不是不动点需要考虑两个东西：一是元素本身，二是置换，所以不动点是<strong>二元</strong>的</p></blockquote><p>例子：</p><blockquote><p>一个正方形分成4格,涂上黑白两种颜色,有多少种方案？其中经过转动相同图像的算一种方案</p></blockquote><p>本来可以直接枚举，但是我们要验证Burnside ，所以对其加以考虑。</p><p>在这个正方形上的置换有：</p><p>(1)顺时针转90度，(2)逆时针转90度，(3)不动，(4)直接转动180度</p><p>先把所有正方形画出来</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/mm8421fo.png" /></p><p>然后按从上到下 从左到右一行一行编号为(1)~(16)</p><p>其中对于每个置换，列出不动点：</p><p>(1):2个</p><p>(2):2个</p><p>(3):16个</p><p>(4):4个</p><p><span class="math display">\[|X/G|=\frac{1}{|G|}\sum_{g\in G}f(g)=\frac{1}{4}(2+2+16+4)=6\]</span></p><h3 id="polya定理-1">Polya定理</h3><p>设<span class="math inline">\(G\)</span>是<span class="math inline">\(X\)</span>的一个置换群，<span class="math inline">\(|X|\)</span>=n，用<span class="math inline">\(m\)</span>种颜色染色，本质不同的方案数:</p><p><span class="math display">\[L=\frac{1}{G}\sum_{g\in G}m^{c(g)}\]</span></p><p><span class="math inline">\(c(g)\)</span>表示<span class="math inline">\(g\)</span>的循环节个数。</p><p>通常我们并不枚举所有的<span class="math inline">\(g\)</span>，并计算<span class="math inline">\(c(g)\)</span>，而是枚举 <span class="math inline">\(c(g)\)</span>，快速计算多少<span class="math inline">\(g\)</span>满足条件。</p><p>仍然将一个正方形分成4格,涂上黑白两种颜色,有多少种方案？其中经过转动相同图像的算一种方案</p><p>在这个正方形上的置换有：</p><p>不动：4</p><p>旋转90度 ：1</p><p>旋转180度 ：2</p><p>旋转270度：1</p><p><span class="math inline">\(M=\frac{1}{4}(2^4+2^1+2^2+2^1)=6\)</span></p><h1 id="生成树计数">生成树计数</h1><h2 id="度数矩阵邻接矩阵和基尔霍夫kirchhoff矩阵">度数矩阵，邻接矩阵和基尔霍夫(Kirchhoff)矩阵</h2><p>对于一个无向图<span class="math inline">\(G\)</span>，定义<span class="math inline">\(G\)</span>的度数矩阵<span class="math inline">\(D\)</span>满足：</p><p><span class="math display">\[d_{i,j}=\begin{cases} deg_i\space\space\space(i=j)\\0\space \space\space\space\space\space\space\space(i\ne j)\end{cases}\]</span></p><p>其中，<span class="math inline">\(deg_i\)</span>表示节点i的度数</p><p>定义<span class="math inline">\(G\)</span>的邻接矩阵<span class="math inline">\(C\)</span>满足：</p><p><span class="math display">\[c_{i,j}=\begin{cases} 0\space\space\space\space\space\space\space\space\space\space(i=j)\\adj_{i,j}\space \space\space(i\ne j)\end{cases}\]</span></p><p>定义<span class="math inline">\(G\)</span>的基尔霍夫矩阵<span class="math inline">\(L\)</span>：<span class="math inline">\(L=D-G\)</span>，也就是：</p><p><span class="math display">\[l_{i,j}=\begin{cases} deg_i\space\space\space\space\space\space\space\space(i=j)\\-adj_{i,j}\space \space\space(i\ne j)\end{cases}\]</span></p><h2 id="行列式">行列式</h2><p>定义：一个矩阵<span class="math inline">\(A\)</span>的行列式表示为:</p><p><span class="math display">\[|A|=\sum _p(-1)^{\sigma(p)}\prod_{i=1}^na_{i,p_i}\]</span></p><p>性质：</p><p>1.一个对角矩阵/上三角矩阵的行列式值是所有对角线上元素的乘积。</p><p>2.交换矩阵的两行/两列，行列式值取反</p><p>3.将矩阵的一行/一列乘上一个固定的常数 k，行列式值也乘上 k。</p><p>4.将矩阵的一行加到另外一行上去，行列式值不变，列同理。</p><p>可以使用高斯消元快速计算行列式。</p><h2 id="矩阵树matrix-tree定理">矩阵树(Matrix-Tree)定理</h2><p>图<span class="math inline">\(G\)</span>的生成树数量是依照以上步骤求出来的基尔霍夫矩阵<span class="math inline">\(L\)</span>的行列式的任意一个代数余子式。</p><p>也就是说随意取它的任意一个<span class="math inline">\(n-1\)</span>阶主子式，然后求出主子式的值，得到的就是在这个图中生成树的数量。</p><p>代码：咕咕咕</p><p>计数笔记就到这里结束了，以后可能会补一些例题什么的~</p><p>接下来大概要学线代和数论/多项式~</p>]]></content>
      
      
      <categories>
          
          <category> 算法竞赛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> math </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用 Latex 写化学方程式</title>
      <link href="/2023/05/09/%E7%94%A8-Latex-%E5%86%99%E5%8C%96%E5%AD%A6%E6%96%B9%E7%A8%8B%E5%BC%8F/"/>
      <url>/2023/05/09/%E7%94%A8-Latex-%E5%86%99%E5%8C%96%E5%AD%A6%E6%96%B9%E7%A8%8B%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>本文收录于2020年的洛谷日报，原文初稿于2020-06-07，小作修改后搬运过来。</p><hr /><p>这篇文章主要介绍<span class="math inline">\(\text{Latex}\)</span>中的 <code>mchm</code> 宏包和 <code>chemfig</code> 宏包，其中较多是 <code>chemfig</code> 宏包书写较复杂的有机化学结构式。</p><p><code>mchm</code> 宏包和 <code>chemfig</code> 宏包都已经可以在 <code>Tex Live</code> 中直接使用，如果您没有本地的 <code>Tex</code> 编译器，可以前往<a href="https://www.overleaf.com/">Overleaf</a>使用在线编译器（需要注册，且免费版编译时间不能超过一分钟）。</p><p><code>chemfig</code>宏包还有更多进阶的内容。详见翻译完成的中文说明书https://chemfig.man.huzheyang.cn</p><h1 id="part-1-textmchm宏包">Part 1 <span class="math inline">\(\text{mchm}\)</span>宏包</h1><p><code>mchm</code> 宏包用来书写不涉及有机化学的化学式。使用这个宏包，需要使用指令<code>\ce&#123;&#125;</code>。在大括号内有以下几个特性。</p><p>1.数字下标将不再需要 <code>_&#123;&#125;</code> 来表示，可以直接书写，如 <code>H2SO4</code> 表现为<span class="math inline">\(\text{H}_2\text{SO}_4\)</span>。</p><p>2.<code>+</code> 和 <code>-</code> 如果没有两边没有空格，则表现为上下标，如 <code>H+</code> 显示为<span class="math inline">\(\text{H}^+\)</span>，<code>H+ + OH-</code> 显示为<span class="math inline">\(\text{H}^+ + \text{OH}^-\)</span>。</p><p>3.水合物的书写可以直接用 <code>*</code> ，如 <code>KCr(SO4)2 * 12H2O</code> 显示为<span class="math inline">\(\text{KCr(SO}_4{)_2} · \text{12H}_2\text{O}\)</span>。</p><p>4.拥有可以标注反应条件的箭头，<code>-&gt; &lt;-&gt; &lt;=&gt;</code> 显示为</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/87vtcmy0.png" /></p><p>此外还有 <code>&lt;=&gt;&gt; &lt;&lt;=&gt;</code> 等箭头。</p><p>如果想要标注反应条件，则在箭头后加 <code>T[][]</code> ，如 <code>-&gt;T[催化剂][\Delta] &lt;=&gt;T[\Delta]</code> 显示为</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/lva68acr.png" /></p><p>5.单键，双键和三键可以直接用 <code>- = #</code> 代替，如 <code>CH3-CH=CH-C#CH</code> 显示为</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/z0tqdmmn.png" /></p><p>6.如果<span class="math inline">\(\text{v}\)</span>和<span class="math inline">\(\text{ \^ }\)</span> 旁边有空格，会显示成向下的箭头（沉淀）和向上的箭头（气体），如 <code>Ca(NO3)2 + Na2CO3 -&gt; CaCO3 v + 2NaNO3</code> 和 <code>2HCl + Na2CO3 -&gt; H2O + CO2 ^ + 2NaCl</code> 显示为</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/1jicxnpz.png" /></p><p>以下是一个被引用很多次的例子（有稍作修改）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">\documentclass&#123;article&#125;</span><br><span class="line">\usepackage[UTF8]&#123;ctex&#125; % 中文宏包</span><br><span class="line">\usepackage&#123;mhchem&#125; %化学式宏包</span><br><span class="line"></span><br><span class="line">\begin&#123;document&#125;</span><br><span class="line"></span><br><span class="line">\ce&#123;2H2 + O2 -&gt;T[点燃] 2H2O&#125;</span><br><span class="line"></span><br><span class="line">\ce&#123;N2 + 3H2 &lt;=&gt;[高温、加压][催化剂] 2NH3&#125;</span><br><span class="line"></span><br><span class="line">\ce&#123;^&#123;227&#125;_&#123;90&#125;Th+&#125;</span><br><span class="line"></span><br><span class="line">\ce&#123;KCr(SO4)2 * 12H2O&#125;</span><br><span class="line"></span><br><span class="line">\ce&#123;C6H5-CHO&#125;</span><br><span class="line"></span><br><span class="line">\ce&#123;X=Y#Z&#125;</span><br><span class="line"></span><br><span class="line">\ce&#123;SO4^2- + Ba^2+ -&gt; BaSO4 v&#125;</span><br><span class="line"></span><br><span class="line">\end&#123;document&#125;</span><br></pre></td></tr></table></figure><p>它显示为：</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/ibit1eru.png" /></p><p>有了以上内容，已经可以较方便地书写无机化学中的大部分化学式了。而 <code>chemfig</code> 宏包，即有机化学，才是这篇文章的重头戏。</p><h1 id="part-2-textchemfig-宏包">Part 2 <span class="math inline">\(\text{chemfig}\)</span> 宏包</h1><ul><li>注：该部分内容需要高中有机化学内容，即必修二和小部分选修五的支持。</li></ul><p><code>chemfig</code> 宏包用于书写有机化学中的结构式等，键线式和结构式等都需要 <code>chemfig</code> 来书写。</p><p><code>\chemfig&#123;&#125;</code> 用于书写单个有机物结构式，如果要将有机化合物写入方程式，可以将 <code>\chemfig&#123;&#125;</code> 嵌套入 <code>\ce&#123;&#125;</code> 里面。</p><p>注意：在<code>chemfig</code>中，三键改为用 <code>~</code> 而不是用 <code>#</code> 来表示。</p><p><code>\chemfig&#123;&#125;</code> 有如下几个作用：</p><p>1.在 <code>\chemfig&#123;&#125;</code> 中，为防止产生歧义，数字下标不再能直接写出，如<span class="math inline">\(\text{CH}_4\)</span>必须写为 <code>CH_4</code> ，<span class="math inline">\(\text{C}_6\text{H}_{12}\text{O}_6\)</span>必须写为 <code>C_6H_&#123;12&#125;O_6</code> 。</p><p>2.在 <code>\chemfig&#123;&#125;</code> 中，化学键会被拉长，且碳碳三键改为用 <code>~</code> 表示，如 <code>\chemfig&#123;CH_3-CH=CH-C~CH&#125;</code> 显示为：</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/ndmlfiad.png" /></p><p>缩短化学键的指令稍后再提。</p><p>3.可以用 <code>*n(---)</code> 表示一个环，n为环的边（或点）个数，括号内为环的化学键。如苯环的凯库勒式可以写作 <code>*6(-=-=-=)</code> 或 <code>*6(=-=-=-)</code> 显示为：</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/eia9u6ny.png" /></p><p>这个苯环有点太大，关于缩小苯环和改变方向，也是过会再提。</p><p>苯环的另一种常见画法是内部带有圆圈的正六边形（鲍林式）。</p><p>我们用 <code>\text&#123;**6(------)&#125;</code> 表示，显示为：</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/qhvjg45l.png" /></p><p>表示六元环时，括号内第一个符号表示左下角的键，逆时针旋转编号，最后一个为最左边的键。如 <code>*6(=-----) *6(-=----) *6(-----=)</code> 分别显示为：</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/rfpbwym4.png" /></p><p>如果括号内的键数量达不到括号外的数字，则会从最后一个开始缺失，如果超过括号外的数字，则不会显示多余的键，如 <code>*6(------=) *6(=----)</code> 分别显示为：</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/5uualvn1.png" /></p><p>单个环中，如果没有定义方向，那么最左边必定是一条垂直的键，且由括号内最后一个符号表示它，括号内第一个符号表示它的下一个键，如 <code>*3(--=)  *4(---=)  *5(----=)</code> 分别显示为：</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/5wsfr1uv.png" /></p><p>4.定义方向和键长，在键后用 <code>[x,y]</code> 描述。x表示方向，y表示键长，方向由 <code>0</code> 到 <code>7</code> 编号。如 <code>0</code> 指向向右， <code>1</code> 指向右上， <code>2</code> 指向正上：</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/uvmayd5l.png" /></p><p>使用例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\text&#123;酮与氰化氢加成：&#125;\ce&#123;\chemfig&#123;CH_3C(=[1]O)(-[7]CH_3)&#125; + \chemfig&#123;CN(-[2]H)&#125; -&gt;T[催化剂] \chemfig&#123;CH_3(-[0]C(-[2]OH)(-[0]CN)(-[6]CH3))&#125;&#125;</span><br></pre></td></tr></table></figure><p>显示为：</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/gutrmh2y.png" /></p><p>你也可以自定义角度，改为 <code>:x</code> ，如 <code>CH_3C(=[:30]O)(-[:330]CH_3)</code> 显示为：</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/xmu61aw6.png" /></p><p>如果不定义角度，系统会按照键的起点所连接的键数量取一个系统认为美观的角度，这个很不靠谱。除非你绘制的分子式全在一条线内，不建议不定义角度。</p><p>我们发现以上的化学键显得有些太长，我们可以用 <code>[,y]</code> 来定义键长，不定义键长时长度默认为1，这个y一般取 <code>0.7</code> 正好，根据你的需要定义键长。</p><p>使用例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\text&#123;酮与氰化氢加成：&#125;\ce&#123;\chemfig&#123;CH_3C(=[1,0.7]O)(-[7,0.7]CH_3)&#125; + \chemfig&#123;CN(-[2,0.7]H)&#125; -&gt;T[催化剂] \chemfig&#123;CH_3(-[0,0.7]C(-[2,0.7]OH)(-[0,0.7]CN)(-[6,0.7]CH3))&#125;&#125;</span><br></pre></td></tr></table></figure><p>显示为：</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/mw507onq.png" /></p><p>如果你只想定义键长，不定义角度，可以写为 <code>[,y]</code> 。</p><p>用这个办法也可以定义环的键长和方向，我们发现上面的苯环太大了，可以改为 <code>[,0.7]*6(-=-=-=)</code> ，也可以定义方向 <code>[:30,0.7]*6(-=-=-=)</code> 分别显示为：</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/9adeza6z.png" /></p><p>由上面酮与氰化氢加成的例子，也能看到少许绘制完整结构式的方法。通过以上几个点，我们还是不能绘制较复杂的结构式，接下来我们将以上几个点拼凑起来，绘制完整的分子结构式。</p><h1 id="part-3-嵌套并列与键线式">Part 3 嵌套，并列与键线式</h1><p>将以上内容结合起来，我们要绘制更加复杂的有机结构式。</p><h2 id="嵌套">嵌套</h2><p>如果绘制不断改变方向的键链，需要用到嵌套。<code>A(-[x,y]B)</code> 绘制了一个条从<span class="math inline">\(\text{A}\)</span>连向<span class="math inline">\(\text{B}\)</span>的单键，B可以继续嵌套下去。如 <code>A(-[x1,y1]B(-[x2,y2]C))</code> 绘制了一条从<span class="math inline">\(\text{A}\)</span>连向<span class="math inline">\(\text{B}\)</span>再连向<span class="math inline">\(\text{C}\)</span>的碳链。</p><p>还有一种嵌套是环中嵌套环来绘制稠环化合物，稠环化合物在高中阶段涉及不多。但仍然稍作介绍。</p><p>嵌套环可以直接在括号内嵌套，给出一个例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">\text&#123;萘：&#125;\ce&#123;\chemfig&#123;[,0.7]*6(-=(*6(-=-=--))-=-=)&#125;&#125;</span><br><span class="line"></span><br><span class="line">\text&#123;蒽：&#125;\ce&#123;\chemfig&#123;[,0.7]*6(-=(*6(-=(*6(-=-=--))-=--))-=-=)&#125;&#125;</span><br><span class="line"></span><br><span class="line">\text&#123;菲：&#125;\ce&#123;\chemfig&#123;[,0.7]*6(-=(*6(-(*6(-=-=--))=-=--))-=-=)&#125;&#125;</span><br></pre></td></tr></table></figure><p>显示为：</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/y5nnlmkg.png" /></p><h2 id="并列">并列</h2><p>如果一个碳连着多个基团，需要用到并列。如 <code>A(-[x1,y1]B)(-[x2,y2]C)</code> 绘制了<span class="math inline">\(\text{A}\)</span>上同时连接了<span class="math inline">\(\text{B}\)</span>和<span class="math inline">\(\text{C}\)</span>基团。</p><h2 id="键线式">键线式</h2><p>键线式在以上的基础上，不添加元素名称即可，如果添加会自动在那个位置上加入元素。给出两个例子</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">\text&#123;褪黑素：&#125;\chemfig&#123;[,0.7]*6(-=(*5(-N(-H)-=(-[:30]CH_2CH_2NHCOCH_3)--))-=-(-H_3CO)=)&#125;</span><br><span class="line"></span><br><span class="line">\text&#123;键线式：&#125;\chemfig&#123;[,0.7]*6(-=(*5(-[0.7]N(-H)-=(-[:30,0.7](-[:330,0.7](-[:30,0.7]N(-[2,0.7]H)(-[:330,0.7](=[6,0.7]O)(-[:30,0.7])))))--))-=-(-[,0.7]O(-[1,0.7]))=)&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/veizr9mf.png" /></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\text&#123;香叶醇：&#125;\chemfig&#123;(-[6](-[5](-[6](-[7](=[6](-[5])(-[7])))))(=[7](-[1](-[7]OH))))&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/utr36t08.png" /></p><p>这样的显示方式，双键与单键相连方式与习惯方式不符，我们可以稍作修改，将代码改为 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\chemfig&#123;(-[6,](-[5,](-[6,](-[7,](=^[6,](-[5,])(-[7,])))))(=^[7,](-[1,](-[7,]OH))))&#125;</span><br></pre></td></tr></table></figure></p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/jx8rwc95.png" /></p><p>注意到，此时单键连向双键的其中一条横向而不是连向两条横线中间了。</p><h1 id="part-4-杂项">Part 4 杂项</h1><p>这个part可能会不断更新，且大部分内容高中化学无需用到。</p><h2 id="两个键的链接">两个键的链接</h2><p>比如异丙基苯，苯环上的一个碳原子连着异丙基，若将异丙基简写为<span class="math inline">\(\text{CH}_3\text{CHCH}_3\)</span>，而键又连着中间的碳，如果直接按以上方法绘制，会将键连至第一个碳。</p><p>这个时候可以指定键的起点（或终点）<code>\chemfig&#123;[,0.7]*6(-=-=(-[2,0.7,,3]CH_3CHCH_3)-=)&#125;</code>，表示终点为异丙基的第三个原子，即中间的<span class="math inline">\(\text{C}\)</span></p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/zan20584.png" /></p><p>如果不采用指定终点，则显示为</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/e3hlxbml.png" /></p><p>在刚刚没有用到的两个逗号之间，表示的是起点，如4-异丙基<del>庚</del>辛烷，写作</p><p><code>\chemfig&#123;CH_3CH_2CH_2CHCH_2CH_2CH_2CH_3(-[2,0.7,7,3]CH_3CHCH_3)&#125;</code></p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/k31xeod0.png" /></p><p>这就是指定起点与终点的键的画法了。</p><h2 id="键的拓展">键的拓展</h2><p>除了常见的单键，双键和三键，存在一些其他的键，如楔形式中的键，<code>chemfig</code> 都提供了方法。</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/92xzsbvu.png" /></p><p>楔形式可以定义三角形的形状。</p><p><code>\chemfig[cram width=10pt,cram dash width=0.4pt,cram dash sep=1pt]&#123;A&gt;B&gt;:C&gt;|D&#125;</code> 中括号内四个参数分别表示起始宽度，线宽度，每几个宽度画一条线（虚楔形用）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">\chemfig[cram width=10pt,cram dash width=0.4pt,cram dash sep=1pt]&#123;A&gt;B&gt;:C&gt;|D&#125;</span><br><span class="line"></span><br><span class="line">\chemfig[cram width=15pt,cram dash width=2pt,cram dash sep=2pt]&#123;A&gt;B&gt;:C&gt;|D&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/ggdkz6ai.png" /></p><p>这种定义方式是定义整个分子所有的键，定义分子所有键的命令还有：</p><p><code>bond offset=</code>表示键的端点与字母之间的距离，如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">\chemfig[bond offset=0pt]&#123;A-B&#125;</span><br><span class="line"></span><br><span class="line">\chemfig&#123;A-B&#125;</span><br><span class="line"></span><br><span class="line">\chemfig[bond offset=5pt]&#123;A-B&#125;</span><br></pre></td></tr></table></figure><p>显示为</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/xy1216su.png" /></p><p>默认bond offset为2pt。可以自定义默认间隔，之后的默认间隔就是你定义的值，也可以定义单个键的间隔，方式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">\setchemfig&#123;bond offset=4pt&#125;</span><br><span class="line">\chemfig&#123;A-B-C&#125;\par</span><br><span class="line">\chemfig&#123;A-#(,0pt)B-C&#125;\par</span><br><span class="line">\chemfig&#123;A-B-#(0pt)C&#125;\par</span><br><span class="line">\chemfig&#123;A-#(,0pt)B-#(0pt)C&#125;</span><br></pre></td></tr></table></figure><p>这里定义了默认间隔为4pt，用小括号中间一个逗号表示一个键起点和终点的间隔，下面看看效果：</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/ghmuiuiu.png" /></p><p>也可以定义键长，不再需要在每个键前面表示键长</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">\chemfig[atom sep=2em]&#123;A-B&#125;\par</span><br><span class="line">\chemfig[atom sep=50pt]&#123;A-B&#125;</span><br></pre></td></tr></table></figure><p>显示为：</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/77aniw64.png" /></p><p>也可以定义颜色，如<code>\chemfig[bond style=&#123;line width=1pt,red&#125;]&#123;A-B=C&gt;|D&lt;E&gt;:F&#125;</code>显示为</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/6ow4mv58.png" /></p><p>另外还有一种方法可以定义键线式的角度，表示为<code>::x</code> ，表示在上一个键的角度上加上<code>x</code>度作为新的角度。</p><p><code>\chemfig&#123;A-[:-5]-[::20]-[::20]B-[7]-[::20]C-[::20]&#125;</code>显示为</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/hvsos9sq.png" /></p><h2 id="高分子聚合物">高分子聚合物</h2><p>先看一个例子</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">\chemfig&#123;-[@&#123;left,0.75&#125;]CH_2-CH_2-[@&#123;right,0.25&#125;]&#125;</span><br><span class="line">\polymerdelim[delimiters =&#123;[]&#125;,height = 5pt]&#123;left&#125;&#123;right&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/xrjhko8j.png" /></p><p>高分子聚合物采用先画中间，再画括号（或者中括号）的画法。由于这种原因，括号常常无法准确放在键中间，所以有时用一个<code>\bigskip</code>放在代码前来优化排版。</p><p>可以看出，用一个<span class="math inline">\(\text{@{x,括号在键的位置}}\)</span>来描述一个括号的位置和名字，第二行绘制括号时，表示了括号种类，高度（也可以用depth表示深度），最后用两个大括号表示加上的位置。</p><p>也有人用 <code>\vphantom</code> 来优化排版，如:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">\chemfig&#123;\vphantom&#123;CH_2&#125;-[@&#123;op,.75&#125;]CH_2-CH_2-[@&#123;cl,0.25&#125;]&#125;</span><br><span class="line">\polymerdelim[delimiters =&#123;[]&#125;,height = 5pt]&#123;op&#125;&#123;cl&#125;</span><br></pre></td></tr></table></figure><p>显示与上面相同，只是在整个pdf中显示会比较正常。</p><p>下面再看几个例子</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">\chemfig&#123;\vphantom&#123;CH_2&#125;-[@&#123;op,0.5&#125;]CH_2-CH(-[6]Cl)-[@&#123;cl,0.5&#125;]&#125;</span><br><span class="line">\polymerdelim[delimiters =&#123;[]&#125;,height = 5pt, depth = 25pt]&#123;op&#125;&#123;cl&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/ilctxrjs.png" /></p><p>下面的例子采用了 <code>h align=false</code> 来使得括号可以不在同一条水平线上</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">\chemfig&#123;-[@&#123;op,.5&#125;:-30]O-[::60](=[::60]O)-[::-60]*6(-=-(-(=[::-60]O)-[::60]O-[::-60]-[::60]-[@&#123;cl,.5&#125;::-60])=-=)&#125;</span><br><span class="line">\polymerdelim[delimiters =&#123;[]&#125;,height=30pt, h align=false]&#123;op&#125;&#123;cl&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/87k3os3d.png" /></p><h2 id="更多符号">更多符号</h2><p><code>\fulldisk</code> 实心点，<code>\emptydisk</code> 空心点（例如绘制十氢化萘的顺反异构体需用到）</p><h1 id="part-5-demo">Part 5 demo</h1><p>以下给出一个完整的文档例子，绘制了高中有机化学基础常见的化学方程式，如果上面的内容没有完全讲明白一些细小的点，可以由例子中体会。</p><p><a href="https://www.luogu.com.cn/paste/eh9kp86r">代码</a></p><p>这份代码太长了，在线编译会超时很久，在本机的texlive上也编译了两分钟之久。所以给各位编译后的一份pdf放在这里~</p><p>链接：https://pan.baidu.com/s/1pI0axwIV8qI_UpeJl7_iRw</p><p>提取码：ele7</p>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Others </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>树上启发式合并</title>
      <link href="/2023/05/09/%E6%A0%91%E4%B8%8A%E5%90%AF%E5%8F%91%E5%BC%8F%E5%90%88%E5%B9%B6/"/>
      <url>/2023/05/09/%E6%A0%91%E4%B8%8A%E5%90%AF%E5%8F%91%E5%BC%8F%E5%90%88%E5%B9%B6/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>本文收录于洛谷日报，原文初稿于2018-04-07，经过修改搬运过来。</p><hr /><h2 id="启发式算法">启发式算法</h2><p>启发式算法是基于人类的经验和直观感觉，对一些算法的优化。</p><p>比较常见的例子是并查集的按秩合并，有带按秩合并的并查集中，合并的代码是这样的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> xx=<span class="built_in">find</span>(x),yy=<span class="built_in">find</span>(y);</span><br><span class="line">    <span class="keyword">if</span>(size[xx]&lt;size[yy])<span class="built_in">swap</span>(xx,yy);</span><br><span class="line">    fa[yy]=xx;size[xx]+=size[yy];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里，对于两个大小不一样的集合，我们将大小小的并到大的，而不是大的连接小的。</p><p>为什么呢？这个集合的大小可以认为是集合的高度（在正常情况下），而我们将集合高度小的并到高度大的显然有助于我们找到父亲</p><p>让高度小的树成为高度较大的树的子树，这个优化可以称为启发式合并算法。</p><h2 id="原理">原理</h2><p>树上启发式合并（ <span class="math inline">\(\text{dsu on tree}\)</span> ，静态链分治）对于某些树上离线问题可以速度大于等于大部分算法且更易于理解和实现的算法。</p><p>考虑下面的问题：</p><p>给出一棵树，每个节点有颜色，询问一些子树的颜色数量（颜色可重复）。</p><p>提供一个仅供验证算法正确性的模板题<a href="https://www.luogu.org/problemnew/show/U41492">树上数颜色</a>，数据纯随机，仅用于验证算法正确性。</p><p><img src="https://cdn.luogu.com.cn/upload/pic/24620.png" /></p><p>对于这种问题解决方式大多是运用大量的数据结构（树套树等），如果可以离线，或询问的量巨大，是不是有更简单的方法？</p><p>很容易想到树上莫队，但是树上启发式合并可以在预处理 <span class="math inline">\(\mathrm{O}(n\log n)\)</span> 的时间复杂度解决这个问题。</p><p>既然支持离线，考虑预处理后 <span class="math inline">\(\mathrm{O}(1)\)</span> 输出答案。</p><p>直接暴力预处理的时间复杂度为<span class="math inline">\(\mathrm{O}(n^2)\)</span>，即对每一个子节点进行一次遍历，每次遍历的复杂度显然与<span class="math inline">\(n\)</span>同阶，有<span class="math inline">\(n\)</span>个节点，故复杂度为<span class="math inline">\(O(n^2)\)</span></p><p>可以发现，每个节点的答案是其子树的叠加，考虑利用这个性质处理问题</p><p>我们可以先预处理出每个节点子树的size和它的重儿子，重儿子同树链剖分一样，是拥有节点最多子树的儿子，这个过程显然可以 <span class="math inline">\(\mathrm{O}(n)\)</span> 完成</p><p>我们用一个数组 check 表示颜色 <span class="math inline">\(i\)</span> 有没有出现过，另一个数组 ans 表示他的颜色个数（即答案）</p><p>遍历一个节点，我们按以下的步骤进行遍历：</p><ul><li><p>先遍历其非重儿子，获取它的 ans，但<strong>不保留遍历后它的check</strong></p></li><li><p>遍历它的重儿子，<strong>保留它的check</strong></p></li><li><p>再次遍历其非重儿子及其父亲，用重儿子的check对遍历到的节点进行计算，获取整棵子树的ans</p></li></ul><p><img src="https://cdn.luogu.com.cn/upload/pic/31537.png" /></p><p><em>上图是一个例子</em></p><p>这样，对于一个节点，我们遍历了一次重子树，两次非重子树，显然是最划算的。</p><p>经过这个过程，我们获得了这个节点的子树的所有 ans</p><p>为什么不合并第一步和第三步呢？因为 check 数组不能重复使用，否则空间会太大，需要在 <span class="math inline">\(O(n)\)</span> 的空间内完成。</p><p>显然若一个节点 <span class="math inline">\(u\)</span> 被遍历了 <span class="math inline">\(x\)</span> 次，则其重儿子会被遍历 <span class="math inline">\(x\)</span> 次，轻儿子（如果有的话）会被遍历 <span class="math inline">\(2x\)</span> 次。</p><p>注意除了重儿子，每次遍历完 check 数组要清零。</p><h2 id="复杂度">复杂度</h2><p>（对于不关心复杂度证明的，可以跳过不看）</p><p>我们像树链剖分一样定义重边和轻边（连向重儿子的为重边，其余为轻边）关于重儿子和重边的定义，可以见下图，对于一棵有n个节点的树：</p><p>根节点到树上任意节点的轻边数不超过 <span class="math inline">\(\log n\)</span> 条。我们设根到该节点有x条轻边该节点的子树大小为y，显然轻边连接的子节点的子树大小小于父亲的一半（若大于一半就不是轻边了），则</p><p><span class="math display">\[y&lt;\frac{n}{2^x} \]</span></p><p>显然有 <span class="math inline">\(n&gt;2^x\)</span>，所以 $x&lt;n $。</p><p>又因为如果一个节点是其父亲的重儿子，则他的子树必定在他的兄弟之中最多，所以任意节点到根的路径上所有重边连接的父节点在计算答案是必定不会遍历到这个节点，所以一个节点的被遍历的次数等于他到根节点路径上的轻边数，所以一个节点的被遍历次数为 <span class="math inline">\(\log n\)</span> ,总时间复杂度则为 <span class="math inline">\(\mathrm{O}(n\log n)\)</span>，统计答案花费 <span class="math inline">\(\mathrm{O}(m)\)</span>.</p><p><img src="https://cdn.luogu.com.cn/upload/pic/24909.png" /></p><p><em>图中标红的即为重边，重边连向的子节点为重儿子</em></p><h2 id="大致代码">大致代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn=<span class="number">100010</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> to,nxt;</span><br><span class="line">&#125;t[maxn];<span class="type">int</span> head[maxn],tot=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">addedge</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    t[++tot].to=y;</span><br><span class="line">    t[tot].nxt=head[x];</span><br><span class="line">    head[x]=tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> c[maxn],size[maxn],son[maxn],cnt[maxn],ans[maxn];</span><br><span class="line"><span class="comment">//  color   size       重儿子    计数器  </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> fa)</span></span>&#123;</span><br><span class="line">    size[x]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=head[x];i;i=t[i].nxt)&#123;</span><br><span class="line">        <span class="type">int</span> to=t[i].to;</span><br><span class="line">        <span class="keyword">if</span>(to!=fa)&#123;</span><br><span class="line">            <span class="built_in">dfs1</span>(to,x);</span><br><span class="line">            size[x]+=size[to];</span><br><span class="line">            <span class="keyword">if</span>(size[to]&gt;size[son[x]])</span><br><span class="line">                son[x]=to;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//                    重儿子    保留答案</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa,<span class="type">int</span> isson,<span class="type">int</span> keep)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(keep)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=head[u];i;i=t[i].nxt)&#123;</span><br><span class="line">            <span class="type">int</span> to=t[i].to;</span><br><span class="line">            <span class="keyword">if</span>(to!=fa&amp;&amp;to!=son[u])&#123;</span><br><span class="line">                <span class="built_in">dfs2</span>(to,u,<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> tmp=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(!keep&amp;&amp;son[u])tmp+=<span class="built_in">dfs2</span>(son[u],u,<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(son[u]) tmp+=<span class="built_in">dfs2</span>(son[u],u,<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=head[u];i;i=t[i].nxt)&#123;</span><br><span class="line">        <span class="type">int</span> v=t[i].to;</span><br><span class="line">        <span class="keyword">if</span>(v!=fa&amp;&amp;v!=son[u])&#123;</span><br><span class="line">            tmp+=<span class="built_in">dfs2</span>(v,u,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!cnt[c[u]])&#123;</span><br><span class="line">        tmp++;</span><br><span class="line">    &#125;</span><br><span class="line">    cnt[c[u]]++;</span><br><span class="line">    <span class="keyword">if</span>(keep)ans[u]=tmp;</span><br><span class="line">    <span class="keyword">if</span>(keep&amp;&amp;!isson) <span class="built_in">memset</span>(cnt,<span class="number">0</span>,<span class="built_in">sizeof</span>(cnt));</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="type">int</span> x,y;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;x,&amp;y);</span><br><span class="line">        <span class="built_in">addedge</span>(x,y);</span><br><span class="line">        <span class="built_in">addedge</span>(y,x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;c[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs1</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">dfs2</span>(<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="type">int</span> m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;m);</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        cin&gt;&gt;x;</span><br><span class="line">        cout&lt;&lt;ans[x]&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用场合">使用场合</h2><p>树上启发式合并普遍运用于求解子树答案的静态问题。只要你能维护一个集合，这个集合支持在一定的时间复杂度 <span class="math inline">\(f(n)\)</span> 内插入元素和查询集合内所有元素的<strong>答案</strong>（在数颜色中，就是支持 $(1) $ 的插入和询问颜色个数，即答案），那这个问题就可以在 <span class="math inline">\(\mathrm{O}(n\log n \times f(n))\)</span> 内计算每个子树的答案。</p><p>例如<a href="https://codeforces.com/gym/104025/problem/M">北京理工大学 第 16 届“连山科技”程序设计大赛（November 7, 2022）M题</a>，给定一个树，离线询问子树内互质对个数。发现这个插入一个数并统计当前集合互质对个数是可以用莫反 <span class="math inline">\(\log n\)</span> 计算的，因此可以树上启发式合并套莫反在 <span class="math inline">\(\mathrm{O}(n\log^2 n)\)</span> 内解决。</p><p>当然也可以求解一些特殊的链上问题，如<a href="http://codeforces.com/problemset/problem/741/D">CF741D</a>，给一棵树，每个节点的权值是'a'到'v'的字母，每次询问要求在一个子树找一条路径，使该路径包含的字符排序后成为回文串。</p><p>因为是排列后成为回文串，所以一个字符出现了两次相当于没出现，也就是说，这条路径满足<strong>最多有一个字符出现奇数次</strong></p><p>正常做法是对每一个节点dfs，每到一个节点就强行枚举所有字母找到和他异或后结果为1的个数&lt;1的路径，再取最长值，这样 <span class="math inline">\(\mathrm{O}(n^2 \mathrm{log} n)\)</span>的，可以用树上启发式合并优化到 <span class="math inline">\(\mathrm{O}(n\log^2 n)\)</span> .关于具体做法，可以参考下面的扩展阅读。</p><h2 id="练习题">练习题</h2><p><a href="http://codeforces.com/problemset/problem/600/E">CF600E Lomsat gelral</a></p><p>题意翻译：树的节点有颜色，一种颜色占领了一个子树，当且仅当没有其他颜色在这个子树中出现得比它多。求占领每个子树的所有颜色之和。</p><p><a href="http://uoj.ac/problem/284">UOJ284 快乐游戏鸡</a></p><h2 id="参考资料扩展阅读">参考资料/扩展阅读</h2><p><a href="http://codeforces.com/blog/entry/44351">CF741D作者介绍的dsu on tree</a></p><p><a href="http://codeforces.com/blog/entry/48871">这位作者的题解</a></p>]]></content>
      
      
      <categories>
          
          <category> 算法竞赛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树上问题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高等数学（下）第七章教材补充与习题选</title>
      <link href="/2023/05/09/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%EF%BC%88%E4%B8%8B%EF%BC%89%E7%AC%AC%E4%B8%83%E7%AB%A0%E6%95%99%E6%9D%90%E8%A1%A5%E5%85%85%E4%B8%8E%E4%B9%A0%E9%A2%98%E9%80%89/"/>
      <url>/2023/05/09/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%EF%BC%88%E4%B8%8B%EF%BC%89%E7%AC%AC%E4%B8%83%E7%AB%A0%E6%95%99%E6%9D%90%E8%A1%A5%E5%85%85%E4%B8%8E%E4%B9%A0%E9%A2%98%E9%80%89/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>本文是大一的数学笔记，搬运过来并顺便测试 <span class="math inline">\(latex\)</span> 渲染效果。</p><p>参考教科书是《高等数学（下册）》，华南理工大学数学系，高等教育出版社。</p><h2 id="第一节-多元函数">第一节 多元函数</h2><p><span class="math display">\[\text{7.1.1. 讨论} \mathop{\lim}\limits_{x\rightarrow 0\atop y\rightarrow0} \frac{x^3y}{x^6+y^2} \text{是否存在.}\]</span></p><p>证明这种题常用 <span class="math inline">\(y=kx\)</span> 一类的代换使得从不同方向逼近一个不同极限来证明该极限不存在.</p><p>为了使得得出的表达式与趋于0的 <span class="math inline">\(x,y\)</span> 无关，可以取 <span class="math inline">\(y=kx^3\)</span> ，从而 <span class="math inline">\(\text{原式}=\mathop{\lim}\limits_{x\rightarrow 0\atop y\rightarrow0} \frac{kx^6}{x^6+k^2x^6}=\frac{k}{1+k^2}\)</span> ，该式与 <span class="math inline">\(k\)</span> 有关，所以极限不存在.</p><p><span class="math display">\[\text{7.1.2.讨论极限} \mathop{\lim}\limits_{x\rightarrow 0\atop y\rightarrow0 }\frac{x^2y^2}{x^4+y^4}\]</span></p><p>另外介绍一种课本未提到的方法：利用极坐标转换计算极限相关问题，即作代换 <span class="math inline">\(x=r\cos \theta , y= r\sin \theta\)</span>，则原来的趋近条件变成 $r0 $ ，这也是符合甚至直观上更符合多元函数的极限定义的（一个点的任意小邻域）。</p><p>利用以上代换，原式变为 <span class="math inline">\(\frac{r^2}{r^4(\cos^4 \theta+\sin^4 \theta)}\)</span>，约去 <span class="math inline">\(r^2\)</span> 后得到极限不存在的结论。</p><p><span class="math display">\[\text{7.1.3 讨论极限} \mathop{\lim}\limits_{x\rightarrow 0\atop y\rightarrow0 } \frac{\sqrt{x^2+y^2}-\sin \sqrt{x^2+y^2}}{(x^2+y^2)^\frac{3}{2} }\]</span></p><p>利用以上方法，得到 <span class="math inline">\(\text{原式}=\frac{r-\sin r}{r^3}\)</span> ，洛必达三次得到该极限为 <span class="math inline">\(\frac{1}{6}\)</span>.</p><h2 id="第二节-偏导数">第二节 偏导数</h2><p>要注意对于多元函数的偏导数而言，<span class="math inline">\(\frac{\partial x}{\partial z}\)</span> 一类将分子分母拆开没有意义的。</p><p>定理：若函数 <span class="math inline">\(z=f(x,y)\)</span> 的两个二阶混合偏导数 <span class="math inline">\(\frac{\partial ^2z}{\partial x\partial y},\frac{\partial ^2z}{\partial y\partial x}\)</span> 在区域 <span class="math inline">\(D\)</span> 内连续，则在该区域内两个混合偏导数相等，即</p><p><span class="math display">\[\frac{\partial ^2z}{\partial x\partial y}=\frac{\partial ^2z}{\partial y\partial x}\]</span></p><p>参考教科书没有给出证明，这里补充一个：</p><p>考虑表达式：</p><p><span class="math display">\[W=\frac{f(x+\Delta x,y+\Delta y)-f(x+\Delta x,y)-f(x,y+\Delta y)+f(x,y)}{\Delta x\Delta y}\]</span></p><p>其中 <span class="math inline">\(\Delta x,\Delta y\neq 0\)</span> 且充分小。</p><p>引入函数：</p><p><span class="math display">\[\phi(x,y)=f(x,y+\Delta y)-f(x,y) \qquad (1)\]</span></p><p>则</p><p><span class="math display">\[W=\frac{\phi(x+\Delta x,y)-\phi(x,y)}{\Delta x\Delta y}\]</span></p><p>视 <span class="math inline">\(y\)</span> 为常量，利用拉格朗日中值定理，有</p><p><span class="math display">\[\phi(x+\Delta x,y)-\phi(x,y)=\phi_x(x+\theta_1\Delta x,y)\Delta x\]</span></p><p>与此同时，对 <span class="math inline">\((1)\)</span> 式求导，得到</p><p><span class="math display">\[\phi_x(x+\theta_1 \Delta x,y)=f_x(x+\theta_1\Delta x,y+\Delta y)-f_x(x+\theta_1\Delta x,y)\]</span></p><p>由于<strong>偏导数连续</strong>，因此将 <span class="math inline">\(x+\theta_1\Delta x\)</span> 视为常量，对等式右边再利用一次拉格朗日中值定理，得到：</p><p><span class="math display">\[f_x(x+\theta_1\Delta x,y+\Delta y)-f_x(x+\theta_1\Delta x,y)=f_x(x+\theta_1\Delta x,y+\theta_2\Delta y)\Delta y\]</span></p><p>由以上推导，得到 <span class="math inline">\(W=f_{xy}(x+\theta_1\Delta x,y+\theta_2\Delta y)\)</span></p><p>类似地，如果我们将 <span class="math inline">\((1)\)</span> 式改成</p><p><span class="math display">\[\psi(x,y)=f(x+\Delta x,y)-f(x,y)\]</span></p><p>再做类似的步骤，可以得到 <span class="math inline">\(W=f_{yx}(x+\theta_3\Delta x,y+\theta_4\Delta y)\)</span></p><p>因此有</p><p><span class="math display">\[f_{xy}(x+\theta_1\Delta x,y+\theta_2\Delta y)=W=f_{yx}(x+\theta_3\Delta x,y+\theta_4\Delta y)\]</span></p><p>令 <span class="math inline">\(\Delta x\rightarrow0,\Delta y\rightarrow0\)</span>，得到</p><p><span class="math display">\[f_{xy}(x,y)=f_{yx}(x,y)\]</span></p><p>此即为待证式，证毕。</p><p>值得一提的是，这个证明与下一章可微分的充分条件（见下）的证明异曲同工。都是利用拉格朗日中值定理变换出需要的偏导数形式，而因为使用了中值定理，所以都要求函数连续。同时这两个定理的条件都是充分不必要条件，很有对称美。</p><blockquote><p>如果函数 <span class="math inline">\(z=f(x,y)\)</span> 的两个偏导数在 <span class="math inline">\((x_0,y_0)\)</span> 存在且连续，则该函数在 <span class="math inline">\((x_0,y_0)\)</span> 可微。</p></blockquote><p>若在这里也贴上证明会更好，但是课本已有，篇幅所限就不贴了。</p><h2 id="第三节-全微分及其应用">第三节 全微分及其应用</h2><p>必要条件：</p><p>若 <span class="math inline">\(z\)</span> 在 <span class="math inline">\((x_0,y_0)\)</span> 可微 ，则</p><p><span class="math inline">\(z\)</span> 在 <span class="math inline">\((x_0,y_0)\)</span> 连续，偏导数存在，且满足：</p><p><span class="math display">\[\mathrm{d}z \biggr |_{(x_0,y_0)}=\frac{\partial z}{\partial x}\biggr |_{(x_0,y_0)}\cdot \Delta x+\frac{\partial z}{\partial y}\biggr |_{(x_0,y_0)}\cdot \Delta y\]</span></p><p>注意，使用该公式前需要证明可微。</p><p>充分条件：</p><p>若 <span class="math inline">\(z\)</span> 在 <span class="math inline">\((x_0,y_0)\)</span> 处的偏导数存在且连续，则 <span class="math inline">\(z\)</span> 在 <span class="math inline">\((x_0,y_0)\)</span> 可微。</p><p>要注意，以上都<strong>不是充分必要条件</strong>。</p><p>经典例题：</p><p><span class="math display">\[7.3.1.\text{设函数 } f(x,y)=(x^2+y^2)\sin\frac{1}{x^2+y^2}(x^2+y^2\neq 0),0(x^2+y^2=0)\]</span></p><p><span class="math display">\[\text{证明：（1）}f(x,y) \text{ 在 } (0,0) \text{可微. （2） }f_x(x,y),f_y(x,y) \text{ 在 }(0,0) \text{不连续.} \]</span></p><p>（1）容易知道 $ f_x(0,0) = f_y(0,0) = 0 $, 从而</p><p><span class="math display">\[\Delta f=f(0+\Delta x,0+\Delta y)-f(0,0)=((\Delta x)^2+(\Delta y)^2)\sin \frac{1}{x^2+y^2}\]</span></p><p>因为有 <span class="math inline">\(\rho = (\Delta x)^2+(\Delta y)^2\)</span>,</p><p><span class="math display">\[\Delta f=\frac{((\Delta x)^2+(\Delta y)^2)\sin \frac{1}{x^2+y^2}}{\sqrt{(\Delta x)^2+(\Delta y)^2}}=\rho\sin\frac{1}{\rho ^2}\rightarrow0 (\rho\rightarrow0)\]</span></p><p>此即全微分定义. 故可微.</p><p>（2）当 <span class="math inline">\((x,y)\neq (0,0)\)</span> 时，有</p><p><span class="math display">\[f_x(x,y)=2x\sin\frac{1}{x^2+y^2}-\frac{2x}{(x^2+y^2)}\cos\frac{1}{x^2+y^2}\]</span></p><p><span class="math display">\[f_y(x,y)=2y\sin\frac{1}{x^2+y^2}-\frac{2y}{(x^2+y^2)}\cos\frac{1}{x^2+y^2}\]</span></p><p><span class="math display">\[f_x(x,0)=2x\sin\frac{1}{x^2}-\frac{2}{x}\cos\frac{1}{x^2}\]</span></p><p>可以看出偏导数在 <span class="math inline">\((0,0)\)</span> 不存在，故不连续.</p><p>这是第三个结论，“充分条件”的一个反例.</p><p><span class="math display">\[7.3.3. \text{证明：}f(x,y)=\sqrt{|xy|}\text{在}(0,0)\text{处不可微.}\]</span></p><p>利用定义：</p><blockquote><p>若 函数 <span class="math inline">\(f(x,y)\)</span> 在点 <span class="math inline">\(P_0(x_0,y_0)\)</span> 处的全增量</p></blockquote><blockquote><p><span class="math display">\[ \Delta z=f(x_0+\Delta x,y_0+\Delta y)-f(x_0,y_0)\quad(1)\]</span></p></blockquote><blockquote><p>可以表示为</p></blockquote><blockquote><p><span class="math display">\[\Delta z=A\Delta x+B\Delta y+o(\rho) \quad(2)\]</span></p></blockquote><blockquote><p>其中 <span class="math inline">\(A,B\)</span> 只和点 <span class="math inline">\((x_0,y_0)\)</span> 有关，而与 <span class="math inline">\(\Delta x,\Delta y\)</span> 无关，<span class="math inline">\(\rho = \sqrt{(\Delta x)^2+(\Delta y)^2}\)</span>，则该函数在 <span class="math inline">\(P_0\)</span> 可微，且 <span class="math inline">\(A\Delta x+B\Delta y\)</span> 为其在该点的全微分。</p></blockquote><p>那么利用 <span class="math inline">\(\Delta z-\Delta z=f(x_0+\Delta x,y_0+\Delta y)-f(x_0,y_0)-A\Delta x-B\Delta y\)</span> 得到 <span class="math inline">\(o(\rho)\)</span> ，再除以 <span class="math inline">\(\rho\)</span> ，得出的结果为 <span class="math inline">\(0\)</span> 则说明确实是无穷小，不为0则不可微。</p><p><span class="math display">\[\mathop{\lim}\limits_{\Delta x\rightarrow 0\atop \Delta y\rightarrow0 }\frac{[f(0+\Delta x,0+\Delta y)-f(0,0)]-[f_x(0,0)\Delta x+f_y(0,0)\Delta y]}{\sqrt{(\Delta x)^2+(\Delta y)^2}}=\mathop{\lim}\limits_{\Delta x\rightarrow 0\atop \Delta y\rightarrow0 }\frac{\sqrt{|\Delta x\Delta y|}}{\sqrt{(\Delta x)^2+(\Delta y)^2}}\]</span></p><p>不存在。故不可微。</p><p>一般证明可微或不可微的步骤：</p><p>1.先求出偏导数 <span class="math inline">\(f_x(x_0,y_0),f_y(x_0,y_0)\)</span>，若不存在则不可微</p><p>2.计算 <span class="math inline">\(\Delta z=f(0+\Delta x,0+\Delta y)-f(0,0)\)</span> 的存在性，若不存在则不可微。</p><p>3.计算 <span class="math inline">\(\frac{f(x_0+\Delta x,y_0+\Delta y)-f(x_0,y_0)-f_x(x_0,y_0)\Delta x-f_y(x_0,y_0)\Delta y}{\sqrt{(\Delta x)^2+(\Delta y)^2}}\)</span> ，若等于 <span class="math inline">\(0\)</span> 则可微。</p><p>判断是否为 <span class="math inline">\(0\)</span> 常用找一条路径 <span class="math inline">\(\Delta y=k(\Delta x)^a\)</span>，使得沿这条路径的极限不为0或不存在。</p><p>补充一张互相推导的图：</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/3aor39uf.png" /></p><p><span class="math display">\[7.3.2\quad u=f(x,y),g(x,y,z)=0,h(x,z)=0, \text{求}\frac{\mathrm{d}u}{\mathrm dx}\]</span></p><p>由全微分形式不变性，两边微分可得</p><p><span class="math display">\[\mathrm{d}u=f_x\mathrm{d}x+f_y\mathrm{d}y\]</span></p><p><span class="math display">\[g_x\mathrm dx+g_y\mathrm dy+g_z\mathrm{d}z=0\]</span></p><p><span class="math display">\[h_x\mathrm d x+h_z\mathrm{d}z=0\]</span></p><p>由二式解出 <span class="math inline">\(\mathrm d y\)</span> 关于 <span class="math inline">\(\mathrm dx,\mathrm dz\)</span> 的表达式</p><p>由三式解出 <span class="math inline">\(\mathrm d z\)</span> 关于 <span class="math inline">\(\mathrm dx\)</span> 的表达式</p><p>代入一式得 <span class="math inline">\(\frac{\mathrm{d}u}{\mathrm dx}=f_x-\frac{f_yg_x}{g_y}+\frac{f_yg_zh_x}{g_yh_z}\)</span></p><h2 id="第四节-多元复合函数的求导法则">第四节 多元复合函数的求导法则</h2><p><span class="math display">\[ 7.4.2\quad  \text{已知 }e^{-xy}-2z+e^z=0,\text{求} \frac{\partial z}{\partial x},\frac{\partial z}{\partial  y}\]</span></p><p><span class="math display">\[\mathrm{d}(e^{-xy}-2z+e^z)=0\]</span></p><p><span class="math display">\[e^{-xy}\mathrm{d}(-xy)-2z\mathrm{d}z+e^z\mathrm{d}z=0\]</span></p><p><span class="math display">\[(e^z-2)\mathrm{d}z=e^{-xy}(x\mathrm{d}y+y\mathrm{d}x)\]</span></p><p>利用全微分的形式不变性，得到</p><p><span class="math display">\[\mathrm{d}z=\frac{ye^{-xy}}{(e^z-2)}\mathrm{d}x+\frac{xe^{-xy}}{(e^z-2)}\mathrm{d}y\]</span></p><p>从而</p><p><span class="math display">\[\frac{\partial z}{\partial x}=\frac{ye^{-xy}}{(e^z-2)},\frac{\partial z}{\partial  y}=\frac{xe^{-xy}}{(e^z-2)}\]</span></p><p>利用下一节介绍的隐函数求导法也可以得到这一结果：</p><p><span class="math display">\[F=e^{-xy}-2z+e^z=0\]</span></p><p><span class="math display">\[F_x=-ye^{-xy}\]</span></p><p><span class="math display">\[F_y=-xe^{-xy}\]</span></p><p><span class="math display">\[F_z=-2+e^z\]</span></p><p><span class="math display">\[\frac{\partial z}{\partial x}=\frac{F_x}{F_z}=\frac{ye^{-xy}}{(e^z-2)},\frac{\partial z}{\partial  y}=\frac{F_y}{F_z}=\frac{xe^{-xy}}{(e^z-2)}\]</span></p><p><span class="math display">\[7.4.3\quad \text{设 } f(x,y) \text{ 是 } k \text{ 次齐次函数，即 }f(tx,ty,tz)=t^kf(x,y,z),\lambda \text{为某一常数，则下列结论正确的是：}\]</span></p><p><span class="math display">\[(A)x\frac{\partial f}{\partial x}+y\frac{\partial f}{\partial v}+z\frac{\partial f}{\partial z}=k^\lambda f(x,y,z)\]</span></p><p><span class="math display">\[(B)x\frac{\partial f}{\partial x}+y\frac{\partial f}{\partial v}+z\frac{\partial f}{\partial z}=\lambda^k f(x,y,z)\]</span></p><p><span class="math display">\[(C)x\frac{\partial f}{\partial x}+y\frac{\partial f}{\partial v}+z\frac{\partial f}{\partial z}=kf(x,y,z)\]</span></p><p><span class="math display">\[(D)x\frac{\partial f}{\partial x}+y\frac{\partial f}{\partial v}+z\frac{\partial f}{\partial z}= f(x,y,z)\]</span></p><p>令 <span class="math inline">\(u=tx,v=ty,w=tz\)</span> ，则 <span class="math inline">\(f(u,v,w)=t^kf(x,y,z)\)</span></p><p>两边对 <span class="math inline">\(t\)</span> 求导，得</p><p><span class="math display">\[\frac{\partial f}{\partial u}\cdot\frac{\partial u}{\partial t}+\frac{\partial f}{\partial v}\cdot\frac{\partial v}{\partial t}+\frac{\partial f}{\partial w}\cdot\frac{\partial w}{\partial t}=kt^{k-1}f(x,y,z)\]</span></p><p>即</p><p><span class="math display">\[\frac{\partial f}{\partial u}\cdot x+\frac{\partial f}{\partial v}\cdot y+\frac{\partial f}{\partial w}\cdot z=kt^{k-1}f(x,y,z)\]</span></p><p>两边同乘 <span class="math inline">\(t\)</span> ，得：</p><p><span class="math display">\[\frac{\partial f}{\partial u}\cdot u+\frac{\partial f}{\partial v}\cdot v+\frac{\partial f}{\partial w}\cdot w=kt^{k}f(x,y,z)=kf(u,v,w)\]</span></p><p>故选 <span class="math inline">\(C\)</span>.</p><p><span class="math display">\[7.4.4. \quad x=e^u\cos v,y=e^u\sin v,z=uv,\text{ 求 }\frac{\partial z}{\partial x},\frac{\partial z}{\partial y}\]</span></p><p><span class="math display">\[\frac{\partial z}{\partial x}=\frac{\partial z}{\partial u}\cdot \frac{\partial u}{\partial x}+\frac{\partial z}{\partial v}\cdot \frac{\partial v}{\partial x}=v\cdot \frac{\partial u}{\partial x}+u\cdot \frac{\partial v}{\partial x}\]</span></p><p>对 $ x=e<sup>uv,y=e</sup>uv$ 对 <span class="math inline">\(x\)</span> 求偏导，得到</p><p><span class="math display">\[1=e^u\frac{\partial u}{\partial x}\cos v-e^u\sin v\frac{\partial v}{\partial x}\]</span></p><p><span class="math display">\[0=e^u\frac{\partial u}{\partial x}\sin v+e^u\cos v\frac{\partial v}{\partial x}\]</span></p><p>解出 <span class="math inline">\(\frac{\partial u}{\partial x},\frac{\partial v}{\partial x}\)</span> ，代入公式即得 <span class="math inline">\(\frac{\partial z}{\partial x}\)</span>，<span class="math inline">\(\frac{\partial z}{\partial y}\)</span> 同理.</p><p><span class="math display">\[7.4.5.\text{设变换 }u=x-2y,v=x+ay \text{可以将方程 } 6\frac{\partial^2z}{\partial x^2}+\frac{\partial^2z}{\partial x\partial y}-\frac{\partial^2z}{\partial y^2}\text{ 简化为 }\frac{\partial^2z}{\partial u\partial v}=0, \text{求常数 }a\]</span></p><p><span class="math display">\[\frac{\partial z}{\partial x}=\frac{\partial z}{\partial u}\cdot \frac{\partial u}{\partial x}+\frac{\partial z}{\partial v}\cdot \frac{\partial v}{\partial x}=\frac{\partial z}{\partial u}+\frac{\partial z}{\partial v}\]</span></p><p><span class="math display">\[\frac{\partial z}{\partial y}=-2\frac{\partial z}{\partial u}+a\frac{\partial z}{\partial v}\]</span></p><p><span class="math display">\[\frac{\partial^2 z}{\partial x\partial y}=\frac{\partial^2 z}{\partial u^2}\cdot\frac{\partial u}{\partial y}+\frac{\partial^2 z}{\partial u\partial v}\cdot\frac{\partial u}{\partial y}+\frac{\partial^2 z}{\partial u\partial v}\cdot\frac{\partial v}{\partial y}+\frac{\partial^2 z}{\partial v^2}\cdot\frac{\partial v}{\partial y}\]</span></p><p><span class="math display">\[\frac{\partial^2 z}{\partial x\partial y}=-2\frac{\partial^2 z}{\partial u^2}-2\frac{\partial^2 z}{\partial v\partial u}+a\frac{\partial^2 z}{\partial u\partial v}+a\frac{\partial^2 z}{\partial v^2}\]</span></p><p><span class="math display">\[\frac{\partial^2 z}{\partial x^2}=\frac{\partial^2 z}{\partial u^2}+\frac{\partial^2 z}{\partial u\partial v}+\frac{\partial^2 z}{\partial v\partial u}+\frac{\partial^2 z}{\partial v^2}\]</span></p><p><span class="math display">\[\frac{\partial^2 z}{\partial y^2}=4\frac{\partial^2 z}{\partial u^2}-2a\frac{\partial^2 z}{\partial u\partial v}-2a\frac{\partial^2 z}{\partial v\partial u}+a^2\frac{\partial^2 z}{\partial v^2}\]</span></p><p>根据题设，合并同类项，得到 <span class="math inline">\(6+a-a^2=0,10+5a\neq 0\)</span> ，即<span class="math inline">\(a=3.\)</span></p><h2 id="第五节-隐函数求导法">第五节 隐函数求导法</h2><p>隐函数存在定理：</p><blockquote><p>设二元函数 <span class="math inline">\(F(x,y)\)</span> 在点 <span class="math inline">\(P(x_0,y_0)\)</span> 的某一邻域内满足：</p></blockquote><blockquote><p>(1)具有连续偏导数</p></blockquote><blockquote><p>(2)<span class="math inline">\(F(x_0,y_0)=0\)</span></p></blockquote><blockquote><p>(3)<span class="math inline">\(F_y(x_0,y_0)=0\)</span></p></blockquote><blockquote><p>则 函数 <span class="math inline">\(F(x,y)\)</span> 在点 <span class="math inline">\(P(x_0,y_0)\)</span> 的某一邻域 的某一邻域内恒能唯一确定一个具有连续导数的函数 <span class="math inline">\(y=f(x)\)</span> ，它满足 <span class="math inline">\(y_0=f(x_0)\)</span> ，并有 <span class="math inline">\(-\frac{F_x(x,y)}{F_y(x,y)}\)</span></p></blockquote><p>多元函数的情况是类似的。</p><p>本书对证明不做要求 <del>，这里补充一个证明：</del> ，但是他太长了，不写了。</p><p>推广到多元：</p><p><span class="math display">\[-\mathrm{d}z=\frac{F_{x_1}}{F_z}\mathrm{d}x_1+\frac{F_{x_2}}{F_z}\mathrm{d}x_2+\cdots+\frac{F_{x_n}}{F_z}\mathrm{d}x_n\]</span></p><p><span class="math display">\[7.5.1. \text{设函数 } f(x,y) \text{ 有连续偏导数，试用极坐标的转换公式 } x=r\cos \theta,y=r\sin \theta\text{ 将 } x\frac{\partial u}{\partial y}-y\frac{\partial u}{\partial x}\text{变化为}r,\theta\text{ 下的表达式.}\]</span></p><p>可以将 <span class="math inline">\(r,\theta\)</span> 视为自变量， <span class="math inline">\(x,y\)</span> 视为中间变量。也可以反过来将 <span class="math inline">\(x,y\)</span> 视为自变量，将 <span class="math inline">\(r,\theta\)</span> 视为中间变量，这两种视角都导出一种可行的解法。</p><p>法一，将 <span class="math inline">\(x,y\)</span> 视为中间变量</p><p>根据条件，有：</p><p><span class="math display">\[\frac{\partial x}{\partial \theta}=-r\sin\theta=-y,\frac{\partial y}{\partial \theta}=r\cos\theta=x\]</span></p><p><span class="math display">\[\frac{\partial u}{\partial \theta} =\frac{\partial u}{\partial x}\cdot\frac{\partial x}{\partial \theta}+\frac{\partial u}{\partial y}\cdot \frac{\partial y}{\partial \theta}=-(x\frac{\partial u}{\partial u}-y\frac{\partial u}{\partial x})\]</span></p><p>故</p><p><span class="math display">\[x\frac{\partial u}{\partial u}-y\frac{\partial u}{\partial x}=-\frac{\partial u}{\partial \theta}\]</span></p><h2 id="第六节-方向导数与梯度">第六节 方向导数与梯度</h2><p>方向导数存在的充分条件：</p><blockquote><p>如果函数 <span class="math inline">\(f(x,y)\)</span> 在 <span class="math inline">\(P_0(x_0,y_0)\)</span> 可微分，那么函数在该点沿任意方向 <span class="math inline">\(\boldsymbol{l}\)</span> 的方向导数存在，且有：</p></blockquote><blockquote><p><span class="math display">\[\frac{\partial f}{\partial \boldsymbol{l}}\Biggr |_{P_0}=f_x(x_0,y_0)\cos \alpha+f_y(x_0,y_0)\cos \beta\]</span></p></blockquote><blockquote><p>其中 <span class="math inline">\(\cos \alpha,\cos \beta\)</span> 是方向 <span class="math inline">\(\boldsymbol{l}\)</span> 的方向余弦.</p></blockquote><h2 id="第八节-多元函数的极值">第八节 多元函数的极值</h2><p><span class="math display">\[  7.8.1 \text{ 在第一卦限内作椭球面 }\frac{x^2}{a^2}+\frac{y^2}{b^2}+\frac{z^2}{c^2}=1 \text{ 的切平面使得该切平面与三个坐标平面围成的四面体的体积最小，求切点的坐标.} \]</span></p><p>设切点 <span class="math inline">\((x_0,y_0,z_0)\)</span> 可以得到法平面方程 <span class="math inline">\((x-x_0)\frac{x_0}{a^2}+(y-y_0)\frac{y_0}{b^2}+(z-z_0)\frac{z_0}{c^2}=0\)</span>，即</p><p><span class="math display">\[\frac{xx_0}{a^2}+\frac{yy_0}{b^2}+\frac{zz_0}{c^2}=1\]</span></p><p><span class="math display">\[V=\frac{a^2b^2c^2}{6x_0y_0z_0}\]</span></p><p>实际上就是求 <span class="math inline">\(V\)</span> 在 <span class="math inline">\(\frac{x^2}{a^2}+\frac{y^2}{b^2}+\frac{z^2}{c^2}=1\)</span> 条件下的最值。</p><p>但是 <span class="math inline">\(V\)</span> 太难求偏导了，改为求 <span class="math inline">\(x_0y_0z_0\)</span> 的最大值</p><p>于是设 <span class="math inline">\(F=xyz+\lambda(\frac{x^2}{a^2}+\frac{y^2}{b^2}+\frac{z^2}{c^2}-1)\)</span></p><p>但是这样 <span class="math inline">\(F_x\)</span> 和 <span class="math inline">\(x,y,z\)</span> 都相关，于是改设 <span class="math inline">\(F=\ln x+\ln y +\ln z+\lambda(\frac{x^2}{a^2}+\frac{y^2}{b^2}+\frac{z^2}{c^2}-1)\)</span></p><p>这样每个偏导数的表达式都只与其主元相关，大大方便了计算.</p><p>得到结果 <span class="math inline">\(x_0=\frac{a}{\sqrt 3},y_0=\frac{b}{\sqrt 3},z_0=\frac{c}{\sqrt 3}\)</span>.</p><p>最小二乘法：极值的运用。</p><p>对于多组样本点，找一条直线拟合使得偏差的平方和最小：</p><p>计偏差函数 <span class="math inline">\(M=\sum_{i=0}^t[y_i-(at_i+b)]\)</span></p><p><span class="math display">\[\frac{\partial M}{\partial a}=0,\frac{\partial M}{\partial b}=0\]</span></p><p>从而得到驻点：</p><p><span class="math display">\[a=\frac{n\sum_{i=1}^{n}x_iy_i-(\sum_{i=1}^{n}x_i)(\sum_{i=1}^{n}y_i)}{n\sum_{i=1}^{n}x_i^2-(\sum_{i=1}^{n}x_i)^2}\]</span></p>]]></content>
      
      
      <categories>
          
          <category> 课程笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> math </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WBLT：一种比较少见的平衡树</title>
      <link href="/2023/05/08/WBLT%EF%BC%9A%E4%B8%80%E7%A7%8D%E6%AF%94%E8%BE%83%E5%B0%91%E8%A7%81%E7%9A%84%E5%B9%B3%E8%A1%A1%E6%A0%91/"/>
      <url>/2023/05/08/WBLT%EF%BC%9A%E4%B8%80%E7%A7%8D%E6%AF%94%E8%BE%83%E5%B0%91%E8%A7%81%E7%9A%84%E5%B9%B3%E8%A1%A1%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>本文收录于2019年3月的洛谷日报，原文初稿于 2019-01-20.</p><hr /><p>WBLT 全称 <span class="math inline">\(\text{Weight Balanced Leafy Tree}\)</span>. 是一种常数较小，代码较简单的平衡树实现方式。</p><p>在看本文之前，推荐您先学习 treap 等平衡树 这篇文章对于有平衡树基础的人较为友好</p><h2 id="定义和引入">定义和引入</h2><p>WBLT是二叉搜索树的一种。不同的是，他同时是一个大根堆（也可以是小根堆），每个非叶节点都有两个儿子，且每个节点的权值与其右儿子的权值相同，且左儿子的权值小于右儿子的权值，左子树的所有节点的权值小于右子树任意节点的权值。</p><p>也就是说他大概长这样：</p><p><img src="https://cdn.luogu.com.cn/upload/pic/49109.png" /></p><p>这种设计有一个明显的缺点 就是如果要储存n个数据，普通的平衡树需要开n个节点，而WBLT需要开2n-1个</p><p>也就是说 储存上图的数据的treap长这样：</p><p><img src="https://cdn.luogu.com.cn/upload/pic/49110.png" /></p><p>那么 相比之下它有什么好处呢？</p><h2 id="旋转">旋转</h2><p>WBLT= Weight Balanced Tree（加权平衡树） + Leafy，其中Leafy已经在定义和引入中体现了，平衡是指一个节点的左子树和右子树大小近似相同，这样在查询/修改的时候才能做到近似log，旋转便是维护平衡的方便手段</p><p>因为其结构特殊 不需要像treap一样引入一个rand，只要旋转就可以维护其平衡。</p><p>先给出旋转的代码 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    size[++cnt]=size[l]+size[r];</span><br><span class="line">    val[cnt]=val[r];</span><br><span class="line">    ls[cnt]=l,rs[cnt]=r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">rotate</span><span class="params">(<span class="type">int</span> cur,<span class="type">bool</span> flag)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">        <span class="built_in">merge</span>(ls[cur],ls[rs[cur]]);</span><br><span class="line">        ls[cur]=cnt;</span><br><span class="line">        rs[cur]=rs[rs[cur]];</span><br><span class="line">    &#125;<span class="comment">//左旋</span></span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">merge</span>(rs[ls[cur]],rs[cur]);</span><br><span class="line">        rs[cur]=cnt;</span><br><span class="line">        ls[cur]=ls[ls[cur]];</span><br><span class="line">    &#125;<span class="comment">//右旋</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 再给出图例（节点上的数字为编号，数字颜色为红色则为新节点）： <img src="https://cdn.luogu.com.cn/upload/pic/49144.png" /> 可以发现，旋转后的WBLT仍然保持原来的性质。而且明显偏重的左子树转到了右边，左右子树相对平衡了。</p><h2 id="查询排名为x的数">查询排名为x的数</h2><p>我们记录每个节点的size，这个size不是子树的大小，而是子树储存的有效信息的大小。</p><p>因为有性质_储存n个数据要开2n-1个节点_，所以如果一个子树的大小为<span class="math inline">\(2x-1\)</span>，那它储存的数据量就有<span class="math inline">\(x\)</span>个。</p><p>接下来的操作就简单了，令find(cur,x)为寻找cur所在的子树下排名为x的数，那么当x比左子树的size小</p><p><span class="math inline">\(find(cur,x)=find(lson_{cur},x)\)</span></p><p>当x比左子树的size大</p><p>$find(cur,x)=find(rson_{cur},x-size_{lson_{cur}})</p><p>如果相等，那显然</p><p><span class="math inline">\(find(cur,x)=val_{cur}\)</span></p><p>因为当前要找的是第x大，那我无需遍历下面，这点也与treap不同</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> cur,<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(size[cur]==x)</span><br><span class="line">        <span class="keyword">return</span> val[cur];</span><br><span class="line">    <span class="keyword">if</span>(x&gt;size[ls[cur]])</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">find</span>(rs[cur],x-size[ls[cur]]);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">find</span>(ls[cur],x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="查询x的排名">查询x的排名</h2><p>同理，设rnk(cur,x)为寻找cur子树下x的排名</p><p>当x小于cur的左儿子的权值</p><p><span class="math inline">\(rnk(cur,x)=rnk(lson_{cur},x)\)</span></p><p>否则</p><p><span class="math inline">\(rnk(cur,x)=size_{lson_{cur}}+rnk(rson_{cur},x)\)</span></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">rnk</span><span class="params">(<span class="type">int</span> cur,<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(size[cur]==<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x&gt;val[ls[cur]])</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">rnk</span>(rs[cur],x)+size[ls[cur]];</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">rnk</span>(ls[cur],x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="插入">插入</h2><p>WBLT其他的操作都与treap类似，在每一步时：</p><blockquote><p>根据要添加的权值和当前搜索到的节点选择左右子树进行递归（如果比左儿子的权值大就去右子树，否则去左子树）</p></blockquote><blockquote><p>递归到最后一步到一个叶子节点时，根据其权值大小建立新节点，确定是该节点的左儿子还是右儿子</p></blockquote><blockquote><p>建立它的兄弟节点。</p></blockquote><blockquote><p>向上pushup（类似于线段树，儿子会影响父亲，这点于与treap不同）。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> cur,<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(size[cur]==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">newnode</span>(ls[cur],<span class="built_in">minn</span>(x,val[cur]));</span><br><span class="line">        <span class="built_in">newnode</span>(rs[cur],<span class="built_in">maxx</span>(x,val[cur]));</span><br><span class="line">        <span class="built_in">pushup</span>(cur);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">insert</span>(x&gt;val[ls[cur]]?rs[cur]:ls[cur],x);</span><br><span class="line">    <span class="built_in">pushup</span>(cur);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="删除">删除</h2><p>在每一步时：</p><blockquote><p>根据要删除权值和当前搜索到的节点选择左右子树进行递归（如果比左儿子的权值大就去右子树，否则去左子树）</p></blockquote><blockquote><p>递归到最后一步到一个叶子节点时，判断该节点是不是要删除的，如果不是则选择其兄弟节点，进行删除，将两个节点中保留的与其父亲节点进行替换</p></blockquote><blockquote><p>向上pushup。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">erase</span><span class="params">(<span class="type">int</span> cur,<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(size[cur]==<span class="number">1</span>)&#123;</span><br><span class="line">        cur= ls[fa]==cur?rs[fa]:ls[fa];</span><br><span class="line">        <span class="built_in">copynode</span>(fa,cur);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    fa=cur;</span><br><span class="line">    <span class="built_in">erase</span>(x&gt;val[ls[cur]]?rs[cur]:ls[cur],x);</span><br><span class="line">    <span class="built_in">pushup</span>(cur);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="旋转和p3369">旋转，和P3369</h2><p>等等 旋转呢？</p><p>我们在上文所有的操作中，似乎没有使用旋转，那旋转放在哪呢？</p><p>我们将其放在树的结构有改变的地方，也就是插入 删除这些操作中，每当一个子树过大，就进行相应的旋转，在插入和删除操作中加入以下函数即可</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> ratio=<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">maintain</span><span class="params">(<span class="type">int</span> cur)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(size[ls[cur]]&gt;size[rs[cur]]*ratio)</span><br><span class="line">        <span class="built_in">rotate</span>(cur,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(size[rs[cur]]&gt;size[ls[cur]]*ratio)</span><br><span class="line">        <span class="built_in">rotate</span>(cur,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么普通平衡树的代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn=<span class="number">400010</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> ratio=<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,cnt,fa,root;</span><br><span class="line"><span class="type">int</span> size[maxn],ls[maxn],rs[maxn],val[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">newnode</span><span class="params">(<span class="type">int</span> &amp;cur,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">    cur=++cnt;</span><br><span class="line">    size[cur]=<span class="number">1</span>;</span><br><span class="line">    val[cur]=v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">copynode</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    size[x]=size[y];</span><br><span class="line">    ls[x]=ls[y],rs[x]=rs[y];</span><br><span class="line">    val[x]=val[y];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    size[++cnt]=size[l]+size[r];</span><br><span class="line">    val[cnt]=val[r];</span><br><span class="line">    ls[cnt]=l,rs[cnt]=r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">rotate</span><span class="params">(<span class="type">int</span> cur,<span class="type">bool</span> flag)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">        <span class="built_in">merge</span>(ls[cur],ls[rs[cur]]);</span><br><span class="line">        ls[cur]=cnt;</span><br><span class="line">        rs[cur]=rs[rs[cur]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">merge</span>(rs[ls[cur]],rs[cur]);</span><br><span class="line">        rs[cur]=cnt;</span><br><span class="line">        ls[cur]=ls[ls[cur]];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">maintain</span><span class="params">(<span class="type">int</span> cur)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(size[ls[cur]]&gt;size[rs[cur]]*ratio)</span><br><span class="line">        <span class="built_in">rotate</span>(cur,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(size[rs[cur]]&gt;size[ls[cur]]*ratio)</span><br><span class="line">        <span class="built_in">rotate</span>(cur,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> cur)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!size[ls[cur]])<span class="keyword">return</span> ;</span><br><span class="line">    size[cur]=size[ls[cur]]+size[rs[cur]];</span><br><span class="line">    val[cur]=val[rs[cur]];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">minn</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a&lt;b?a:b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">maxx</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a&gt;b?a:b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> cur,<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(size[cur]==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">newnode</span>(ls[cur],<span class="built_in">minn</span>(x,val[cur]));</span><br><span class="line">        <span class="built_in">newnode</span>(rs[cur],<span class="built_in">maxx</span>(x,val[cur]));</span><br><span class="line">        <span class="built_in">pushup</span>(cur);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">maintain</span>(cur);</span><br><span class="line">    <span class="built_in">insert</span>(x&gt;val[ls[cur]]?rs[cur]:ls[cur],x);</span><br><span class="line">    <span class="built_in">pushup</span>(cur);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">erase</span><span class="params">(<span class="type">int</span> cur,<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(size[cur]==<span class="number">1</span>)&#123;</span><br><span class="line">        cur= ls[fa]==cur?rs[fa]:ls[fa];</span><br><span class="line">        <span class="built_in">copynode</span>(fa,cur);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">maintain</span>(cur);</span><br><span class="line">    fa=cur;</span><br><span class="line">    <span class="built_in">erase</span>(x&gt;val[ls[cur]]?rs[cur]:ls[cur],x);</span><br><span class="line">    <span class="built_in">pushup</span>(cur);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> cur,<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(size[cur]==x)</span><br><span class="line">        <span class="keyword">return</span> val[cur];</span><br><span class="line">    <span class="built_in">maintain</span>(cur);</span><br><span class="line">    <span class="keyword">if</span>(x&gt;size[ls[cur]])</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">find</span>(rs[cur],x-size[ls[cur]]);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">find</span>(ls[cur],x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">rnk</span><span class="params">(<span class="type">int</span> cur,<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(size[cur]==<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">maintain</span>(cur);</span><br><span class="line">    <span class="keyword">if</span>(x&gt;val[ls[cur]])</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">rnk</span>(rs[cur],x)+size[ls[cur]];</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">rnk</span>(ls[cur],x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="built_in">newnode</span>(root,(<span class="number">1</span>&lt;&lt;<span class="number">30</span>));</span><br><span class="line">    <span class="keyword">while</span>(n--)&#123;</span><br><span class="line">        <span class="type">int</span> s,x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;s,&amp;x);</span><br><span class="line">        <span class="keyword">if</span>(s==<span class="number">1</span>)<span class="built_in">insert</span>(root,x);</span><br><span class="line">        <span class="keyword">if</span>(s==<span class="number">2</span>)<span class="built_in">erase</span>(root,x);</span><br><span class="line">        <span class="keyword">if</span>(s==<span class="number">3</span>)<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">rnk</span>(root,x));</span><br><span class="line">        <span class="keyword">if</span>(s==<span class="number">4</span>)<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">find</span>(root,x));</span><br><span class="line">        <span class="keyword">if</span>(s==<span class="number">5</span>)<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">find</span>(root,<span class="built_in">rnk</span>(root,x)<span class="number">-1</span>));</span><br><span class="line">        <span class="keyword">if</span>(s==<span class="number">6</span>)<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">find</span>(root,<span class="built_in">rnk</span>(root,x+<span class="number">1</span>)));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下是评测记录</p><p><img src="https://cdn.luogu.com.cn/upload/pic/49195.png" /></p><p><em>上面的是treap，下面的是WBLT</em></p><p>我们发现，WBLT只比treap慢一点点，所以WBLT和treap几乎是一样块的~</p><h2 id="例题">例题</h2><h3 id="p1503-鬼子进村">P1503 鬼子进村</h3><p>平衡树部分是个裸题，其他倒还得想想</p><p>先把0和n+1插入，作为边界</p><p>摧毁节点就插入该点</p><p>删除上一个就维护个栈，删除栈顶即可</p><p>询问操作就查找前驱和后继，一减就行了，记得特判是否已经被摧毁（记个vis数组即可）</p><p><a href="https://www.luogu.org/paste/5isx0y4z">代码</a></p><h3 id="p2596-zjoi2006书架">P2596 [ZJOI2006]书架</h3><p>平衡树部分还是个裸题</p><p>定义优先级越小，那本书就放越上面</p><p>设<span class="math inline">\(a_i\)</span>为编号为<span class="math inline">\(i\)</span>的书本的优先级，<span class="math inline">\(mapp_i\)</span>为优先级为i的节点编号。</p><p>Top S:将优先级变为最小再插入</p><p>Bottom S：将优先级变为最大再插入</p><p>Insert S T：找到对应两本书 交换优先级</p><p>Ask S：查询优先级排名</p><p>Query S：查询第k小的优先级对应的编号</p><p>代码:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn=<span class="number">400010</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> ratio=<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">register</span> <span class="type">int</span> num=<span class="number">0</span>,flag=<span class="number">1</span>;<span class="type">char</span> ch;</span><br><span class="line">    <span class="keyword">while</span>((ch=<span class="built_in">getchar</span>())&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>) <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) flag=<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">else</span> num=ch-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="keyword">while</span>((ch=<span class="built_in">getchar</span>())&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>) num=num*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> num*flag; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">out</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&gt;=<span class="number">10</span>) <span class="built_in">out</span>(x/<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">putchar</span>(x%<span class="number">10</span>+<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m,cnt,fa,root;</span><br><span class="line"><span class="type">int</span> size[maxn],ls[maxn],rs[maxn],val[maxn],a[maxn];</span><br><span class="line"><span class="type">int</span> mapp[maxn];</span><br><span class="line"></span><br><span class="line"><span class="comment">/*此处有省略，平衡树部分请参照上文*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> opt[<span class="number">20</span>];</span><br><span class="line"><span class="type">int</span> k,l,r,i;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    n=<span class="built_in">read</span>();</span><br><span class="line">    m=<span class="built_in">read</span>();</span><br><span class="line">    <span class="built_in">newnode</span>(root,(<span class="number">1</span>&lt;&lt;<span class="number">30</span>));</span><br><span class="line">    l=<span class="number">233333</span>,r=n+<span class="number">233333</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> qaq;</span><br><span class="line">        qaq=<span class="built_in">read</span>();</span><br><span class="line">        <span class="built_in">insert</span>(root,i+<span class="number">233333</span>);</span><br><span class="line">        a[qaq]=i+<span class="number">233333</span>;</span><br><span class="line">        mapp[i+<span class="number">233333</span>]=qaq;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(m--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,opt);</span><br><span class="line">        <span class="keyword">if</span>(opt[<span class="number">0</span>]==<span class="string">&#x27;Q&#x27;</span>) &#123;</span><br><span class="line">            k=<span class="built_in">read</span>();</span><br><span class="line">            <span class="built_in">out</span>(mapp[<span class="built_in">find</span>(root,k)]);</span><br><span class="line">            <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(opt[<span class="number">0</span>]==<span class="string">&#x27;A&#x27;</span>) &#123;</span><br><span class="line">            k=<span class="built_in">read</span>();</span><br><span class="line">            <span class="built_in">out</span>(<span class="built_in">rnk</span>(root,a[k])<span class="number">-1</span>);</span><br><span class="line">            <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(opt[<span class="number">0</span>]==<span class="string">&#x27;T&#x27;</span>) &#123;</span><br><span class="line">            k=<span class="built_in">read</span>();</span><br><span class="line">            <span class="built_in">erase</span>(root,a[k]);</span><br><span class="line">            <span class="built_in">insert</span>(root,--l);</span><br><span class="line">            a[k]=l;</span><br><span class="line">            mapp[l]=k;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(opt[<span class="number">0</span>]==<span class="string">&#x27;B&#x27;</span>) &#123;</span><br><span class="line">            k=<span class="built_in">read</span>();</span><br><span class="line">            <span class="built_in">erase</span>(root,a[k]);</span><br><span class="line">            <span class="built_in">insert</span>(root,++r);</span><br><span class="line">            a[k]=r;</span><br><span class="line">            mapp[r]=k;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(opt[<span class="number">0</span>]==<span class="string">&#x27;I&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">register</span> <span class="type">int</span> s=<span class="built_in">read</span>(),t=<span class="built_in">read</span>();</span><br><span class="line">            <span class="keyword">if</span>(t==<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="type">int</span> rnk2=<span class="built_in">rnk</span>(root,a[s]),rnk1=rnk2+<span class="number">1</span>;</span><br><span class="line">                <span class="type">int</span> s2=<span class="built_in">find</span>(root,rnk1);</span><br><span class="line">                s2=mapp[s2];</span><br><span class="line">                <span class="built_in">erase</span>(root,a[s]);</span><br><span class="line">                <span class="built_in">erase</span>(root,a[s2]);</span><br><span class="line">                <span class="built_in">swap</span>(a[s],a[s2]);</span><br><span class="line">                mapp[a[s]]=s;</span><br><span class="line">                mapp[a[s2]]=s2;</span><br><span class="line">                <span class="built_in">insert</span>(root,a[s]);</span><br><span class="line">                <span class="built_in">insert</span>(root,a[s2]);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(t==<span class="number">-1</span>) &#123;</span><br><span class="line">                <span class="type">int</span> rnk2=<span class="built_in">rnk</span>(root,a[s]),rnk1=rnk2<span class="number">-1</span>;</span><br><span class="line">                <span class="type">int</span> s2=<span class="built_in">find</span>(root,rnk1);</span><br><span class="line">                s2=mapp[s2];</span><br><span class="line">                <span class="built_in">erase</span>(root,a[s]);</span><br><span class="line">                <span class="built_in">erase</span>(root,a[s2]);</span><br><span class="line">                <span class="built_in">swap</span>(a[s],a[s2]);</span><br><span class="line">                mapp[a[s]]=s;</span><br><span class="line">                mapp[a[s2]]=s2;</span><br><span class="line">                <span class="built_in">insert</span>(root,a[s]);</span><br><span class="line">                <span class="built_in">insert</span>(root,a[s2]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果这个吊打了splay ，和fhq-treap差不了多少</p><p>而且似乎比同种思路的treap快了300ms左右</p><h2 id="总结">总结</h2><p>WBLT有着显著的优缺点</p><p>优点是快（ <span class="math inline">\(\text{O}(n\log n)\)</span> 常数较小） 好记 码量小 且能实现很多功能</p><p>缺点是内存空间大，尽管可以用垃圾回收补偿，但是仍然需要两倍的空间</p><p>备注：本文实现方法是单旋，没法证复杂度同时也难以卡掉。2018集训队论文里介绍了双旋的实现，是复杂度正确的。</p>]]></content>
      
      
      <categories>
          
          <category> 算法竞赛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World!</title>
      <link href="/2023/05/08/Hello-World-0/"/>
      <url>/2023/05/08/Hello-World-0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>写博客的习惯从初中打 OI 就开始了，一直懒得自己部署 hexo 甚至懒得搬到 csdn ，于是一直在使用<a href="https://www.luogu.com.cn/blog/codesonic/">洛谷的博客</a>（甚至高数笔记都交到了洛谷博客上）。但是随着退役和对算法竞赛的不断淡出（虽然现在还在 ACM 队里），而写博客记笔记的欲望也没有减退，就找了个中午部署了这个 hexo 博客。以后有空会逐步把原来的博客的文章挑些比较有价值的搬运过来。</p><p>个人比较喜欢写写数学内容，将来也可能写点人工智能相关的笔记，也希望除开日常事务的繁忙，能多学点有趣的内容。当然随笔也是会写的。</p><p>如果想加友链可以联系我。</p><p>马上就要去上课了，写的应该比较凌乱，其他的内容以后再来慢慢完善和维护吧。</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Others </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
